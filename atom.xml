<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rick7dology</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-02-27T13:15:53.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Rick7</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Scrapy使用简介_1</title>
    <link href="http://yoursite.com/2018/02/28/Scrapy%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B-1/"/>
    <id>http://yoursite.com/2018/02/28/Scrapy使用简介-1/</id>
    <published>2018-02-27T17:22:12.000Z</published>
    <updated>2018-02-27T13:15:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="01x-前言"><a href="#01x-前言" class="headerlink" title="01x 前言"></a>01x 前言</h1><p>上一篇笔记记录了学习Python爬虫的简单思路，然后就要对Python爬虫框架进行基本使用了，玩玩更健康</p><h1 id="02x-Scrapy基本介绍"><a href="#02x-Scrapy基本介绍" class="headerlink" title="02x Scrapy基本介绍"></a>02x Scrapy基本介绍</h1><ul><li>基本数据流图解：</li></ul><p><img src="/images/scrapyworkflow.png" alt="数据流图"></p><ul><li>基本数据流程：</li></ul><ol><li>Spiders发送第一个URL给引擎</li><li>引擎从Spider中获取到第一个要爬取的URL后，在调度器(Scheduler)以Request调度</li><li>调度器把需要爬取的request返回给引擎</li><li>引擎将request通过下载中间件发给下载器(Downloader)去互联网下载数据</li><li>一旦数据下载完毕，下载器获取由互联网服务器发回来的Response，并将其通过下载中间件发送给引擎</li><li>引擎从下载器中接收到Response并通过Spider中间件发送给Spider处理</li><li>Spider处理Response并从中返回匹配到的Item及(跟进的)新的Request给引擎</li><li>引擎将(Spider返回的)爬取到的Item给Item Pipeline做数据处理或者入库保存，将(Spider返回的)Request给调度器入队列</li><li>(从第三步)重复直到调度器中没有更多的request</li></ol><ul><li>简单的说：</li></ul><p>引擎是大脑，负责在各组件中调度传递信息。我们要编写的几个主要组件就是spider，pipeline和中间件</p><ul><li>项目结构：</li></ul><p><img src="/images/structure.png" alt="项目结构图"></p><ul><li>编程思路：</li></ul><p>还是以猫眼这个简单例子，这次使用了scrapy来实现，首先编写maoyan_top.py,实现爬虫主程序，也就是定义一个爬虫，然后编写items.py定义一个存储数据的数据结构，类似dict，最后编写pipelines.py实现数据存储，这就是最简单的scrapy实现思路</p><ul><li>首先编写maoyan_top.py，主要就是编写MaoyanTopSpider类，这个类继承scrapy.Spider，定义好基本URL的数据后，就是主力编写parse函数，这个函数就是负责解析数据的。注意这里我yield了item给pipelines.py处理，yield了scrapy.Request给调度器进行翻页爬取</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> ..items <span class="keyword">import</span> MaoyanItem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaoyanTopSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">'maoyan_top'</span></span><br><span class="line">    allowed_domains = [<span class="string">'maoyan.com'</span>]</span><br><span class="line">    base_url = <span class="string">"https://maoyan.com/board/4?offset="</span></span><br><span class="line">    offset = <span class="number">0</span></span><br><span class="line">    start_urls = [base_url + str(offset)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line"></span><br><span class="line">        nodelist = response.xpath(<span class="string">"//div[@class='board-item-main']"</span>)</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> nodelist:</span><br><span class="line">            item = MaoyanItem()</span><br><span class="line">            item[<span class="string">'name'</span>] = node.xpath(<span class="string">".//a/text()"</span>).extract()[<span class="number">0</span>]</span><br><span class="line">            item[<span class="string">'actors'</span>] = node.xpath(<span class="string">".//p[@class='star']/text()"</span>).extract()[<span class="number">0</span>].split()</span><br><span class="line">            integer = node.xpath(<span class="string">".//i[@class='integer']/text()"</span>).extract()[<span class="number">0</span>]</span><br><span class="line">            fraction = node.xpath(<span class="string">".//i[@class='fraction']/text()"</span>).extract()[<span class="number">0</span>]</span><br><span class="line">            item[<span class="string">'score'</span>] = integer+fraction</span><br><span class="line">            <span class="keyword">yield</span> item</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.offset &lt; <span class="number">100</span>:</span><br><span class="line">            self.offset += <span class="number">10</span></span><br><span class="line">            url = self.base_url+str(self.offset)</span><br><span class="line">            <span class="keyword">yield</span> scrapy.Request(url,callback = self.parse)</span><br></pre></td></tr></table></figure><ul><li>然后编写items.py定义一个存储数据的数据结构给上面的parse函数使用,非常简单我就定义了三个字段，分别为电影的名字，评分和演员</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaoyanItem</span><span class="params">(scrapy.Item)</span>:</span></span><br><span class="line">    <span class="comment"># define the fields for your item here like:</span></span><br><span class="line">    name = scrapy.Field()</span><br><span class="line">    actors = scrapy.Field()</span><br><span class="line">    score = scrapy.Field()</span><br></pre></td></tr></table></figure><ul><li>最后编写pipelines.py进行存储数据，这里要注意parse函数yield出来的item会到达这里处理</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaoyanPipeline</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open_spider</span><span class="params">(self,spider)</span>:</span></span><br><span class="line">        print(type(spider))</span><br><span class="line">        print(<span class="string">"open file"</span>)</span><br><span class="line"></span><br><span class="line">        self.f = open(<span class="string">'/Users/Rick7/Desktop/items.json'</span>, <span class="string">'w+'</span>,encoding=<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line"></span><br><span class="line">        line = json.dumps(dict(item),ensure_ascii=<span class="keyword">False</span>) + <span class="string">"\n"</span></span><br><span class="line">        self.f.write(line)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close_spider</span><span class="params">(self,spider)</span>:</span></span><br><span class="line"></span><br><span class="line">        self.f.close()</span><br><span class="line">        print(<span class="string">"close file"</span>)</span><br></pre></td></tr></table></figure><ul><li>配置好setting文件激活管道，程序完成</li></ul><h1 id="03x-总结"><a href="#03x-总结" class="headerlink" title="03x 总结"></a>03x 总结</h1><ul><li>要学scrapy首先要搞清楚这个框架的数据流</li><li>建议阅读官方文档了解其中的类和方法</li><li>后面还会继续学习高级一点点的知识，例如url去重，中间件的使用等</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;01x-前言&quot;&gt;&lt;a href=&quot;#01x-前言&quot; class=&quot;headerlink&quot; title=&quot;01x 前言&quot;&gt;&lt;/a&gt;01x 前言&lt;/h1&gt;&lt;p&gt;上一篇笔记记录了学习Python爬虫的简单思路，然后就要对Python爬虫框架进行基本使用了，玩玩更健康&lt;/
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫小总结</title>
    <link href="http://yoursite.com/2018/02/28/Python%E7%88%AC%E8%99%AB%E5%B0%8F%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/02/28/Python爬虫小总结/</id>
    <published>2018-02-27T16:54:37.000Z</published>
    <updated>2018-02-27T09:15:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="01x-前言"><a href="#01x-前言" class="headerlink" title="01x 前言"></a>01x 前言</h1><p>最近玩了一下Python的爬虫，感觉这个东西对Python初学者还是挺友好的，适合入门Python</p><h1 id="02x-简单编程套路"><a href="#02x-简单编程套路" class="headerlink" title="02x 简单编程套路"></a>02x 简单编程套路</h1><ul><li>requests 库发送请求</li><li>Beautifulsoap,Xpath,Pyquiry,正则，等解释库提取数据</li><li>储存数据到文件或者数据库</li></ul><p>下面通过一个简单的对猫眼榜单的爬取代码体现上面的思路：</p><ul><li>get_onepage(url)函数发送请求，主要使用requests库</li><li>parse_onepage(content)函数负责解释和提取数据，主要使用了Beautifulsoap</li><li>save_csv(content)函数就是把数据保存到CSV文件</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_onepage</span><span class="params">(url)</span>:</span></span><br><span class="line">    headers = &#123;<span class="string">'user-agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) '</span></span><br><span class="line">                             <span class="string">'Chrome/60.0.3112.113 Safari/537.36'</span>&#125;</span><br><span class="line">    raw_content = requests.get(url,headers=headers)</span><br><span class="line">    raw_content.encoding = <span class="string">'utf-8'</span></span><br><span class="line">    <span class="comment"># print(raw_content.text)</span></span><br><span class="line">    <span class="keyword">return</span> raw_content.text</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_onepage</span><span class="params">(content)</span>:</span></span><br><span class="line">    soup = BeautifulSoup(content,<span class="string">'lxml'</span>)</span><br><span class="line">    movie_item = soup.find_all(<span class="string">'dd'</span>)</span><br><span class="line">    <span class="keyword">for</span> items <span class="keyword">in</span> movie_item:</span><br><span class="line">        dict = &#123;<span class="string">'index'</span>: <span class="string">''</span>, <span class="string">'title'</span>: <span class="string">''</span>, <span class="string">'star'</span>: <span class="string">''</span>&#125;</span><br><span class="line">        movie_index = items.find(<span class="string">'i'</span>,class_ = <span class="string">"board-index"</span>)</span><br><span class="line">        dict[<span class="string">'index'</span>] = movie_index.get_text()</span><br><span class="line">        movie_title = items.find(<span class="string">'p'</span>,attrs = &#123;<span class="string">'class'</span>: <span class="string">'name'</span>&#125;)</span><br><span class="line">        dict[<span class="string">'title'</span>] = movie_title.find(<span class="string">'a'</span>).get_text()</span><br><span class="line">        movie_actor = items.find(<span class="string">'p'</span>,attrs = &#123;<span class="string">'class'</span>: <span class="string">'star'</span>&#125;)</span><br><span class="line">        dict[<span class="string">'star'</span>] = movie_actor.get_text().strip()</span><br><span class="line">        <span class="keyword">yield</span> dict</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_csv</span><span class="params">(content)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">"/Users/Rick7/Desktop/data.csv"</span>,<span class="string">'a'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line">        fieldnames = [<span class="string">'index'</span>, <span class="string">'title'</span>, <span class="string">'star'</span>]</span><br><span class="line">        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)</span><br><span class="line">        writer.writeheader()</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> parse_onepage(content):</span><br><span class="line">            writer.writerow(item)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(offset_number)</span>:</span></span><br><span class="line">    url = <span class="string">"http://maoyan.com/board/4?offset="</span>+str(offset_number)</span><br><span class="line">    html = get_onepage(url)</span><br><span class="line">    save_csv(html)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        i=i*<span class="number">10</span></span><br><span class="line">        main(i)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h1 id="03x-总结"><a href="#03x-总结" class="headerlink" title="03x 总结"></a>03x 总结</h1><ul><li>这是最简单的爬虫小程序，从中要体会里面思路</li><li>上面的小程序只针对静态页面，对于动态的Ajax加载，使用过selenium，不过感觉十分慢和不友好，建议抓包找去真实的URL比较实际</li><li>比起beautifulsoap，感觉xpath提取数据更加高效简洁</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;01x-前言&quot;&gt;&lt;a href=&quot;#01x-前言&quot; class=&quot;headerlink&quot; title=&quot;01x 前言&quot;&gt;&lt;/a&gt;01x 前言&lt;/h1&gt;&lt;p&gt;最近玩了一下Python的爬虫，感觉这个东西对Python初学者还是挺友好的，适合入门Python&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>OAuth 2.0 学习笔记 </title>
    <link href="http://yoursite.com/2018/02/13/OAuth-2-0-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/02/13/OAuth-2-0-学习笔记/</id>
    <published>2018-02-13T15:47:52.000Z</published>
    <updated>2018-02-14T03:54:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="x01-前言"><a href="#x01-前言" class="headerlink" title="x01 前言"></a>x01 前言</h1><p>最近OAuth又出了一个漏洞，根据漏洞介绍这个漏洞不在OAuth协议，而在用户的部署上，等详细分析吧，漏洞链接如下，借此机会复习一下OAuth2.0</p><p><a href="http://www.cnvd.org.cn/flaw/show/CNVD-2018-01622" target="_blank" rel="noopener">http://www.cnvd.org.cn/flaw/show/CNVD-2018-01622</a></p><h1 id="x02-OAuth-2-0-流程"><a href="#x02-OAuth-2-0-流程" class="headerlink" title="x02 OAuth 2.0 流程"></a>x02 OAuth 2.0 流程</h1><p>详细的交换就不写了，网上一大堆，简单总结两句授权码模式（authorization code），包括了(用户A，网站B，GitHub(信息提供者,resource owner))</p><p>前提：网站B要想得到GitHub认证，必须先和GitHub协商可以取得什么权限等事情，这时候GitHub认可了网站B的合法性并同意网站B可以使用GitHub的相关用户资料，并给了网站B：Client Id 和 Client Secret。</p><ol><li><p>用户A想登陆网站B，但不想注册，所以点击了下面的GitHub图标，想通过GitHub账号登陆网站B,这时候就触发了OAuth认证</p></li><li><p>网站带着GitHub颁发的Client Id 到 ”<a href="https://github.com/login/oauth/authorize“" target="_blank" rel="noopener">https://github.com/login/oauth/authorize“</a> 请求权限，这时候会显示网站B从GitHub会取得什么权限，如果用户觉得ok就点击授权，不ok就拒绝，认证结束</p></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /authorize?response_type=code&amp;client_id=s6BhdRkqt3&amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1</span><br><span class="line">Host: github.com</span><br></pre></td></tr></table></figure><ol><li>当如何点击授权后，页面会跳转到网站B预先设定的 redirect_uri 并附带一个授权码(code)</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 302 Found</span><br><span class="line">Location: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA</span><br></pre></td></tr></table></figure><ol><li>用户A的浏览器得到一个302的回复，然后重定向到网站B指定redirect_uri，网站B从而得到了code，然后网站B拿着 code 和能够标识个人身份的 “client_id “,client_secret“ 去拜访 github，拿到access_token，这里的“client_id “,client_secret“ 是Github判断这个请求的合法性依据，”,client_secret“这个是网站B独有的。</li></ol><figure class="highlight"><table><tr><td class="code"><pre><span class="line">POST //github.com/login/oauth/access_token</span><br><span class="line">params = &#123;</span><br><span class="line">  code: "xxx",</span><br><span class="line">  client_id: "xxx",</span><br><span class="line">  client_secret: "xxx",</span><br><span class="line">  redirect_uri: "http://my-website.com"</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">response = &#123;</span><br><span class="line">  access_token: "e72e16c7e42f292c6912e7710c838347ae178b4a"</span><br><span class="line">  scope: "user,gist"</span><br><span class="line">  token_type: "bearer",</span><br><span class="line">  refresh_token: "xxxx"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>从上面的response中得到了access_token，相应的scope，网站B可以凭借这个token来取得用户在GitHub的信息，至于能够取得的信息范围就由scope来定义了，用户A可以使用GitHub的账号登陆网站B了。这就是授权码模式的简单描述。</li></ol><h1 id="x03-已知的安全问题-CSRF"><a href="#x03-已知的安全问题-CSRF" class="headerlink" title="x03 已知的安全问题-CSRF"></a>x03 已知的安全问题-CSRF</h1><ol><li>漏洞原理</li></ol><blockquote><p>这个问题的关键点在于，OAuth2的认证流程是分为好几步来完成的，在图1中的第4步，第三方应用在收到一个GET请求时，除了能知道当前用户的cookie，以及URL中的Authorization Code之外，难以分辨出这个请求到底是用户本人的意愿，还是攻击者利用用户的身份伪造出来的请求。 于是乎，攻击者就能使用移花接木的手段，提前准备一个含有自己的Authorization Code的请求，并让受害者的浏览器来接着完成后续的令牌申请流程。(知乎转载)</p></blockquote><ol><li>详细分析</li></ol><p>回顾一下上面简单总结的第四步：</p><blockquote><p>用户A的浏览器得到一个302的回复，然后重定向到网站B指定redirect_uri，网站B从而得到了code，然后网站B拿着 code 和能够标识个人身份的 “client_id “,client_secret“ 去拜访 github，拿到access_token，这里的“client_id “,client_secret“ 是Github判断这个请求的合法性依据，”,client_secret“这个是网站B独有的。</p></blockquote><p>这里面有个问题就是用户A的浏览器根据302状态码把code redirect到网站B,这个code是和将要登录网站B的账号关联的，如果攻击者替换了用户A这个请求，把里面的code换成攻击者账号的，然后网站B继续完成OAuth的认证流程，这会造成用户A在网站B的账号和攻击者的GitHub账号绑定了，攻击者只要在网站B通过GitHub登录就能成功登录用户A在网站B的账号了。<strong>因此这个漏洞本质是欺骗网站B</strong></p><p><img src="/images/CSRF OAuth.jpg" alt="攻击图"></p><ol><li>攻击成功条件</li></ol><ul><li>用户A的User Session是valid的</li><li>OAuth2提供者颁发的Authorization Code有效期很短，OAuth2官方推荐的时间是不大于10分钟，所以要快</li><li>一个Authorization Code只能被使用一次</li></ul><h1 id="x04-如何防御"><a href="#x04-如何防御" class="headerlink" title="x04 如何防御"></a>x04 如何防御</h1><p>刚才提到了，既然这个漏洞本质是欺骗网站B，那么要做防御的当然在网站B了，网站B要确保用户发去GitHub的授权码(Authorization Code)申请和用户redirect回来的授权码是一致的，怎么做呢？就是加一个唯一的，随机的参数state来确保唯一性</p><ul><li>首先，网站B redirect 用户A到GitHub申请授权码的时候带上”state=xyz“参数</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /authorize?response_type=code&amp;client_id=s6BhdRkqt3&amp;state=xyz</span><br><span class="line">        &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br></pre></td></tr></table></figure><ul><li>然后，用户A的浏览器收到GitHub发来的302带着授权码redirect回到B网站时，GitHub会根据申请code时的请求在302的location中带上”state=xyz“</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 302 Found</span><br><span class="line">Location: https://B.com/cb?code=SplxlOBeZQQYbYS6WxSbIA</span><br><span class="line">          &amp;state=xyz</span><br></pre></td></tr></table></figure><ul><li><p>这样网站B就可以根据state参数确认这个code对应哪一个用户了</p></li><li><p>要避免遭受本文提到的CSRF攻击问题，需要第三方应用正确的使用state参数</p></li></ul><h1 id="Refer-link"><a href="#Refer-link" class="headerlink" title="Refer link"></a>Refer link</h1><p><a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html</a></p><p><a href="https://aaronparecki.com/oauth-2-simplified/" target="_blank" rel="noopener">https://aaronparecki.com/oauth-2-simplified/</a></p><p><a href="https://www.zhihu.com/question/19781476" target="_blank" rel="noopener">https://www.zhihu.com/question/19781476</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;x01-前言&quot;&gt;&lt;a href=&quot;#x01-前言&quot; class=&quot;headerlink&quot; title=&quot;x01 前言&quot;&gt;&lt;/a&gt;x01 前言&lt;/h1&gt;&lt;p&gt;最近OAuth又出了一个漏洞，根据漏洞介绍这个漏洞不在OAuth协议，而在用户的部署上，等详细分析吧，漏洞链
      
    
    </summary>
    
    
      <category term="Web security" scheme="http://yoursite.com/tags/Web-security/"/>
    
  </entry>
  
  <entry>
    <title>Same-Origin Protection (SOP)</title>
    <link href="http://yoursite.com/2018/02/09/Same-Origin-Protection-SOP/"/>
    <id>http://yoursite.com/2018/02/09/Same-Origin-Protection-SOP/</id>
    <published>2018-02-09T10:39:27.000Z</published>
    <updated>2018-02-09T07:54:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="x01-什么是同源策略-SOP"><a href="#x01-什么是同源策略-SOP" class="headerlink" title="x01 什么是同源策略(SOP)"></a>x01 什么是同源策略(SOP)</h1><p>在Web安全中，SOP是一个非常重要安全策略，必须要弄懂才能对很多攻击有更加清晰的理解，那什么是同源策略呢？下面是我本人的理解：</p><p><strong>同源策略是一个浏览器中内建的安全策略，它确保不同源的网站不能互相作用或者互相交换。</strong></p><ul><li><p>不同源指的是协议(https,http,ftp…),不同端口(80,443,22,21),不同域名。</p></li><li><p>不能互相作用或者互相交换是指：A网站即使和B网站不同源，但仍然可以发送request到B网站，这个请求在B网站还是会处理的，但A网站不能读取response，总结一句就是：跨域请求是可以发去的，但是请求响应response被浏览器堵塞了，所以说同源策略是限制了不同源的读，但不限制不同源的写</p></li><li><p>由于同源策略的限制，跨域的ajax请求不会带cookie，然而script/iframe/img等标签却是支持跨域的，所以在请求的时候是会带上cookie的，这使得CSRF攻击有可乘之机</p></li></ul><h1 id="x02-CSRF攻击"><a href="#x02-CSRF攻击" class="headerlink" title="x02 CSRF攻击"></a>x02 CSRF攻击</h1><ul><li>由于同源策略的限制，跨域的ajax请求不会带cookie，然而script/iframe/img等标签却是支持跨域的，所以在请求的时候是会带上cookie的。如果用户登陆了Abank.com，那么cookie里面就有了tocken，同时又打开了另外一个标签页访问了evil.com，这个网页里面有一个iframe:</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://Abank.com/app/transferFunds?amount=1500&amp;destinationAccount="</span><span class="attr">attackeraccountnumber</span>" &gt;</span></span><br></pre></td></tr></table></figure><ul><li>防CSRF攻击的策略就是将token添加到请求的参数里面，也就是说每个需要验证身份的请求都要显式地带上token值,目的就是让请求不可预知，就算攻击者得到了你的登录token，也没有办法构造转账的请求，因为转账的请求带有一个不可预知的，随机的token作为保护，当然也可以加入一些人机交换，例如验证码之类的</li></ul><h1 id="x03-Cross-domain-和-Silverlight-的跨越配置文件"><a href="#x03-Cross-domain-和-Silverlight-的跨越配置文件" class="headerlink" title="x03 Cross-domain 和 Silverlight 的跨越配置文件"></a>x03 Cross-domain 和 Silverlight 的跨越配置文件</h1><p>这两个配置文件必须设置严格，防止不必要跨域</p><h1 id="Refer-link"><a href="#Refer-link" class="headerlink" title="Refer link"></a>Refer link</h1><p><a href="https://www.gracefulsecurity.com/cross-domain-flash-and-silverlight-crossdomain-xml/" target="_blank" rel="noopener">https://www.gracefulsecurity.com/cross-domain-flash-and-silverlight-crossdomain-xml/</a></p><p><a href="https://www.gracefulsecurity.com/what-is-cross-site-request-forgery/" target="_blank" rel="noopener">https://www.gracefulsecurity.com/what-is-cross-site-request-forgery/</a></p><p><a href="http://www.veracode.com/security/csrf" target="_blank" rel="noopener">http://www.veracode.com/security/csrf</a></p><p><a href="http://yincheng.site/cross-domain" target="_blank" rel="noopener">http://yincheng.site/cross-domain</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;x01-什么是同源策略-SOP&quot;&gt;&lt;a href=&quot;#x01-什么是同源策略-SOP&quot; class=&quot;headerlink&quot; title=&quot;x01 什么是同源策略(SOP)&quot;&gt;&lt;/a&gt;x01 什么是同源策略(SOP)&lt;/h1&gt;&lt;p&gt;在Web安全中，SOP是一个非常
      
    
    </summary>
    
    
      <category term="Web security" scheme="http://yoursite.com/tags/Web-security/"/>
    
  </entry>
  
  <entry>
    <title>XXE 攻击(2)</title>
    <link href="http://yoursite.com/2018/02/08/XXE-%E6%94%BB%E5%87%BB%E2%80%94%E2%80%942/"/>
    <id>http://yoursite.com/2018/02/08/XXE-攻击——2/</id>
    <published>2018-02-07T20:57:37.000Z</published>
    <updated>2018-02-07T14:00:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在上一遍文章中提到了XML的格式定义DTD存在外部实体引用攻击，这次来学习一下主流的XML格式定义XML Schema，刚好最近上了java的spring培训，里面定义beans的时候主要配置的就是XML文档，所以也是时候再学学xml的相关知识了，网上很多相关文章，主要记录一些和安全相关的设置吧</p><h1 id="x01-XML-Schema-基础"><a href="#x01-XML-Schema-基础" class="headerlink" title="x01 XML Schema 基础"></a>x01 XML Schema 基础</h1><p>XML Schema 描述了 XML文档的结构，也是由 XML 编写，其中Schema可以理解为约束、概要，但不推荐使用中文进行记忆，Schema就是Schema</p><ul><li>一个普通的xml文档：</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">to</span>&gt;</span>Tove<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">from</span>&gt;</span>Jani<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">heading</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span>Don't forget me this weekend!<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>一个XML Schema定义</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">xs:schema</span> <span class="attr">xmlns:xs</span>=<span class="string">"http://www.w3.org/2001/XMLSchema"</span></span></span><br><span class="line"><span class="tag"><span class="attr">targetNamespace</span>=<span class="string">"http://www.w3schools.com"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns</span>=<span class="string">"http://www.w3schools.com"</span></span></span><br><span class="line"><span class="tag"><span class="attr">elementFormDefault</span>=<span class="string">"qualified"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">"note"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">xs:complexType</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xs:sequence</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">"to"</span> <span class="attr">type</span>=<span class="string">"xs:string"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">"from"</span> <span class="attr">type</span>=<span class="string">"xs:string"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">"heading"</span> <span class="attr">type</span>=<span class="string">"xs:string"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">"body"</span> <span class="attr">type</span>=<span class="string">"xs:string"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xs:sequence</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">xs:complexType</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xs:element</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">xs:schema</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>第一句代表xml版本号，1.0版本</li><li><xs:schema> </xs:schema> schema的根元素</li><li>xmlns:xs=”<a href="http://www.w3.org/2001/XMLSchema" target="_blank" rel="noopener">http://www.w3.org/2001/XMLSchema</a>“ 代表schema 中用到的元素和数据类型来自命名空间 “<a href="http://www.w3.org/2001/XMLSchema&quot;。同时它还规定了来自命名空间" target="_blank" rel="noopener">http://www.w3.org/2001/XMLSchema&quot;。同时它还规定了来自命名空间</a> “<a href="http://www.w3.org/2001/XMLSchema" target="_blank" rel="noopener">http://www.w3.org/2001/XMLSchema</a>“ 的元素和数据类型应该使用前缀 xs：</li><li>targetNamespace=”<a href="http://www.runoob.com" target="_blank" rel="noopener">http://www.runoob.com</a>“ 显示被此 schema 定义的元素 (note, to, from, heading, body) 来自命名空间： “<a href="http://www.runoob.com&quot;。" target="_blank" rel="noopener">http://www.runoob.com&quot;。</a></li><li>xmlns=”<a href="http://www.runoob.com" target="_blank" rel="noopener">http://www.runoob.com</a>“ xmlns=”<a href="http://www.runoob.com" target="_blank" rel="noopener">http://www.runoob.com</a>“</li><li>elementFormDefault=”qualified” 指出任何 XML 实例文档所使用的且在此 schema 中声明过的元素必须被命名空间限定。</li><li>后面是各种元素定义，数据类型定义等</li></ol><p>详细的关于XML Schema定义可以参考下面的链接</p><p><a href="http://www.runoob.com/schema/schema-schema.html" target="_blank" rel="noopener">http://www.runoob.com/schema/schema-schema.html</a></p><ul><li>xml文档引用上面定义的Schema:note.xsd(这是重点要理解的)</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">note</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns</span>=<span class="string">"http://www.w3schools.com"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.w3schools.com note.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">to</span>&gt;</span>Tove<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">from</span>&gt;</span>Jani<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">heading</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span>Don't forget me this weekend!<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>xmlns=”<a href="http://www.w3schools.com" target="_blank" rel="noopener">http://www.w3schools.com</a>“ 定义了默认的命名空间，如果没有定义其他的命名空间，XML 文档会使用这个作为schema 验证器</li><li>xmlns:xsi=”<a href="http://www.w3.org/2001/XMLSchema-instance" target="_blank" rel="noopener">http://www.w3.org/2001/XMLSchema-instance</a>“ 定义了一个指定的命名空间，并把这个空间 alias - xsi(别名)</li><li>xsi:schemaLocation=”<a href="http://www.w3schools.com" target="_blank" rel="noopener">http://www.w3schools.com</a> note.xsd”&gt; 定义了xsi的schemaLocation属性，格式为：namespace and XSD-location-URI，中间用换行符或者空格作为分隔符</li></ol><p>下来来自stackoverflow的详细解释，好明白的讲解：</p><p><a href="https://stackoverflow.com/questions/34202967/xmlns-xmlnsxsi-xsischemalocation-and-targetnamespace" target="_blank" rel="noopener">https://stackoverflow.com/questions/34202967/xmlns-xmlnsxsi-xsischemalocation-and-targetnamespace</a></p><h1 id="x02-XML-Schema攻击的分类"><a href="#x02-XML-Schema攻击的分类" class="headerlink" title="x02 XML Schema攻击的分类"></a>x02 XML Schema攻击的分类</h1><p>XML Schema攻击分为,下面的没有怎么研究，希望日后可以补充，都是看家人的总结来的</p><p>1.schemaLocation</p><p>2.noNamespaceSchemaLocation</p><p>3.XInclude。</p><p>4.XSLT 攻击</p><p>refer link</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzIwNDI4MzAwOA==&amp;mid=2650524176&amp;idx=1&amp;sn=e1f8ebb128ae248d69e2947e4ac9bcf2&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzIwNDI4MzAwOA==&amp;mid=2650524176&amp;idx=1&amp;sn=e1f8ebb128ae248d69e2947e4ac9bcf2&amp;scene=21#wechat_redirect</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在上一遍文章中提到了XML的格式定义DTD存在外部实体引用攻击，这次来学习一下主流的XML格式定义XML Schema，刚好最近上了java
      
    
    </summary>
    
    
      <category term="Web security" scheme="http://yoursite.com/tags/Web-security/"/>
    
  </entry>
  
  <entry>
    <title>XXE 攻击</title>
    <link href="http://yoursite.com/2018/02/06/XXE-%E6%94%BB%E5%87%BB/"/>
    <id>http://yoursite.com/2018/02/06/XXE-攻击/</id>
    <published>2018-02-06T11:14:30.000Z</published>
    <updated>2018-02-06T15:24:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="x01-什么是-XXE"><a href="#x01-什么是-XXE" class="headerlink" title="x01 什么是 XXE"></a>x01 什么是 XXE</h1><p>XXE：XML External Entity，即外部实体攻击,其本质是利用应用过滤不严格进行xml语句的注入攻击，感觉应该属于注入攻击的一种，</p><h1 id="x02-XML-文档的DTD"><a href="#x02-XML-文档的DTD" class="headerlink" title="x02 XML 文档的DTD"></a>x02 XML 文档的DTD</h1><p>文档类型定义（DTD）可定义合法的XML文档构建模块。它使用一系列合法的元素来定义文档的结构，包括定义了XML文档的元素(!ELEMENT)，属性(!ATTLIST)，实体(!ENTITY),<strong>其中实体的定义为：实体是用于定义引用普通文本或特殊字符的快捷方式的变量。类似于定义了一个变量</strong></p><p>详细的DTD定义可以参考下面的链接：</p><p><a href="http://www.runoob.com/dtd/dtd-building.html" target="_blank" rel="noopener">http://www.runoob.com/dtd/dtd-building.html</a></p><h1 id="x03-内部实体和外部实体"><a href="#x03-内部实体和外部实体" class="headerlink" title="x03 内部实体和外部实体"></a>x03 内部实体和外部实体</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">DTD 定义内部实体</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">!ENTITY</span> <span class="attr">writer</span> "<span class="attr">Donald</span> <span class="attr">Duck.</span>"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">!ENTITY</span> <span class="attr">copyright</span> "<span class="attr">Copyright</span> <span class="attr">runoob.com</span>"&gt;</span></span><br><span class="line"></span><br><span class="line">XML引用上面实体的内部定义：</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">author</span>&gt;</span>&amp;writer;&amp;copyright;<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">DTD 定义外部实体，加了一个SYSTEM关键字</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">!ENTITY</span> <span class="attr">writer</span> <span class="attr">SYSTEM</span> "<span class="attr">http:</span>//<span class="attr">www.runoob.com</span>/<span class="attr">entities.dtd</span>"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">!ENTITY</span> <span class="attr">copyright</span> <span class="attr">SYSTEM</span> "<span class="attr">http:</span>//<span class="attr">www.runoob.com</span>/<span class="attr">entities.dtd</span>"&gt;</span></span><br><span class="line"></span><br><span class="line">XML引用上面定义的外部实体</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">author</span>&gt;</span>&amp;writer;&amp;copyright;<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="x04-XXE-攻击PAYLOAD"><a href="#x04-XXE-攻击PAYLOAD" class="headerlink" title="x04 XXE 攻击PAYLOAD"></a>x04 XXE 攻击PAYLOAD</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE foo [</span></span><br><span class="line"><span class="meta">    &lt;!ELEMENT foo ANY &gt;</span></span><br><span class="line"><span class="meta">    &lt;!ENTITY  xxe SYSTEM "file:///c:/windows/win.ini" &gt; #定义了外部实体引用</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">foo</span>&gt;</span>&amp;xxe;<span class="tag">&lt;/<span class="name">foo</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="x05-XXE攻击原理"><a href="#x05-XXE攻击原理" class="headerlink" title="x05 XXE攻击原理"></a>x05 XXE攻击原理</h1><p>在 XML1.0 标准里，XML文档里的实体的标识符可以访问本地远程内容，如果在外部实体引用的过程中，注入恶意代码，即可引发信息泄露等安全问题。</p><p>比如上述示例中所演示的 URI，即可读取 passwd 中的敏感信息。</p><h1 id="x06-攻击方式"><a href="#x06-攻击方式" class="headerlink" title="x06 攻击方式"></a>x06 攻击方式</h1><ul><li><p>有回显</p></li><li><p>无回显</p></li></ul><p>具体就不继续了，网上一大堆文章，反正了解了核心概念就可以了，其他利用姿势自行Google</p><h1 id="07-如何防御"><a href="#07-如何防御" class="headerlink" title="07 如何防御"></a>07 如何防御</h1><p>可以将 libxml 版本升级到 2.9.0 以后，因为 libxml 2.9.0 以后默认是不解析外部实体的，还要做输入过滤，错误处理等，反正应对注入的措施都要有</p><h1 id="Bonus"><a href="#Bonus" class="headerlink" title="Bonus"></a>Bonus</h1><p>XML Schema 很快会将 DTD 取而代之，但 XML Schema 也会存在注入的问题，这个后面再慢慢看，还有Xpath注入等，关于xml的安全问题还是由很多的</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://mp.weixin.qq.com/s/vkCdz6YCoiiJPI30KePD6g" target="_blank" rel="noopener">http://mp.weixin.qq.com/s/vkCdz6YCoiiJPI30KePD6g</a></p><p><a href="http://www.runoob.com/dtd/dtd-summary.html" target="_blank" rel="noopener">http://www.runoob.com/dtd/dtd-summary.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;x01-什么是-XXE&quot;&gt;&lt;a href=&quot;#x01-什么是-XXE&quot; class=&quot;headerlink&quot; title=&quot;x01 什么是 XXE&quot;&gt;&lt;/a&gt;x01 什么是 XXE&lt;/h1&gt;&lt;p&gt;XXE：XML External Entity，即外部实体攻击,其本
      
    
    </summary>
    
    
      <category term="Web security" scheme="http://yoursite.com/tags/Web-security/"/>
    
  </entry>
  
  <entry>
    <title>Jekins security related</title>
    <link href="http://yoursite.com/2018/02/05/Jekins-security-related-doc/"/>
    <id>http://yoursite.com/2018/02/05/Jekins-security-related-doc/</id>
    <published>2018-02-05T15:08:20.000Z</published>
    <updated>2018-02-05T07:11:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>一些Jekins安全配置和漏洞的文章：</p><p><a href="https://www.blackhat.com/docs/eu-15/materials/eu-15-Mittal-Continuous-Intrusion-Why-CI-Tools-Are-An-Attackers-Best-Friend.pdf" target="_blank" rel="noopener">https://www.blackhat.com/docs/eu-15/materials/eu-15-Mittal-Continuous-Intrusion-Why-CI-Tools-Are-An-Attackers-Best-Friend.pdf</a></p><p><a href="https://www.sans.org/reading-room/whitepapers/bestprac/securing-jenkins-ci-systems-36872" target="_blank" rel="noopener">https://www.sans.org/reading-room/whitepapers/bestprac/securing-jenkins-ci-systems-36872</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一些Jekins安全配置和漏洞的文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.blackhat.com/docs/eu-15/materials/eu-15-Mittal-Continuous-Intrusion-Why-CI-Tools-Are-An-A
      
    
    </summary>
    
    
      <category term="Jekins" scheme="http://yoursite.com/tags/Jekins/"/>
    
  </entry>
  
  <entry>
    <title>Java由反射到命令执行</title>
    <link href="http://yoursite.com/2018/02/01/Java%E7%94%B1%E5%8F%8D%E5%B0%84%E5%88%B0%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"/>
    <id>http://yoursite.com/2018/02/01/Java由反射到命令执行/</id>
    <published>2018-01-31T17:26:50.000Z</published>
    <updated>2018-02-01T09:55:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-什么是Java反射和应用场景"><a href="#1-什么是Java反射和应用场景" class="headerlink" title="1 什么是Java反射和应用场景"></a>1 什么是Java反射和应用场景</h1><ul><li>详细的反射教程可以参考下面的链接，讲得超级详细，简单讲就是在程序运行时动态获得类的属性和方法，并可以动态创建对象</li></ul><p><a href="http://www.sczyh30.com/posts/Java/java-reflection-1/#%E4%B8%80%E3%80%81%E5%9B%9E%E9%A1%BE%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%EF%BC%9F" target="_blank" rel="noopener">关于反射的详解教程请点我</a></p><ul><li>应用场景</li></ul><blockquote><p>当我们在使用IDE(如Eclipse，IDEA)时，当我们输入一个对象或类并想调用它的属性或方法时，一按点号，编译器就会自动列出它的属性或方法，这里就会用到反射。反射最重要的用途就是开发各种通用框架。<br>很多框架（比如Spring）都是配置化的（比如通过XML文件配置JavaBean,Action之类的），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。</p></blockquote><ul><li>简单介绍几个主要方法，详解的用法可以参考我上面给的链接</li></ul><ol><li>加载类，得到指定类的Class对象</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"com.yano.reflect.Consumer"</span>);</span><br><span class="line">Class clazz1 = <span class="keyword">new</span> Consumer().getClass();</span><br><span class="line">Class class2 = Person.class;</span><br></pre></td></tr></table></figure><ol><li>创建实例</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法一：</span><br><span class="line">Class&lt;?&gt; c = String.class;</span><br><span class="line">Object str = c.newInstance();</span><br><span class="line">方法二：</span><br><span class="line"><span class="comment">//获取String所对应的Class对象</span></span><br><span class="line">Class&lt;?&gt; c = String.class;</span><br><span class="line"><span class="comment">//获取String类带一个String参数的构造器</span></span><br><span class="line">Constructor constructor = c.getConstructor(String.class);</span><br><span class="line"><span class="comment">//根据构造器创建实例</span></span><br><span class="line">Object obj = constructor.newInstance(<span class="string">"23333"</span>);</span><br><span class="line">System.out.println(obj);</span><br></pre></td></tr></table></figure><ol><li>获取方法</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getMethod方法返回一个特定的方法，其中第一个参数为方法名称，后面的参数为方法的参数对应Class的对象</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Method <span class="title">getMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span></span></span><br></pre></td></tr></table></figure><h1 id="2-Java的命令执行类："><a href="#2-Java的命令执行类：" class="headerlink" title="2 Java的命令执行类："></a>2 Java的命令执行类：</h1><ul><li>java.lang.Runtime类,下面是官方文档解释</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Runtime extends Object</span><br><span class="line"></span><br><span class="line">Every Java application has a single instance of class Runtime that allows the application to interface with the environment in which the application is running. The current runtime can be obtained from the getRuntime method.</span><br><span class="line">An application cannot create its own instance of this class.</span><br></pre></td></tr></table></figure><ul><li>其中主要的方法是：getRuntime(),得到一个和当前程序相关联的Runtime类的对象，文档解释如下：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static Runtime getRuntime()</span><br><span class="line">Returns the runtime object associated with the current Java application. Most of the methods of class Runtime are instance methods and must be invoked with respect to the current runtime object.</span><br><span class="line">Returns:</span><br><span class="line">the Runtime object associated with the current Java application.</span><br></pre></td></tr></table></figure><ul><li>这个Runtime对象再调用exec()方法执行命令，详细文档解释如下：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Process exec(String command)</span><br><span class="line">             throws IOException</span><br><span class="line">Executes the specified string command in a separate process.</span><br><span class="line">This is a convenience method. An invocation of the form exec(command) behaves in exactly the same way as the invocation exec(command, null, null).</span><br></pre></td></tr></table></figure><ul><li>最后综合使用,在我的mac打开了计算器程序</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, IOException </span>&#123;</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">"open /Applications/Calculator.app/"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-命令执行漏洞的实现，如何取得Runtime类是关键，其中一种常用方式就是通过反射"><a href="#3-命令执行漏洞的实现，如何取得Runtime类是关键，其中一种常用方式就是通过反射" class="headerlink" title="3 命令执行漏洞的实现，如何取得Runtime类是关键，其中一种常用方式就是通过反射"></a>3 命令执行漏洞的实现，如何取得Runtime类是关键，其中一种常用方式就是通过反射</h1><ol><li>场景一 Android API17 前的Webview加了addJavascriptInterface()方法，映射了一个Java对象到js中</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebAppInterface</span> </span>&#123;</span><br><span class="line">    Context mContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Instantiate the interface and set the context */</span></span><br><span class="line">    WebAppInterface(Context c) &#123;</span><br><span class="line">        mContext = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Show a toast from the web page */</span></span><br><span class="line">    <span class="comment">/*@JavascriptInterface  /*新的要求，加注解,API17以上*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showToast</span><span class="params">(String toast)</span> </span>&#123;</span><br><span class="line">        Toast.makeText(mContext, toast, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WebView webView = (WebView) findViewById(R.id.webview);</span><br><span class="line">webView.addJavascriptInterface(<span class="keyword">new</span> WebAppInterface(<span class="keyword">this</span>), <span class="string">"Android"</span>);</span><br></pre></td></tr></table></figure><ul><li>上面这段Android代码中，把WebAppInterface类映射到了js中的的Android对象上，所以可以在js中调用WebAppInterface类的方法</li></ul><p>对于强迫症患者，一定会疑惑这个“Android”在js中算什么，类？还是实例？，下面一段是Google文档的解释,Webview帮我们初始化好这个js的”Android”对象，可以直接在JavaScript中调用</p><blockquote><p>You can bind this class to the JavaScript that runs in your WebView with addJavascriptInterface() and name the interface Android. For example:<br>This creates an interface called Android for JavaScript running in the WebView. At this point, your web application has access to the WebAppInterface class. For example, here’s some HTML and JavaScript that creates a toast message using the new interface when the user clicks a button:<br>There’s no need to initialize the Android interface from JavaScript. The WebView automatically makes it available to your web page. So, at the click of the button, the showAndroidToast() function uses the Android interface to call the WebAppInterface.showToast() method.</p></blockquote><ul><li>结合前面的Java反射知识，既然暴露了Java对象给JavaScript操作，首先可以通过这个这个对象的“getClass()”方法获得对应类的Class对象，然后调用Class对象的”forname()”方法加载指定的“Runtime”类，这个特殊的“Runtime”类再调用”getmethod()”方法调用类里面的getruntime方法，返回一个Method对象，最后调用”invoke()”方法执行Runtime类的exec()方法。。。这就是整个思路了</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.test;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebAppInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showToast</span><span class="params">(String toast)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"just a test class"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException,</span></span><br><span class="line"><span class="function">            InstantiationException, IOException, NoSuchMethodException, InvocationTargetException </span>&#123;</span><br><span class="line">        WebAppInterface Android = <span class="keyword">new</span> WebAppInterface();<span class="comment">/* 模拟一个可以被js调用的实例 */</span></span><br><span class="line">        Method method = Android.getClass().forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>,<span class="keyword">null</span>);</span><br><span class="line">        Runtime run = (Runtime) method.invoke(<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        run.exec(<span class="string">"open /Applications/Calculator.app/"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/RCE.jpg" alt="效果图"></p><h1 id="Bonus"><a href="#Bonus" class="headerlink" title="Bonus"></a>Bonus</h1><p>关于Java泛型的一点讲解：泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p><p><a href="https://www.jianshu.com/p/95f349258afb" target="_blank" rel="noopener">详细的Java 泛型讲解请点击我</a></p><ol><li>不用泛型直接通过反射创建类的实例，需要进行强制类型转换</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Consumer clazz;</span><br><span class="line">clazz = (Consumer) Class.forName(<span class="string">"com.company.hsbc.Consumer"</span>).newInstance();</span><br></pre></td></tr></table></figure><ol><li>用object类型可以解决问题</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object clazz;</span><br><span class="line">clazz = Class.forName(<span class="string">"com.company.hsbc.Consumer"</span>).newInstance();</span><br></pre></td></tr></table></figure><h1 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-什么是Java反射和应用场景&quot;&gt;&lt;a href=&quot;#1-什么是Java反射和应用场景&quot; class=&quot;headerlink&quot; title=&quot;1 什么是Java反射和应用场景&quot;&gt;&lt;/a&gt;1 什么是Java反射和应用场景&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;详细的反射教程可
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Android支付宝克隆漏洞</title>
    <link href="http://yoursite.com/2018/01/30/Android%E6%94%AF%E4%BB%98%E5%AE%9D%E5%85%8B%E9%9A%86%E6%BC%8F%E6%B4%9E/"/>
    <id>http://yoursite.com/2018/01/30/Android支付宝克隆漏洞/</id>
    <published>2018-01-30T15:54:33.000Z</published>
    <updated>2018-01-30T09:32:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章介绍了Android Webview组件的安全问题，其中一个就是file域访问限制不严格导致数据泄露，前段时间很火的支付宝克隆漏洞也是基于file协议的权限设置不当造成的，参考了很多文章总结一下攻击流程：</p><h1 id="1-克隆漏洞基本原理解释："><a href="#1-克隆漏洞基本原理解释：" class="headerlink" title="1 克隆漏洞基本原理解释："></a>1 克隆漏洞基本原理解释：</h1><ul><li><p>Step 1 ：通过 URL Scheme 的方式唤起打开 App 里暴露出去的(export=true)带 WebView 组件的 Activity , 这里需要得到支付宝的Scheme，然后通过这些Scheme打开Webview</p></li><li><p>Step 2 ：在发送给目标的网页中通过a标签调用支付宝带 WebView 组件的 Activity，从而实现在支付宝中打开Webview</p></li><li><p>Step 3 ：Webview加载攻击者的攻击脚本到本地SD卡的download目录：</p></li><li><p>Step 4 ：再利用file协议加载攻击者存在本地的脚本</p></li><li><p>Step 5 ：由于这个Webview是通过支付宝打开的，再通过file协议读取本地攻击脚本，所以本地攻击脚本实际是支付宝打开的，可以读取支付宝沙盒进程的个人用户数据，并上传回服务器，到此，攻击完成，成功得到用户的支付宝数据</p></li><li><p>Step 6 ：攻击者加载目标用户的支付宝数据，支付宝没有二次验证机器指纹直接默认登录成功，攻击者可以使用用户的支付宝进行支付</p></li></ul><h1 id="2-漏洞利用的关键点："><a href="#2-漏洞利用的关键点：" class="headerlink" title="2 漏洞利用的关键点："></a>2 漏洞利用的关键点：</h1><ol><li>在 Step 1 中：</li></ol><p>这里使用了支付宝定义的URL Scheme，如何得到有效的Scheme，使得可以通过a标签启动支付宝的Webview，这是一个关键点</p><ol><li><p>在 Step 2 中：<br>构造一个网页，网页代码要包含：1.启动支付宝的Webview  2.下载攻击脚本到本地SD卡的download目录 3.利用file协议加载本地攻击脚本</p></li><li><p>在 Step 5 中：<br>下载到本地的攻击脚本再一次利用file协议读取支付宝的个人数据，并上传到攻击者的服务器或者设备中</p></li><li><p>攻击成功的两个关键点：</p></li></ol><ul><li><p>WebView中setAllowFileAccessFromFileURLs 或setAllowUniversalAccessFromFileURLsAPI配置为true；</p></li><li><p>WebView可以直接被外部调用，并能够加载外部可控的HTML文件</p></li></ul><h1 id="3-相关技术介绍："><a href="#3-相关技术介绍：" class="headerlink" title="3 相关技术介绍："></a>3 相关技术介绍：</h1><ul><li>什么是URL Scheme：</li></ul><blockquote><p>android中的scheme是一种页面内跳转协议，是一种非常好的实现机制，通过定义自己的scheme协议，可以非常方便跳转app中的各个页面；通过scheme协议，服务器可以定制化告诉App跳转那个页面，可以通过通知栏消息定制化跳转页面，可以通过H5页面跳转页面等。</p><p>客户端应用可以向操作系统注册一个 URL scheme，该 scheme 用于从浏览器或其他应用中启动本应用。通过指定的 URL 字段，可以让应用在被调起后直接打开某些特定页面，比如商品详情页、活动详情页等等。也可以执行某些指定动作，如完成支付等。也可以在应用内通过 html 页来直接调用显示 app 内的某个页面</p></blockquote><h1 id="4-总结："><a href="#4-总结：" class="headerlink" title="4 总结："></a>4 总结：</h1><p>这次的克隆漏洞利用的都是Android Webview的已知漏洞，但却玩出了新花样，但却引出了一些问题，例如Chrome打开网页自动下载没有一丁点提示，支付宝没有对用户进行二次设备验证等</p><h1 id="5-refer-link："><a href="#5-refer-link：" class="headerlink" title="5 refer link："></a>5 refer link：</h1><p>关于Android平台WebView控件存在跨域访问高危漏洞的安全公告<br><a href="http://www.cnvd.org.cn/webinfo/show/4365?from=timeline&amp;isappinstalled=0" target="_blank" rel="noopener">http://www.cnvd.org.cn/webinfo/show/4365?from=timeline&amp;isappinstalled=0</a></p><p>“应用克隆”攻击模型<br><a href="https://mp.weixin.qq.com/s/pQqOLQS_hWfv8btYpYK1xQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/pQqOLQS_hWfv8btYpYK1xQ</a></p><p>Android安全开发之浅谈网页打开APP<br><a href="https://yq.aliyun.com/articles/57088" target="_blank" rel="noopener">https://yq.aliyun.com/articles/57088</a></p><p>Webview跨源攻击分析<br><a href="http://blogs.360.cn/360mobile/2014/09/22/webview%E8%B7%A8%E6%BA%90%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">http://blogs.360.cn/360mobile/2014/09/22/webview%E8%B7%A8%E6%BA%90%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/</a></p><p>Attack Your Android Apps By Webview<br><a href="http://blog.knownsec.com/2013/03/attack-your-android-apps-by-webview/" target="_blank" rel="noopener">http://blog.knownsec.com/2013/03/attack-your-android-apps-by-webview/</a></p><p>Andorid Intent 与 Chrome<br><a href="https://developer.chrome.com/multidevice/android/intents?spm=5176.100239.blogcont57088.9.1c29be50KIPvAG" target="_blank" rel="noopener">https://developer.chrome.com/multidevice/android/intents?spm=5176.100239.blogcont57088.9.1c29be50KIPvAG</a></p><p>克隆攻击分析与复现<br><a href="https://xianzhi.aliyun.com/forum/topic/1952" target="_blank" rel="noopener">https://xianzhi.aliyun.com/forum/topic/1952</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一篇文章介绍了Android Webview组件的安全问题，其中一个就是file域访问限制不严格导致数据泄露，前段时间很火的支付宝克隆漏洞也是基于file协议的权限设置不当造成的，参考了很多文章总结一下攻击流程：&lt;/p&gt;
&lt;h1 id=&quot;1-克隆漏洞基本原理解释：&quot;&gt;&lt;a
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android WebView Vulnerabilities</title>
    <link href="http://yoursite.com/2018/01/27/Android-WebView-Vulnerabilities/"/>
    <id>http://yoursite.com/2018/01/27/Android-WebView-Vulnerabilities/</id>
    <published>2018-01-26T17:29:30.000Z</published>
    <updated>2018-01-29T10:27:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天专门总结一下Android Webview漏洞，因为这是一个安全大坑，我也被坑了…郁闷，平时复习一下就好了</p><h1 id="1-基本开发知识："><a href="#1-基本开发知识：" class="headerlink" title="1 基本开发知识："></a>1 基本开发知识：</h1><p>If you want to deliver a web application (or just a web page) as a part of a client application, you can do it using WebView。顾名思义就是开发web app之类的，用处很多，不详细讲了，看开发文档写得很清楚</p><ul><li>添加Webview,步骤为写配置文件到layout，建立Webview类，然后取得Internet权限，一目了然</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">写配置文件：</span><br><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;WebView  xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    android:id=<span class="string">"@+id/webview"</span></span><br><span class="line">    android:layout_width=<span class="string">"fill_parent"</span></span><br><span class="line">    android:layout_height=<span class="string">"fill_parent"</span></span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">新建类：</span><br><span class="line">WebView myWebView = (WebView) findViewById(R.id.webview);</span><br><span class="line">myWebView.loadUrl(&quot;http://www.example.com&quot;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">申请Internet权限：</span><br><span class="line">&lt;manifest ... &gt;</span><br><span class="line">    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure><ul><li>使用JavaScript（JavaScript is disabled in a WebView by default）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">通过Websettings开启JavaScript</span><br><span class="line">WebView myWebView = (WebView) findViewById(R.id.webview);</span><br><span class="line">WebSettings webSettings = myWebView.getSettings();</span><br><span class="line">webSettings.setJavaScriptEnabled(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><ul><li>通过绑定JavaScript和你指定的android代码,让JavaScript可以调用你指定的代码，例如你定义了一个WebAppInterface类</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebAppInterface</span> </span>&#123;</span><br><span class="line">    Context mContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Instantiate the interface and set the context */</span></span><br><span class="line">    WebAppInterface(Context c) &#123;</span><br><span class="line">        mContext = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Show a toast from the web page */</span></span><br><span class="line">    <span class="meta">@JavascriptInterface</span>  <span class="comment">/*新的要求，加注解,API17以上*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showToast</span><span class="params">(String toast)</span> </span>&#123;</span><br><span class="line">        Toast.makeText(mContext, toast, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WebView webView = (WebView) findViewById(R.id.webview);</span><br><span class="line">webView.addJavascriptInterface(<span class="keyword">new</span> WebAppInterface(<span class="keyword">this</span>), <span class="string">"Android"</span>);</span><br></pre></td></tr></table></figure><ul><li>到此，JavaScript就可以调用你定义的函数了</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Say hello"</span> <span class="attr">onClick</span>=<span class="string">"showAndroidToast('Hello Android!')"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    function showAndroidToast(toast) &#123;</span></span><br><span class="line"><span class="undefined">        Android.showToast(toast); /*There's no need to initialize the Android interface from JavaScript. The WebView automatically makes it available to your web page</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="2-存在的安全问题："><a href="#2-存在的安全问题：" class="headerlink" title="2 存在的安全问题："></a>2 存在的安全问题：</h1><h2 id="1-Webview-任意代码执行漏洞"><a href="#1-Webview-任意代码执行漏洞" class="headerlink" title="1 Webview 任意代码执行漏洞"></a>1 Webview 任意代码执行漏洞</h2><ol><li>问题方法”addJavascriptInterface()”,上文基础部分中提到这个方法让JavaScript调用你定义的JAVA函数</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mWebView.addJavascriptInterface(<span class="keyword">new</span> TestAddJsInterface(), “myjs”);</span><br></pre></td></tr></table></figure><ol><li>在API17之前，上面的“addJavascriptInterface()”方法会导致出现问题，网页中的JS脚本可以利用接口“myjs”调用App中的Java代码，而Java对象继承关系会导致很多Public的函数及getClass函数都可以在JS中被访问，结合Java的反射机制，攻击者还可以获得系统类的函数，进而可以进行任意代码执行</li></ol><p>类似的攻击代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">execute</span><span class="params">(cmdArgs)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="comment">// 步骤1：遍历 window 对象</span></span><br><span class="line">    <span class="comment">// 目的是为了找到包含 getClass()的对象</span></span><br><span class="line">    <span class="comment">// 因为Android映射的"myjs"对象也在window中，所以肯定会遍历到</span></span><br><span class="line">    <span class="keyword">for</span> (var obj in window) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"getClass"</span> in window[obj]) &#123;  </span><br><span class="line"></span><br><span class="line">      <span class="comment">// 步骤2：利用反射调用forName（）得到Runtime类对象</span></span><br><span class="line">            alert(obj);          </span><br><span class="line">            <span class="keyword">return</span>  window[obj].getClass().forName(<span class="string">"java.lang.Runtime"</span>)  </span><br><span class="line"></span><br><span class="line">      <span class="comment">// 步骤3：以后，就可以调用静态方法来执行一些命令，比如访问文件的命令</span></span><br><span class="line">getMethod(<span class="string">"getRuntime"</span>,<span class="keyword">null</span>).invoke(<span class="keyword">null</span>,<span class="keyword">null</span>).exec(cmdArgs);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 从执行命令后返回的输入流中得到字符串，有很严重暴露隐私的危险。</span></span><br><span class="line"><span class="comment">// 如执行完访问文件的命令之后，就可以得到文件名的信息了。</span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>当一些 APP 通过扫描二维码打开一个外部网页时，攻击者就可以执行这段 js 代码进行漏洞攻击</p></li><li><p>关键的JAVA反射思路如下：</p></li></ol><ul><li>JAVA中的对象有一公共的方法：getClass() ；</li><li>该方法可以获取到当前类的Class对象</li><li>该类有一关键的方法： Class.forName；</li><li>该方法可以加载一个类（可加载 java.lang.Runtime 类）</li><li>而该类是可以执行本地命令的</li></ul><ol><li>解决方案：</li></ol><p>Google在API_17中规定允许被调用的函数必须以@JavascriptInterface进行注解，理论上如果APP依赖的API为17或者以上，就不会受该问题的影响。所以检查API的版本和关键函数的注解可以有效识别漏洞</p><h2 id="2-WebView域控制不严格漏洞"><a href="#2-WebView域控制不严格漏洞" class="headerlink" title="2 WebView域控制不严格漏洞"></a>2 WebView域控制不严格漏洞</h2><p>这个漏洞主要出现在了对file协议的控制不当上，通过4个API来理解WebView中file协议的安全性，下面的代码是新建一个Webview，通过发送Intent调用这个export的activity，把intent中的data作为url传入Webview，这个data是攻击者可控的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebViewActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> WebView webView;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_webview);</span><br><span class="line">        webView = (WebView) findViewById(R.id.webView1);</span><br><span class="line">        <span class="comment">//webView.getSettings().setAllowFileAccess(false);                    (1)</span></span><br><span class="line">        <span class="comment">//webView.getSettings().setJavaScriptEnabled(true);                   (2)</span></span><br><span class="line">        <span class="comment">//webView.getSettings().setAllowFileAccessFromFileURLs(true);       (3)</span></span><br><span class="line">        <span class="comment">//webView.getSettings().setAllowUniversalAccessFromFileURLs(true); (4)</span></span><br><span class="line">        Intent i = getIntent();</span><br><span class="line">        String url = i.getData().toString();</span><br><span class="line">        webView.loadUrl(url);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>/<strong>Mainifest.xml</strong>/<br>// 将该 WebViewActivity 在Mainifest.xml设置exported属性<br>// 表示：当前Activity是否可以被另一个Application的组件启动<br>android:exported=”true”</p><ol><li>setAllowFileAccess</li></ol><p>设置是否允许 WebView 使用 File 协议 ,默认设置为true，即允许在 File 域下执行任意 JavaScript 代码 ,使用 file 域加载的 js代码能够使用进行同源策略跨域访问，从而导致隐私信息泄露,如果不允许使用 file 协议，则不会存在上述的威胁；但同时也限制了 WebView 的功能，使其不能加载本地的 html 文件</p><ol><li>setAllowFileAccessFromFileURLs</li></ol><p>设置是否允许通过 file url 加载的 Js代码读取其他的本地文件,当这个方法为true时，攻击者可以读取本地敏感文件<br>在Android 4.1前默认允许<br>在Android 4.1后默认禁止</p><ol><li><p>setAllowUniversalAccessFromFileURLs<br>设置是否允许通过 file url 加载的 Javascript 可以访问其他的源(包括http、https等源)<br>在Android 4.1前默认允许（setAllowFileAccessFromFileURLs（）不起作用）<br>在Android 4.1后默认禁止</p></li><li><p>setJavaScriptEnabled</p></li></ol><p>设置是否允许 WebView 使用 JavaScript（默认是不允许）<br>但很多应用（包括移动浏览器）为了让 WebView 执行 http 协议中的 JavaScript，都会主动设置为true，不区别对待是非常危险的。</p><ol><li><p>符号链接跨源攻击 (不看)</p></li><li><p>最佳设置</p></li></ol><ul><li><p>对于不需要使用 file 协议的应用，禁用 file 协议；</p></li><li><p>对于需要使用 file 协议的应用，禁止 file 协议加载 JavaScript。</p></li></ul><h2 id="明文保存密码"><a href="#明文保存密码" class="headerlink" title="明文保存密码"></a>明文保存密码</h2><ol><li>WebView默认开启密码保存功能 ：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mWebView.setSavePassword(<span class="keyword">true</span>)</span><br></pre></td></tr></table></figure><p>开启后，在用户输入密码时，会弹出提示框：询问用户是否保存密码；<br>如果选择”是”，密码会被明文保到 /data/data/com.package.name/databases/webview.db 中，这样就有被盗取密码的危险</p><ol><li>关闭密码保存提醒</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WebSettings.setSavePassword(<span class="keyword">false</span>)</span><br></pre></td></tr></table></figure><h2 id="SSL-Error-Handling"><a href="#SSL-Error-Handling" class="headerlink" title="SSL Error Handling"></a>SSL Error Handling</h2><p>直接忽略了SSL错误的处理方法，让程序继续运行，让程序有机会收到Mitm</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceivedSslError</span><span class="params">(WebView view, SslErrorHandler handler,</span></span></span><br><span class="line"><span class="function"><span class="params">SslError error)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">handler.proceed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="refer-link"><a href="#refer-link" class="headerlink" title="refer link:"></a>refer link:</h1><p><a href="https://pentestlab.blog/2017/02/12/android-webview-vulnerabilities/" target="_blank" rel="noopener">https://pentestlab.blog/2017/02/12/android-webview-vulnerabilities/</a></p><p><a href="https://developer.android.com/guide/webapps/webview.html" target="_blank" rel="noopener">https://developer.android.com/guide/webapps/webview.html</a></p><p><a href="https://www.jianshu.com/p/3a345d27cd42" target="_blank" rel="noopener">https://www.jianshu.com/p/3a345d27cd42</a></p><p><a href="https://www.jianshu.com/p/5b3acad0f025" target="_blank" rel="noopener">https://www.jianshu.com/p/5b3acad0f025</a></p><p><a href="http://blogs.360.cn/360mobile/2014/09/22/webview%E8%B7%A8%E6%BA%90%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">http://blogs.360.cn/360mobile/2014/09/22/webview%E8%B7%A8%E6%BA%90%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天专门总结一下Android Webview漏洞，因为这是一个安全大坑，我也被坑了…郁闷，平时复习一下就好了&lt;/p&gt;
&lt;h1 id=&quot;1-基本开发知识：&quot;&gt;&lt;a href=&quot;#1-基本开发知识：&quot; class=&quot;headerlink&quot; title=&quot;1 基本开发知识：&quot;&gt;
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 奇怪的错误</title>
    <link href="http://yoursite.com/2018/01/27/Hexo-%E5%A5%87%E6%80%AA%E7%9A%84%E9%94%99%E8%AF%AF/"/>
    <id>http://yoursite.com/2018/01/27/Hexo-奇怪的错误/</id>
    <published>2018-01-26T17:26:23.000Z</published>
    <updated>2018-01-26T09:29:09.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>升级后遇到了一个奇怪的错误,在Hexo目录下“hexo”命令失效了：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo</span><br><span class="line">ERROR Local hexo not found in ~/Hexo</span><br><span class="line">ERROR Try running: &apos;npm install hexo --save&apos;</span><br></pre></td></tr></table></figure><ul><li>解决方法如下：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -rf node_modules/ &amp;&amp; npm install</span><br></pre></td></tr></table></figure><ul><li>错误原因：</li></ul><p>Unknown</p><ul><li>Refer link:</li></ul><p><a href="https://github.com/hexojs/hexo/issues/2076" target="_blank" rel="noopener">https://github.com/hexojs/hexo/issues/2076</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;升级后遇到了一个奇怪的错误,在Hexo目录下“hexo”命令失效了：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$
      
    
    </summary>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 统计字数的新插件</title>
    <link href="http://yoursite.com/2018/01/25/Hexo-%E7%BB%9F%E8%AE%A1%E5%AD%97%E6%95%B0%E7%9A%84%E6%96%B0%E6%8F%92%E4%BB%B6/"/>
    <id>http://yoursite.com/2018/01/25/Hexo-统计字数的新插件/</id>
    <published>2018-01-25T11:44:50.000Z</published>
    <updated>2018-01-25T06:11:21.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>最近更新了一下博客的主题版本，发现原来的wordcount插件不行了，查看了一下配置文件，推荐了新插件：”hexo-symbols-count-time”</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Post wordcount display settings</span><br><span class="line"># Dependencies: https://github.com/theme-next/hexo-symbols-count-time</span><br><span class="line">symbols_count_time:</span><br><span class="line">  symbols: true</span><br><span class="line">  time: true</span><br><span class="line">  total_symbols: true</span><br><span class="line">  total_time: true</span><br></pre></td></tr></table></figure><ul><li>马上尝试一下：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure><ul><li>具体的配置方法参考：</li></ul><p><a href="https://github.com/theme-next/hexo-symbols-count-time" target="_blank" rel="noopener">https://github.com/theme-next/hexo-symbols-count-time</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;最近更新了一下博客的主题版本，发现原来的wordcount插件不行了，查看了一下配置文件，推荐了新插件：”hexo-symbols-count-time”&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr
      
    
    </summary>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Java 反序列化漏洞学习笔记</title>
    <link href="http://yoursite.com/2018/01/24/Java-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/01/24/Java-反序列化漏洞学习笔记/</id>
    <published>2018-01-24T15:59:15.000Z</published>
    <updated>2018-02-05T07:35:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-什么是Java序列化和反序列化"><a href="#1-什么是Java序列化和反序列化" class="headerlink" title="1 什么是Java序列化和反序列化:"></a>1 什么是Java序列化和反序列化:</h1><ol><li><p>Java 序列化是指把 Java 对象转换为字节序列的过程便于保存在内存、文件、数据库中，ObjectOutputStream类的 writeObject() 方法可以实现序列化。</p></li><li><p>Java 反序列化是指把字节序列恢复为 Java 对象的过程，ObjectInputStream 类的 readObject() 方法用于反序列化。</p></li><li><p>网络上传输和本地硬盘中存储的是字节流，即01010之类的数据，所以序列化在传输和存储中是必要的,问题的根源在于类ObjectInputStream在反序列化时，没有对生成的对象的类型做限制；</p></li><li><p>首先在序列化和反序列化的过程中，每个类都有自己的readObject与writeObject对应，很多类自己重写了自己的readObject与writeObject函数，是否有漏洞要看程序有没有用了一些指定的库</p></li><li><p>基本的序列化和反序列化代码：</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">    String obj = <span class="string">"hello world!"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将序列化对象写入文件object.db中</span></span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"object.db"</span>);</span><br><span class="line">    ObjectOutputStream os = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">    os.writeObject(obj);</span><br><span class="line">    os.close();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从文件object.db中读取数据</span></span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"object.db"</span>);</span><br><span class="line">    ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(fis);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过反序列化恢复对象obj</span></span><br><span class="line">    String obj2 = (String)ois.readObject();</span><br><span class="line">    ois.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-攻击方法"><a href="#2-攻击方法" class="headerlink" title="2 攻击方法:"></a>2 攻击方法:</h1><p>Java的某些库暴露或间接暴露反序列化API ，导致用户可以操作传入数据，两个或多个看似安全的模块在同一运行环境下，共同产生的安全问题，攻击者可以精心构造反序列化对象并执行恶意代码，主要方法是重写readObject()方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="comment">//重写readObject()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span>&#123;</span><br><span class="line">        <span class="comment">//执行默认的readObject()方法</span></span><br><span class="line">        in.defaultReadObject();</span><br><span class="line">        <span class="comment">//执行打开计算器程序命令</span></span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">"open /Applications/Calculator.app/"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-经典漏洞："><a href="#3-经典漏洞：" class="headerlink" title="3 经典漏洞："></a>3 经典漏洞：</h1><ol><li>使用了有安全缺陷的Apache Commons Collections jar包 ,调用关系好复杂，Java渣渣看不明白 ，简单总结几句：</li></ol><ul><li><p>三个关键类：AnnotationInvocationHandler，TransformedMap.decorate，InvokerTransformer</p></li><li><p>Apache Commons Collections 序列化 RCE 漏洞问题主要出现在 org.apache.commons.collections.Transformer 接口上，<br>在 Apache Commons Collections 中有一个 InvokerTransformer 类实现了 Transformer 接口，主要作用是调用 Java 的反射机制来调用任意函数，只需要传入方法名、参数类型和参数，即可调用任意函数</p></li></ul><ol><li>2016 年的 Spring 框架的反序列化漏洞，该漏洞是利用了 RMI 以及 JNDI：</li></ol><ul><li>问题的关键点在JtaTransactionManager 类的 readObject() 方法，然后一大堆调用，反正其中有个函数lookup()使用了用户的可控输入属性：userTransactionName ， 攻击者构造userTransactionName就ok</li></ul><h1 id="4-利用工具："><a href="#4-利用工具：" class="headerlink" title="4 利用工具："></a>4 利用工具：</h1><p><a href="https://github.com/frohoff/ysoserial" target="_blank" rel="noopener">https://github.com/frohoff/ysoserial</a></p><h1 id="5-发现漏洞："><a href="#5-发现漏洞：" class="headerlink" title="5 发现漏洞："></a>5 发现漏洞：</h1><blockquote><p>1 首先拿到一个Java应用，需要找到一个接受外部输入的序列化对象的接收点，即反序列化漏洞的触发点。我们可以通过审计源码中对反序列化函数的调用readObject来寻找，也可以直接通过对应用交互流量进行抓包，查看流量中是否包含java序列化数据来判断，java序列化数据的特征为以标记（ac ed 00 05）开头。</p><p>2 确定了反序列化输入点后，再考察应用的Class Path中是否包含Apache Commons Collections库（ysoserial所支持的其他库亦可），如果是，就可以使用ysoserial来生成反序列化的payload</p><p>3 从流量中发现序列化的痕迹，关键字：ac ed 00 05，rO0AB</p><p>4 Java RMI 的传输 100% 基于反序列化，Java RMI 的默认端口是1099端口</p><p>5 从源码入手，可以被序列化的类一定实现了Serializable接口<br>观察反序列化时的readObject()方法是否重写，重写中是否有设计不合理，可以被利用之处</p></blockquote><p>Refer link:</p><ul><li>[<a href="https://paper.seebug.org/312/" target="_blank" rel="noopener">https://paper.seebug.org/312/</a>]</li><li>[<a href="http://www.cnblogs.com/alert123/p/5124637.html" target="_blank" rel="noopener">http://www.cnblogs.com/alert123/p/5124637.html</a>]</li><li>[<a href="https://blog.chaitin.cn/2015-11-11_java_unserialize_rce/" target="_blank" rel="noopener">https://blog.chaitin.cn/2015-11-11_java_unserialize_rce/</a>]</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-什么是Java序列化和反序列化&quot;&gt;&lt;a href=&quot;#1-什么是Java序列化和反序列化&quot; class=&quot;headerlink&quot; title=&quot;1 什么是Java序列化和反序列化:&quot;&gt;&lt;/a&gt;1 什么是Java序列化和反序列化:&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Python MongoDB学习笔记</title>
    <link href="http://yoursite.com/2018/01/23/Python-MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/01/23/Python-MongoDB学习笔记/</id>
    <published>2018-01-23T14:51:08.000Z</published>
    <updated>2018-01-24T06:57:49.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-MongoDB-常用函数实例代码"><a href="#1-MongoDB-常用函数实例代码" class="headerlink" title="1 MongoDB 常用函数实例代码"></a>1 MongoDB 常用函数实例代码</h1><ol><li><p>连接 MongoDB 我们需要使用 PyMongo 库里面的 MongoClient，一般来说传入 MongoDB 的 IP 及端口即可，第一个参数为地址 host，第二个参数为端口 port，端口如果不传默认是 27017</p></li><li><p>MongoDB 中还分为一个个数据库，我们接下来的一步就是指定要操作哪个数据库，在这里我以 test 数据库为例进行说明，所以下一步我们需要在程序中指定要使用的数据库</p></li><li><p>MongoDB 的每个数据库又包含了许多集合 Collection，也就类似与关系型数据库中的表，下一步我们需要指定要操作的集合</p></li><li><p>在 MongoDB 中，每条数据其实都有一个 _id 属性来唯一标识，如果没有显式指明 _id，MongoDB 会自动产生一个 ObjectId 类型的 _id 属性。insert() 方法会在执行后返回的 _id 值</p></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line">client = pymongo.MongoClient(host=<span class="string">'localhost'</span>, port=<span class="number">27017</span>) <span class="comment"># 链接数据库，得到数据库对象“client"</span></span><br><span class="line">db = client.test <span class="comment"># 新建或者选择”test“数据库</span></span><br><span class="line"><span class="comment"># db = client['test']</span></span><br><span class="line">collection = db.students <span class="comment"># 新建或者选择”students“ collection对象</span></span><br><span class="line"><span class="comment"># collection = db['students']</span></span><br><span class="line"></span><br><span class="line">student1 = &#123;</span><br><span class="line">    <span class="string">'id'</span>: <span class="string">'20170101'</span>,</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'Jordan'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="string">'gender'</span>: <span class="string">'male'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">student2 = &#123;</span><br><span class="line">    <span class="string">'id'</span>: <span class="string">'20170202'</span>,</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'Mike'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">21</span>,</span><br><span class="line">    <span class="string">'gender'</span>: <span class="string">'male'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># result = collection.insert(student) 官方不推荐用这个方法</span></span><br><span class="line"><span class="comment"># print(result)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># result = collection.insert_one(student) # 对collection对象进行数据插入</span></span><br><span class="line"><span class="comment"># print(result)</span></span><br><span class="line"><span class="comment"># print(result.inserted_id)</span></span><br><span class="line"></span><br><span class="line">result = collection.insert_many([student1, student2]) <span class="comment"># 对collection对象进行多个数据插入</span></span><br><span class="line">print(result)</span><br><span class="line">print(result.inserted_ids)</span><br><span class="line"></span><br><span class="line">result = collection.find_one(&#123;<span class="string">'name'</span>: <span class="string">'Mike'</span>&#125;) <span class="comment"># 对collection对象进行查找</span></span><br><span class="line">print(type(result))</span><br><span class="line">print(result) <span class="comment"># 可以发现它多了一个 _id 属性，这就是 MongoDB 在插入的过</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-MongoDB-常用函数实例代码&quot;&gt;&lt;a href=&quot;#1-MongoDB-常用函数实例代码&quot; class=&quot;headerlink&quot; title=&quot;1 MongoDB 常用函数实例代码&quot;&gt;&lt;/a&gt;1 MongoDB 常用函数实例代码&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python Selenium库学习笔记</title>
    <link href="http://yoursite.com/2018/01/23/Python-Selenium%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/01/23/Python-Selenium库学习笔记/</id>
    <published>2018-01-23T14:50:49.000Z</published>
    <updated>2018-01-23T06:56:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-声明浏览器对象"><a href="#1-声明浏览器对象" class="headerlink" title="1 声明浏览器对象"></a>1 声明浏览器对象</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver </span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome() <span class="comment">#得到各类浏览器对象，当然需要先下载各类浏览器驱动</span></span><br><span class="line">browser = webdriver.Firefox()</span><br><span class="line">browser = webdriver.Edge()</span><br><span class="line">browser = webdriver.PhantomJS()</span><br><span class="line">browser = webdriver.Safari()</span><br></pre></td></tr></table></figure><h1 id="2-访问页面"><a href="#2-访问页面" class="headerlink" title="2 访问页面"></a>2 访问页面</h1><p>用 get() 方法来请求一个网页，参数传入链接 URL 即可，比如在这里我们用 get() 方法访问淘宝，然后打印出源代码，代码如下</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">'https://www.taobao.com'</span>)<span class="comment">#请求淘宝页面</span></span><br><span class="line">print(browser.page_source)<span class="comment">#得到网页源代码</span></span><br><span class="line">browser.close()<span class="comment">#浏览器关闭</span></span><br></pre></td></tr></table></figure><h1 id="3-查找节点"><a href="#3-查找节点" class="headerlink" title="3 查找节点"></a>3 查找节点</h1><p>用于填充表单、模拟点击等等，比如我们想要完成向某个输入框输入文字的操作，总得需要知道这个输入框在哪里吧？所以 Selenium 提供了一系列查找节点的方法，我们可以用这些方法来获取想要的节点，以便于下一步执行一些动作或者提取信息</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">'https://www.taobao.com'</span>)</span><br><span class="line">input_first = browser.find_element_by_id(<span class="string">'q'</span>) <span class="comment">#find_element_by_id()方法</span></span><br><span class="line">input_second = browser.find_element_by_css_selector(<span class="string">'#q'</span>)<span class="comment">#find_element_by_css_selector()方法</span></span><br><span class="line">input_third = browser.find_element_by_xpath(<span class="string">'//*[@id="q"]'</span>)<span class="comment">#find_element_by_xpath()方法</span></span><br><span class="line">print(input_first, input_second, input_third)</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure><p>列出所有获取单个节点的方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find_element_by_id</span><br><span class="line">find_element_by_name</span><br><span class="line">find_element_by_xpath</span><br><span class="line">find_element_by_link_text</span><br><span class="line">find_element_by_partial_link_text</span><br><span class="line">find_element_by_tag_name</span><br><span class="line">find_element_by_class_name</span><br><span class="line">find_element_by_css_selector</span><br><span class="line"></span><br><span class="line">find_element_by_id(id) 就等价于 find_element(By.ID, id)，二者得到的结果完全一致。</span><br></pre></td></tr></table></figure><h1 id="4-查找多节点"><a href="#4-查找多节点" class="headerlink" title="4 查找多节点"></a>4 查找多节点</h1><p>用 find_elements() 这样的方法，方法名称中 element 多了一个 s ，注意区分，也就是说，上面列举的方法加“s”就能实现多节点查找<br>如果我们用 find_element() 方法，只能获取匹配的第一个节点，结果是 WebElement 类型，如果用 find_elements() 方法，<br>则结果是<strong>列表类型，列表的每个节点是 WebElement 类型</strong>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find_elements_by_id</span><br><span class="line">find_elements_by_name</span><br><span class="line">find_elements_by_xpath</span><br><span class="line">find_elements_by_link_text</span><br><span class="line">find_elements_by_partial_link_text</span><br><span class="line">find_elements_by_tag_name</span><br><span class="line">find_elements_by_class_name</span><br><span class="line">find_elements_by_css_selector</span><br></pre></td></tr></table></figure><h1 id="5-节点交互"><a href="#5-节点交互" class="headerlink" title="5 节点交互"></a>5 节点交互</h1><p>Selenium 可以驱动浏览器来执行一些操作，也就是说我们可以让浏览器模拟执行一些动作，比较常见的用法有：<br>输入文字用 send_keys() 方法，清空文字用 clear() 方法，另外还有按钮点击，用 click() 方法。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()<span class="comment">#得到浏览器对象</span></span><br><span class="line">browser.get(<span class="string">'https://www.taobao.com'</span>)<span class="comment">#请求淘宝网</span></span><br><span class="line">input = browser.find_element_by_id(<span class="string">'q'</span>)<span class="comment">#查找id=q的元素，得到输入框&lt;input&gt;</span></span><br><span class="line">input.send_keys(<span class="string">'iPhone'</span>)<span class="comment">#调用send_keys()方法输入‘iPhone’</span></span><br><span class="line">time.sleep(<span class="number">1</span>)<span class="comment">#等待一秒</span></span><br><span class="line">input.clear()<span class="comment">#清空输入框</span></span><br><span class="line">input.send_keys(<span class="string">'iPad'</span>)<span class="comment">#再次输入新的字符串'iPad'</span></span><br><span class="line">button = browser.find_element_by_class_name(<span class="string">'btn-search'</span>)<span class="comment">#查找class为'btn-search'，得到button节点</span></span><br><span class="line">button.click()<span class="comment">#调用click()进行搜索</span></span><br></pre></td></tr></table></figure><h1 id="6-延时等待-显式等待"><a href="#6-延时等待-显式等待" class="headerlink" title="6 延时等待 - 显式等待"></a>6 延时等待 - 显式等待</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome() <span class="comment">#得到浏览器对象</span></span><br><span class="line">browser.get(<span class="string">'https://www.taobao.com/'</span>) <span class="comment">#发出请求</span></span><br><span class="line">wait = WebDriverWait(browser, <span class="number">10</span>) <span class="comment">#得到WebDriverWait对象</span></span><br><span class="line">input = wait.until(EC.presence_of_element_located((By.ID, <span class="string">'q'</span>))) <span class="comment">#使用EC设置等待条件：等待id为q的元素加载</span></span><br><span class="line">button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, <span class="string">'.btn-search'</span>)))<span class="comment">#等待button按钮可以点击</span></span><br><span class="line">print(input, button)</span><br></pre></td></tr></table></figure><p>所以这样可以做到的效果就是，在 10 秒内如果 ID 为 q 的节点即搜索框成功加载出来了，那就返回该节点，如果超过10 秒还没有加载出来，那就抛出异常。<br>对于按钮，可以更改一下等待条件，比如改为 element_to_be_clickable，也就是可点击，所以查找按钮时是查找 CSS 选择器为 .btn-search 的按钮，如果 10 秒内它是可点击的也就是成功加载出来了，那就返回这个按钮节点，如果超过 10 秒还不可点击，也就是没有加载出来，那就抛出异常。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-声明浏览器对象&quot;&gt;&lt;a href=&quot;#1-声明浏览器对象&quot; class=&quot;headerlink&quot; title=&quot;1 声明浏览器对象&quot;&gt;&lt;/a&gt;1 声明浏览器对象&lt;/h1&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python 正则库学习笔记</title>
    <link href="http://yoursite.com/2018/01/23/Python-%E6%AD%A3%E5%88%99%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/01/23/Python-正则库学习笔记/</id>
    <published>2018-01-23T14:50:12.000Z</published>
    <updated>2018-01-23T06:56:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-要记得的一些常用匹配模式"><a href="#1-要记得的一些常用匹配模式" class="headerlink" title="1 要记得的一些常用匹配模式"></a>1 要记得的一些常用匹配模式</h1><ul><li>\w 匹配字母，数字，和下划线</li><li>\W 匹配非字母数字，和下划线</li><li>\s 匹配任意空白字符，例如[\t\n\r\f]，其中”\t”是制表符</li><li>\S 匹配任意非空白字符</li><li>\d 匹配任意数字，等价于[0-9]</li><li>^  匹配字符串开头</li><li>$  匹配字符串结尾</li><li>.  匹配任意字符，除了换行符</li><li>* 匹配0个或者多个的表达式</li><li><ul><li>匹配1个或者多个的表达式</li></ul></li><li>?  匹配0个或者1个前面的表达式，非贪婪模式</li><li>{n} 匹配前面的表达式n次</li><li>{n,m} 匹配前面的表达式n到m次，贪婪模式</li></ul><h1 id="2-python的re库"><a href="#2-python的re库" class="headerlink" title="2 python的re库"></a>2 python的re库</h1><h2 id="match-方法，一定要从头开始才匹配"><a href="#match-方法，一定要从头开始才匹配" class="headerlink" title="match()方法，一定要从头开始才匹配"></a>match()方法，一定要从头开始才匹配</h2><ol><li>match() 方法会尝试从字符串的起始位置匹配正则表达式，如果匹配，就返回匹配成功的结果，如果不匹配，那就返回 None。match() 方法是从字符串的开头开始匹配，一旦开头不匹配，那么整个匹配就失败了。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">content = <span class="string">'Hello 123 4567 World_This is a Regex Demo'</span></span><br><span class="line"></span><br><span class="line">print(len(content))</span><br><span class="line"></span><br><span class="line">result=re.match(<span class="string">'^Hello\s\d\d\d\s\d&#123;4&#125;\s\w&#123;10&#125;'</span>,content) <span class="comment">#第一个参数是正则，第二个参数是目标字符串</span></span><br><span class="line"></span><br><span class="line">print(result) <span class="comment">#返回一个结果对象：SRE_Match 对象</span></span><br><span class="line">print(result.span()) <span class="comment">#返回匹配的字符串起始位置</span></span><br><span class="line">print(result.group()) <span class="comment"># 返回匹配的结果字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#output：</span></span><br><span class="line"><span class="number">41</span></span><br><span class="line">&lt;_sre.SRE_Match object; span=(<span class="number">0</span>, <span class="number">25</span>), match=<span class="string">'Hello 123 4567 World_This'</span>&gt;</span><br><span class="line">(<span class="number">0</span>, <span class="number">25</span>)</span><br><span class="line">Hello <span class="number">123</span> <span class="number">4567</span> World_This</span><br><span class="line">()</span><br></pre></td></tr></table></figure><ol><li>在这里可以使用 () 括号来将我们想提取的子字符串括起来，() 实际上就是标记了一个子表达式的开始和结束位置，被标记的每个子表达式会依次对应每一个分组，我们可以调用 group() 方法传入分组的索引即可获取提取的结果。</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">content = <span class="string">'Hello 123 4567 World_This is a Regex Demo'</span></span><br><span class="line"></span><br><span class="line">print(len(content))</span><br><span class="line"></span><br><span class="line">result=re.match(<span class="string">'^Hello\s\d\d\d\s(\d&#123;4&#125;)\s\w&#123;10&#125;'</span>,content)</span><br><span class="line"></span><br><span class="line">print(result.group(<span class="number">1</span>)) <span class="comment">#</span></span><br><span class="line">print(result.groups())</span><br><span class="line"></span><br><span class="line"><span class="comment">#output:</span></span><br><span class="line"><span class="number">41</span></span><br><span class="line"><span class="number">4567</span></span><br><span class="line">(<span class="string">'4567'</span>,)</span><br></pre></td></tr></table></figure><ol><li>通用匹配，改进上面的正则表达式</li></ol><p>一个万能匹配可以用，也就是 .* （点星），.（点）可以匹配任意字符（除换行符），*（星） 又代表匹配前面的字符无限次，所以它们组合在一起就可以匹配任意的字符了，有了它我们就不用挨个字符地匹配了。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">content = <span class="string">'Hello 123 4567 World_This is a Regex Demo'</span></span><br><span class="line"></span><br><span class="line">print(len(content))</span><br><span class="line"></span><br><span class="line">result=re.match(<span class="string">'^Hello.*Demo$'</span>,content) <span class="comment">#使用了.\* （点星）进行通用匹配</span></span><br><span class="line"></span><br><span class="line">print(result.group())</span><br><span class="line"></span><br><span class="line"><span class="comment">#output:</span></span><br><span class="line"></span><br><span class="line"><span class="number">41</span></span><br><span class="line">Hello <span class="number">123</span> <span class="number">4567</span> World_This <span class="keyword">is</span> a Regex Demo</span><br><span class="line">()</span><br></pre></td></tr></table></figure><p>4.贪婪与非贪婪</p><p>这里就涉及一个贪婪匹配与非贪婪匹配的原因了，贪婪匹配下，.* 会匹配尽可能多的字符，我们的正则表达式中 .* 后面是 \d+，也就是至少一个数字，并没有指定具体多少个数字，所以 .* 就尽可能匹配多的字符，所以它把 123456 也匹配了，给 \d+ 留下一个可满足条件的数字 7，所以 \d+ 得到的内容就只有数字 7 了。+</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">content = <span class="string">'Hello 123 4567 World_This is a Regex Demo'</span></span><br><span class="line"></span><br><span class="line">print(len(content))</span><br><span class="line"></span><br><span class="line">result=re.match(<span class="string">'^He.*(\d+).*Demo$'</span>,content) <span class="comment">#贪婪模式</span></span><br><span class="line"></span><br><span class="line">print(result.group())</span><br><span class="line"></span><br><span class="line">print(result.groups())</span><br></pre></td></tr></table></figure><p>贪婪匹配是尽可能匹配多的字符，非贪婪匹配就是尽可能匹配少的字符，.*? 之后是 \d+ 用来匹配数字，当 .*? 匹配到 Hello 后面的空白字符的时候，再往后的字符就是数字了，而 \d+ 恰好可以匹配，那么这里 .*? 就不再进行匹配，交给 \d+ 去匹配后面的数字。所以这样，.*? 匹配了尽可能少的字符，\d+ 的结果就是 1234567 了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">content = <span class="string">'Hello 1234567 World_This is a Regex Demo'</span></span><br><span class="line"></span><br><span class="line">print(len(content))</span><br><span class="line"></span><br><span class="line">result=re.match(<span class="string">'^He.*?(\d+).*Demo$'</span>,content) <span class="comment">#非贪婪模式</span></span><br><span class="line"></span><br><span class="line">print(result.group())</span><br><span class="line"></span><br><span class="line">print(result.groups())</span><br><span class="line"></span><br><span class="line"><span class="comment">#output:</span></span><br><span class="line"></span><br><span class="line"><span class="number">40</span></span><br><span class="line">Hello <span class="number">1234567</span> World_This <span class="keyword">is</span> a Regex Demo</span><br><span class="line">(<span class="string">'1234567'</span>,)</span><br></pre></td></tr></table></figure><p><strong>实验证明，使用 .*? (点星问号) 和 .+?（点加问号）可以实现非贪婪模式匹配,在字符串中间尽量用非贪婪模式匹配，在字符串结尾用贪婪模式匹配</strong></p><p>5 修饰符(match方法的第三个参数)</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">content = <span class="string">'''Hello 1234567 World_This</span></span><br><span class="line"><span class="string">is a Regex Demo</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">result = re.match(<span class="string">'^He.*?(\d+).*?Demo$'</span>, content,re.S) <span class="comment">#增加了re.S,使得(.*?)可以匹配换行符</span></span><br><span class="line">print(result.group(<span class="number">1</span>))</span><br></pre></td></tr></table></figure><h2 id="search-方法，匹配第一个结果"><a href="#search-方法，匹配第一个结果" class="headerlink" title="search()方法，匹配第一个结果"></a>search()方法，匹配第一个结果</h2><p>match() 方法是从字符串的开头开始匹配，一旦开头不匹配，那么整个匹配就失败了，search()方法在匹配时会扫描整个字符串，然后返回第一个成功匹配的结果，也就是说，正则表达式可以是字符串的一部分，在匹配时，search() 方法会依次扫描字符串，直到找到第一个符合规则的字符串，然后返回匹配内容，如果搜索完了还没有找到，那就返回 None，为了匹配方便，我们可以尽量使用 search() 方法</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">html = <span class="string">'''&lt;div id="songs-list"&gt;</span></span><br><span class="line"><span class="string">    &lt;h2 class="title"&gt;经典老歌&lt;/h2&gt;</span></span><br><span class="line"><span class="string">    &lt;p class="introduction"&gt;</span></span><br><span class="line"><span class="string">        经典老歌列表</span></span><br><span class="line"><span class="string">    &lt;/p&gt;</span></span><br><span class="line"><span class="string">    &lt;ul id="list" class="list-group"&gt;</span></span><br><span class="line"><span class="string">        &lt;li data-view="2"&gt;一路上有你&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li data-view="7"&gt;</span></span><br><span class="line"><span class="string">            &lt;a href="/2.mp3" singer="任贤齐"&gt;沧海一声笑&lt;/a&gt;</span></span><br><span class="line"><span class="string">        &lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li data-view="4" class="active"&gt;</span></span><br><span class="line"><span class="string">            &lt;a href="/3.mp3" singer="齐秦"&gt;往事随风&lt;/a&gt;</span></span><br><span class="line"><span class="string">        &lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li data-view="6"&gt;&lt;a href="/4.mp3" singer="beyond"&gt;光辉岁月&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li data-view="5"&gt;&lt;a href="/5.mp3" singer="陈慧琳"&gt;记事本&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li data-view="5"&gt;</span></span><br><span class="line"><span class="string">            &lt;a href="/6.mp3" singer="邓丽君"&gt;&lt;i class="fa fa-user"&gt;&lt;/i&gt;但愿人长久&lt;/a&gt;</span></span><br><span class="line"><span class="string">        &lt;/li&gt;</span></span><br><span class="line"><span class="string">    &lt;/ul&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;'''</span></span><br><span class="line"></span><br><span class="line">result=re.search(<span class="string">'&lt;li.*?4.*?active.*?singer="(.*?)"&gt;(.*?)&lt;/a&gt;'</span>,html,re.S)</span><br><span class="line">print(result.group())</span><br><span class="line">print(result.group(<span class="number">1</span>))</span><br><span class="line">print(result.group(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#output:</span></span><br><span class="line">&lt;li data-view="2"&gt;一路上有你&lt;/li&gt;</span><br><span class="line">        &lt;li data-view=<span class="string">"7"</span>&gt;</span><br><span class="line">            &lt;a href="/2.mp3" singer="任贤齐"&gt;沧海一声笑&lt;/a&gt;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">        &lt;li data-view="4" class="active"&gt;</span><br><span class="line">            &lt;a href="/3.mp3" singer="齐秦"&gt;往事随风&lt;/a&gt;</span><br><span class="line">齐秦</span><br><span class="line">往事随风</span><br></pre></td></tr></table></figure><h2 id="findall-方法-返回列表"><a href="#findall-方法-返回列表" class="headerlink" title="findall()方法,返回列表"></a>findall()方法,返回列表</h2><p>在前面我们说了 search()方法的用法，它可以返回匹配正则表达式的第一个内容，但是如果我们想要获取匹配正则表达式的所有内容的话怎么办？这时就需要借助于 findall() 方法了。如果有返回结果的话就是列表类型，所以我们需要遍历一下来获依次获取每组内容。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">result=re.findall(<span class="string">'&lt;li.*?href="(.*?)".*?singer="(.*?)"&gt;(.*?)&lt;/a&gt;'</span>,html,re.S)</span><br><span class="line"><span class="comment"># print(result.group())</span></span><br><span class="line">print(isinstance(result,list))</span><br><span class="line">print(type(result))</span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line"><span class="comment">#output:</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">list</span>'&gt;</span></span><br><span class="line">[('/2.mp3', '任贤齐', '沧海一声笑'), ('/3.mp3', '齐秦', '往事随风'), ('/4.mp3', 'beyond', '光辉岁月'), ('/5.mp3', '陈慧琳', '记事本'), ('/6.mp3', '邓丽君', '&lt;i class="fa fa-user"&gt;&lt;/i&gt;但愿人长久')]</span><br></pre></td></tr></table></figure><p>所以，如果只是获取第一个内容，可以用 search() 方法，当需要提取多个内容时，就可以用 findall() 方法。+</p><h2 id="sub-方法，用于修改文本-返回修改后的字符串"><a href="#sub-方法，用于修改文本-返回修改后的字符串" class="headerlink" title="sub()方法，用于修改文本,返回修改后的字符串"></a>sub()方法，用于修改文本,返回修改后的字符串</h2><p>第一个参数传入正则表达式来匹配需要替换的内容，然后第二个参数是替换成的字符串，要去掉的话就可以赋值为空，第三个参数就是原字符串。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">content = <span class="string">'''Hello 1234567 World_This</span></span><br><span class="line"><span class="string">is a Regex Demo</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">result = re.sub(<span class="string">'\d+'</span>,<span class="string">''</span>,content,re.S)</span><br><span class="line">print(result)<span class="comment">#返回一个字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#output:</span></span><br><span class="line"></span><br><span class="line">Hello  World_This</span><br><span class="line"><span class="keyword">is</span> a Regex Demo</span><br></pre></td></tr></table></figure><h2 id="compile-方法，提前封装好正则表达式"><a href="#compile-方法，提前封装好正则表达式" class="headerlink" title="compile()方法，提前封装好正则表达式"></a>compile()方法，提前封装好正则表达式</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">content1 = <span class="string">'2016-12-15 12:00'</span></span><br><span class="line"></span><br><span class="line">pattern=re.compile(<span class="string">'\d&#123;2&#125;:\d&#123;2&#125;'</span>)<span class="comment">#提前编译好正则表达式，可以提供运行效率</span></span><br><span class="line"></span><br><span class="line">result=re.sub(pattern,<span class="string">''</span>,content1)</span><br><span class="line"></span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-要记得的一些常用匹配模式&quot;&gt;&lt;a href=&quot;#1-要记得的一些常用匹配模式&quot; class=&quot;headerlink&quot; title=&quot;1 要记得的一些常用匹配模式&quot;&gt;&lt;/a&gt;1 要记得的一些常用匹配模式&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;\w 匹配字母，数字，和下划线&lt;
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python requests学习笔记</title>
    <link href="http://yoursite.com/2018/01/23/Python-requests%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/01/23/Python-requests学习笔记/</id>
    <published>2018-01-23T14:49:41.000Z</published>
    <updated>2018-01-23T06:56:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Requests-库的基本用法"><a href="#Requests-库的基本用法" class="headerlink" title="Requests 库的基本用法"></a>Requests 库的基本用法</h1><h2 id="1-基本发送GET请求"><a href="#1-基本发送GET请求" class="headerlink" title="1 基本发送GET请求"></a>1 基本发送GET请求</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 get 方式请求</span></span><br><span class="line">response = requests.get(<span class="string">'https://tieba.baidu.com/'</span>)</span><br><span class="line">print(response.text)</span><br></pre></td></tr></table></figure><h2 id="2-发送GET带参数，对变量params传入字典类型即可"><a href="#2-发送GET带参数，对变量params传入字典类型即可" class="headerlink" title="2 发送GET带参数，对变量params传入字典类型即可"></a>2 发送GET带参数，对变量params传入字典类型即可</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">'http://httpbin.org/get'</span></span><br><span class="line">payload = &#123;<span class="string">'name'</span>: <span class="string">'Numb'</span>, <span class="string">'author'</span>: <span class="string">'Linkin Park'</span>&#125;</span><br><span class="line"></span><br><span class="line">response = requests.get(url, params=payload)</span><br><span class="line">print(response.url)</span><br><span class="line">print(response.text)</span><br></pre></td></tr></table></figure><h3 id="2-1-params-同时支持传入列表，达到一个变量赋两个值的效果"><a href="#2-1-params-同时支持传入列表，达到一个变量赋两个值的效果" class="headerlink" title="2.1 params 同时支持传入列表，达到一个变量赋两个值的效果"></a>2.1 params 同时支持传入列表，达到一个变量赋两个值的效果</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload = &#123;<span class="string">'key1'</span>: <span class="string">'value1'</span>, <span class="string">'key2'</span>: [<span class="string">'value2'</span>, <span class="string">'value3'</span>]&#125;</span><br><span class="line"></span><br><span class="line">r = requests.get(<span class="string">'http://httpbin.org/get'</span>, params=payload)</span><br><span class="line"></span><br><span class="line">print(r.url)</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出 ： http://httpbin.org/get?key1=value1&amp;key2=value2&amp;key2=value3</span></span><br></pre></td></tr></table></figure><h2 id="3-发送Post请求，使用data参数传输数据"><a href="#3-发送Post请求，使用data参数传输数据" class="headerlink" title="3 发送Post请求，使用data参数传输数据"></a>3 发送Post请求，使用data参数传输数据</h2><h3 id="3-1-直接传输字典类型到data参数，会自动编码为表单形式发送"><a href="#3-1-直接传输字典类型到data参数，会自动编码为表单形式发送" class="headerlink" title="3.1 直接传输字典类型到data参数，会自动编码为表单形式发送"></a>3.1 直接传输字典类型到data参数，会自动编码为表单形式发送</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">'http://httpbin.org/post'</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">'user'</span>: <span class="string">'abc123'</span>,</span><br><span class="line">    <span class="string">'pass'</span>: <span class="string">'admin'</span></span><br><span class="line">&#125;</span><br><span class="line">response = requests.post(url, data=data) </span><br><span class="line">print(response.text)</span><br></pre></td></tr></table></figure><h3 id="3-2-通过json参数传递json数据到服务器，Requests库会自动编码，这是新特性-如果还是依靠data参数传递json数据，则需要使用json模块进行数据编码再传递给data参数，复杂了一点，不推荐了吧"><a href="#3-2-通过json参数传递json数据到服务器，Requests库会自动编码，这是新特性-如果还是依靠data参数传递json数据，则需要使用json模块进行数据编码再传递给data参数，复杂了一点，不推荐了吧" class="headerlink" title="3.2 通过json参数传递json数据到服务器，Requests库会自动编码，这是新特性,如果还是依靠data参数传递json数据，则需要使用json模块进行数据编码再传递给data参数，复杂了一点，不推荐了吧"></a>3.2 通过json参数传递json数据到服务器，Requests库会自动编码，这是新特性,如果还是依靠data参数传递json数据，则需要使用json模块进行数据编码再传递给data参数，复杂了一点，不推荐了吧</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url = <span class="string">'https://api.github.com/some/endpoint'</span></span><br><span class="line">payload = &#123;<span class="string">'some'</span>: <span class="string">'data'</span>&#125;</span><br><span class="line">r = requests.post(url, json=payload)<span class="comment">##传递json数据给json参数</span></span><br></pre></td></tr></table></figure><h2 id="4-Request库发送get或者post请求后会得到一个response对象，这个对象包含了很多有用的属性"><a href="#4-Request库发送get或者post请求后会得到一个response对象，这个对象包含了很多有用的属性" class="headerlink" title="4 Request库发送get或者post请求后会得到一个response对象，这个对象包含了很多有用的属性"></a>4 Request库发送get或者post请求后会得到一个response对象，这个对象包含了很多有用的属性</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">"http://httpbin.org/post"</span></span><br><span class="line"></span><br><span class="line">data = &#123;<span class="string">'user'</span>:<span class="string">'abc123'</span>,<span class="string">'passwd'</span>:<span class="string">'admin123'</span>&#125;</span><br><span class="line"></span><br><span class="line">r = request.post(url,data=data)</span><br><span class="line"></span><br><span class="line">print(r.text) <span class="comment"># 返回请求的文本字符串</span></span><br><span class="line">print(r.headers) <span class="comment"># 返回请求头</span></span><br><span class="line">print(r.cookies) <span class="comment"># 返回cookies</span></span><br><span class="line">print(r.status_code) <span class="comment"># 返回请求的状态码</span></span><br></pre></td></tr></table></figure><h2 id="5-Session机制：requests库如何保持session，详细参考下面的官方代码示例"><a href="#5-Session机制：requests库如何保持session，详细参考下面的官方代码示例" class="headerlink" title="5 Session机制：requests库如何保持session，详细参考下面的官方代码示例"></a>5 Session机制：requests库如何保持session，详细参考下面的官方代码示例</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = requests.Session() <span class="comment"># 生成一个session对象</span></span><br><span class="line"></span><br><span class="line">s.get(<span class="string">'http://httpbin.org/cookies/set/sessioncookie/123456789'</span>) <span class="comment"># 有示例网站取得sessioncookie</span></span><br><span class="line"></span><br><span class="line">r = s.get(<span class="string">"http://httpbin.org/cookies"</span>) <span class="comment"># 再次发送请求到示例网站，示例网站会返回你的cookie</span></span><br><span class="line"></span><br><span class="line">print(r.text) <span class="comment">#由此回复证明第二次请求也带上了sessioncookie</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：'&#123;"cookies": &#123;"sessioncookie": "123456789"&#125;&#125;'</span></span><br></pre></td></tr></table></figure><p>不过需要注意，就算使用了会话，方法级别的参数也不会被跨请求保持。下面的例子只会和第一个请求发送 cookie ，而非第二个：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = requests.Session()</span><br><span class="line"></span><br><span class="line">r = s.get(<span class="string">'http://httpbin.org/cookies'</span>, cookies=&#123;<span class="string">'from-my'</span>: <span class="string">'browser'</span>&#125;) <span class="comment">#使用了方法级别的参数cookies</span></span><br><span class="line">print(r.text)</span><br><span class="line"><span class="comment"># '&#123;"cookies": &#123;"from-my": "browser"&#125;&#125;'</span></span><br><span class="line"></span><br><span class="line">r = s.get(<span class="string">'http://httpbin.org/cookies'</span>) <span class="comment">#第二次请求cookies方法设置的请求消失了</span></span><br><span class="line">print(r.text)</span><br><span class="line"><span class="comment"># '&#123;"cookies": &#123;&#125;&#125;'</span></span><br></pre></td></tr></table></figure><h2 id="6-会话也可用来为请求方法提供缺省数据。这是通过为会话对象的属性提供数据来实现的："><a href="#6-会话也可用来为请求方法提供缺省数据。这是通过为会话对象的属性提供数据来实现的：" class="headerlink" title="6 会话也可用来为请求方法提供缺省数据。这是通过为会话对象的属性提供数据来实现的："></a>6 会话也可用来为请求方法提供缺省数据。这是通过为会话对象的属性提供数据来实现的：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = requests.Session()</span><br><span class="line">s.auth = (<span class="string">'user'</span>, <span class="string">'pass'</span>) <span class="comment">#提供缺省数据</span></span><br><span class="line">s.headers.update(&#123;<span class="string">'x-test'</span>: <span class="string">'true'</span>&#125;) <span class="comment">#提供缺省数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># both 'x-test' and 'x-test2' are sent</span></span><br><span class="line">r=s.get(<span class="string">'http://httpbin.org/headers'</span>, headers=&#123;<span class="string">'x-test2'</span>: <span class="string">'true'</span>&#125;) <span class="comment">#headers是方法参数</span></span><br><span class="line">print(r.text)</span><br></pre></td></tr></table></figure><h2 id="7-编码问题"><a href="#7-编码问题" class="headerlink" title="7 编码问题"></a>7 编码问题</h2><p>当你收到一个响应时，Requests 会猜测响应的编码方式，用于在你调用 Response.text 方法时对响应进行解码。Requests 首先在 HTTP 头部检测是否存在指定的编码方式，如果不存在，则会使用 charade 来尝试猜测编码方式。</p><h2 id="8-认证问题"><a href="#8-认证问题" class="headerlink" title="8 认证问题"></a>8 认证问题</h2><p>Ref ：<a href="http://requests-oauthlib.readthedocs.io/en/latest/oauth2_workflow.html#introduction" target="_blank" rel="noopener">http://requests-oauthlib.readthedocs.io/en/latest/oauth2_workflow.html#introduction</a></p><h2 id="9-相关中文参考文档"><a href="#9-相关中文参考文档" class="headerlink" title="9 相关中文参考文档"></a>9 相关中文参考文档</h2><p><a href="http://docs.python-requests.org/zh_CN/latest/index.html" target="_blank" rel="noopener">http://docs.python-requests.org/zh_CN/latest/index.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Requests-库的基本用法&quot;&gt;&lt;a href=&quot;#Requests-库的基本用法&quot; class=&quot;headerlink&quot; title=&quot;Requests 库的基本用法&quot;&gt;&lt;/a&gt;Requests 库的基本用法&lt;/h1&gt;&lt;h2 id=&quot;1-基本发送GET请求&quot;&gt;
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python BS4学习笔记</title>
    <link href="http://yoursite.com/2018/01/23/Python-BS4%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/01/23/Python-BS4学习笔记/</id>
    <published>2018-01-23T14:49:17.000Z</published>
    <updated>2018-01-23T06:52:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BS4库的基本用法"><a href="#BS4库的基本用法" class="headerlink" title="BS4库的基本用法"></a>BS4库的基本用法</h1><h2 id="1-简介-四大对象"><a href="#1-简介-四大对象" class="headerlink" title="1 简介,四大对象"></a>1 简介,四大对象</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BeautifulSoup 就是 Python 的一个 HTML 或 XML 的解析库，我们可以用它来方便地从网页中提取数据，</span><br><span class="line"></span><br><span class="line">BeautifulSoup 在解析的时候实际上是依赖于解析器的，它除了支持 Python 标准库中的 HTML 解析器，还支持一些第三方的解析器比如 LXML,日常中推荐LXML ，这个解析器有解析 HTML 和 XML 的功能，而且速度快，容错能力强，所以推荐使用这个解析器来进行解析。</span><br><span class="line"></span><br><span class="line">BeautifulSoup将复杂的HTML文档装换成一个复杂的树形结构，每个节点都是python对象，可归纳为四种：Tag、Navigablestring、Comment、BeautifulSoup.</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soupobj=BeautifulSoup(html,<span class="string">'lxml'</span>)</span><br><span class="line">print(type(soupobj)) </span><br><span class="line">print(type(soupobj.a))</span><br><span class="line">print(type(soupobj.p.string))</span><br><span class="line"></span><br><span class="line"><span class="comment">#output</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">bs4</span>.<span class="title">BeautifulSoup</span>'&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">bs4</span>.<span class="title">element</span>.<span class="title">Tag</span>'&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">bs4</span>.<span class="title">element</span>.<span class="title">NavigableString</span>'&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-BeautifulSoup四大对象之Tag对象：html中的一个个标签，html标签加上里面的内容就是Tag。"><a href="#2-BeautifulSoup四大对象之Tag对象：html中的一个个标签，html标签加上里面的内容就是Tag。" class="headerlink" title="2 BeautifulSoup四大对象之Tag对象：html中的一个个标签，html标签加上里面的内容就是Tag。"></a>2 BeautifulSoup四大对象之Tag对象：html中的一个个标签，html标签加上里面的内容就是Tag。</h2><ol><li>可以利用soup_obj加标签名获取这些标签内容，但它只返回所有内容中的第一个符合要求的标签。</li></ol><figure class="highlight"><table><tr><td class="code"><pre><span class="line">soupobj=BeautifulSoup(html,<span class="string">'lxml'</span>)</span><br><span class="line">print(soupobj.head)</span><br><span class="line">print(soupobj.head.title) <span class="comment">#直接输出节点里面的内容，包括节点本身</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#output</span></span><br><span class="line">&lt;head&gt;&lt;title&gt;The HTML is for test BeautifulSoup&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;title&gt;The HTML is for test BeautifulSoup&lt;/title&gt;</span><br></pre></td></tr></table></figure><ol><li>Tag的两个重要属性name和attrs</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soupobj=BeautifulSoup(html,<span class="string">'lxml'</span>)</span><br><span class="line">print(soupobj.a.name)</span><br><span class="line">print(soupobj.a.attrs) <span class="comment">#返回字典</span></span><br><span class="line">print(soupobj.a.attrs[<span class="string">'class'</span>])<span class="comment">#几种访问具体属性的方法</span></span><br><span class="line">print(soupobj.a[<span class="string">'class'</span>])</span><br><span class="line">print(soupobj.a.get(<span class="string">'class'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#output</span></span><br><span class="line">a</span><br><span class="line">&#123;<span class="string">'id'</span>: <span class="string">'link1'</span>, <span class="string">'href'</span>: <span class="string">'http://www.baidu.com'</span>, <span class="string">'class'</span>: [<span class="string">'sister'</span>]&#125;</span><br><span class="line">[<span class="string">'sister'</span>]</span><br><span class="line">[<span class="string">'sister'</span>]</span><br><span class="line">[<span class="string">'sister'</span>]</span><br></pre></td></tr></table></figure><h2 id="3-NavigableString对象"><a href="#3-NavigableString对象" class="headerlink" title="3 NavigableString对象"></a>3 NavigableString对象</h2><p>已经得到了标签，如何获得标签内的文字。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soupobj=BeautifulSoup(html,<span class="string">'lxml'</span>)</span><br><span class="line">print(soupobj.p.string)</span><br><span class="line">print(soupobj.p.get_text()) <span class="comment">#两种方法访问节点的字符串</span></span><br><span class="line">print(type(soupobj.p.string))</span><br><span class="line"><span class="comment">#output:</span></span><br><span class="line">this <span class="keyword">is</span> title</span><br><span class="line">this <span class="keyword">is</span> title</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">bs4</span>.<span class="title">element</span>.<span class="title">NavigableString</span>'&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-Comment对象-比较少用"><a href="#4-Comment对象-比较少用" class="headerlink" title="4 Comment对象,比较少用"></a>4 Comment对象,比较少用</h2><p>Tag , NavigableString , BeautifulSoup 几乎覆盖了html和xml中的所有内容,<br>但是还有一些特殊对象.容易让人担心的内容是文档的注释部分,Comment 对象是一个特殊类型的 NavigableString 对象:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">markup = <span class="string">"&lt;b&gt;&lt;!--Hey, buddy. Want to buy a used parser?--&gt;&lt;/b&gt;"</span></span><br><span class="line">soup = BeautifulSoup(markup,<span class="string">'lxml'</span>)</span><br><span class="line">comment = soup.b.string</span><br><span class="line">print(comment)</span><br><span class="line">print(type(comment))</span><br><span class="line"></span><br><span class="line"><span class="comment">#output</span></span><br><span class="line">Hey, buddy. Want to buy a used parser?</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">bs4</span>.<span class="title">element</span>.<span class="title">Comment</span>'&gt;</span></span><br></pre></td></tr></table></figure><h2 id="5-BeautifulSoup对象"><a href="#5-BeautifulSoup对象" class="headerlink" title="5 BeautifulSoup对象"></a>5 BeautifulSoup对象</h2><p>BeautifulSoup 对象表示的是一个文档的全部内容.大部分时候,可以把它当作 Tag 对象,它支持 遍历文档树 和 搜索文档树 中描述的大部分的方法.</p><p>因为 BeautifulSoup 对象并不是真正的HTML或XML的tag,所以它没有name和attribute属性.但有时查看它的 .name 属性是很方便的,所以 BeautifulSoup 对象包含了一个值为 “[document]” 的特殊属性 .name</p><h2 id="6-遍历文档树"><a href="#6-遍历文档树" class="headerlink" title="6 遍历文档树"></a>6 遍历文档树</h2><ol><li>理解子节点</li></ol><p>一个Tag可能包含多个字符串或其它的Tag,这些都是这个Tag的子节点.Beautiful Soup提供了许多操作和遍历子节点的属性.</p><p>注意: Beautiful Soup中字符串节点不支持这些属性,因为字符串没有子节点</p><ol><li>.contents 和 .children</li></ol><ul><li>tag的 .contents 属性可以将tag的子节点以列表的方式输出:</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soupobj=BeautifulSoup(html,<span class="string">'lxml'</span>)</span><br><span class="line"></span><br><span class="line">print(soupobj.body.contents) <span class="comment">#tag的 .contents 属性可以将tag的子节点以列表的方式输出:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> soupobj.body.contents:</span><br><span class="line">    print(i.name)<span class="comment">#输出直接子节点,内嵌在子节点里面的节点不输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#output</span></span><br><span class="line"><span class="keyword">None</span></span><br><span class="line">p</span><br><span class="line"><span class="keyword">None</span></span><br><span class="line">p</span><br><span class="line"><span class="keyword">None</span></span><br><span class="line">p</span><br><span class="line"><span class="keyword">None</span></span><br></pre></td></tr></table></figure><ul><li>.children属性返回一个子节点的列表迭代器</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soupobj=BeautifulSoup(html,<span class="string">'lxml'</span>)</span><br><span class="line">i=soupobj.body.children <span class="comment">#返回一个子节点的列表迭代器</span></span><br><span class="line">print(i)</span><br><span class="line"><span class="keyword">for</span> elem <span class="keyword">in</span> i:</span><br><span class="line">    print(elem.name)</span><br><span class="line"></span><br><span class="line"><span class="comment">#output:</span></span><br><span class="line">&lt;list_iterator object at <span class="number">0x101a88160</span>&gt;</span><br><span class="line"><span class="keyword">None</span></span><br><span class="line">p</span><br><span class="line"><span class="keyword">None</span></span><br><span class="line">p</span><br><span class="line"><span class="keyword">None</span></span><br><span class="line">p</span><br><span class="line"><span class="keyword">None</span></span><br></pre></td></tr></table></figure><ul><li>.contents 和 .children 属性仅包含tag的直接子节点.例如,<head>标签只有一个直接子节点<title></title></head></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soupobj=BeautifulSoup(html,<span class="string">'lxml'</span>)</span><br><span class="line">i=soupobj.body.descendants <span class="comment">#返回一个子孙节点的生成器</span></span><br><span class="line">print(i)</span><br><span class="line"><span class="keyword">for</span> elem <span class="keyword">in</span> i:</span><br><span class="line">    print(elem.name)</span><br><span class="line"></span><br><span class="line"><span class="comment">#output</span></span><br><span class="line"></span><br><span class="line">&lt;generator object descendants at <span class="number">0x1041de728</span>&gt;</span><br><span class="line"><span class="keyword">None</span></span><br><span class="line">p</span><br><span class="line">b</span><br><span class="line"><span class="keyword">None</span></span><br><span class="line"><span class="keyword">None</span></span><br><span class="line">p</span><br><span class="line"><span class="keyword">None</span></span><br><span class="line">a</span><br><span class="line"><span class="keyword">None</span></span><br><span class="line"><span class="keyword">None</span></span><br><span class="line">a</span><br><span class="line"><span class="keyword">None</span></span><br><span class="line"><span class="keyword">None</span></span><br><span class="line"><span class="keyword">None</span></span><br><span class="line">p</span><br><span class="line"><span class="keyword">None</span></span><br><span class="line"><span class="keyword">None</span></span><br></pre></td></tr></table></figure><ul><li>兄弟节点的 .next_sibling, .previous_sibling属性,全部兄弟节点的.next_siblings, .previous_siblings属性</li></ul><h2 id="7-搜索文档树"><a href="#7-搜索文档树" class="headerlink" title="7 搜索文档树"></a>7 搜索文档树</h2><ol><li>find_all(name,attrs,recursive,text,limit,**kwargs)方法</li></ol><p>搜索当前tag的所有tag子节点，并判断是否符合过滤器条件。</p><ul><li>name参数：可以查找所有名字为name的tag，字符串对象会被自动忽略掉,函数返回一个list,name参数可以是字符串，正则，列表，True，<br>还可以传方法等</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soupobj=BeautifulSoup(html,<span class="string">'lxml'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> soupobj.find_all(re.compile(<span class="string">'e'</span>)):<span class="comment">#传入正则，调用search()方法</span></span><br><span class="line">    print(i.name)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> soupobj.find_all([<span class="string">'a'</span>,<span class="string">'b'</span>]):<span class="comment">#传入列表</span></span><br><span class="line">    print(i.name)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> soupobj.find_all(<span class="string">'title'</span>):<span class="comment">#传入字符串</span></span><br><span class="line">    print(i.name)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> soupobj.find_all(<span class="keyword">True</span>):<span class="comment">#传入TRUE</span></span><br><span class="line">    print(i.name)</span><br><span class="line"></span><br><span class="line"><span class="comment">#output:</span></span><br><span class="line">body</span><br><span class="line">b</span><br></pre></td></tr></table></figure><ol><li>**kwargs参数：关键字参数，如果一个关键字参数不是搜索内置的参数名,搜索时会把该参数当作tag的属性来搜索,如果包含一个名字为 id 的参数,Beautiful Soup会搜索每个tag的”id”属性.</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> soupobj.find_all(id=<span class="string">'link2'</span>): <span class="comment">#传入关键字参数，函数会搜索id属性等于link2的tag</span></span><br><span class="line">    print(i.name)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> soupobj.find_all(href=re.compile(<span class="string">'baidu'</span>),id=<span class="string">'link2'</span>):<span class="comment">#使用关键字参数过滤多个属性：href,id</span></span><br><span class="line">    print(i.name)</span><br><span class="line"><span class="comment">#output</span></span><br><span class="line">a</span><br><span class="line">a</span><br></pre></td></tr></table></figure><ol><li>按CSS搜索（其实是继续使用关键字参数），可以通过 class<em> 参数搜索有指定CSS类名的tag,class</em> 参数同样接受不同类型的 过滤器 ,字符串,正则表达式,方法或 True</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> soupobj.find_all(class_=<span class="string">'story'</span>): <span class="comment">#单一使用'class_'属性查询</span></span><br><span class="line">    print(i.name)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> soupobj.find_all(href=re.compile(<span class="string">'baidu'</span>),class_=<span class="string">'sister'</span>): <span class="comment">#联合多条件查询</span></span><br><span class="line">    print(i.name)</span><br></pre></td></tr></table></figure><ol><li>通过 text 参数可以搜搜文档中的字符串内容.与 name 参数的可选值一样, text 参数接受 字符串 , 正则表达式 , 列表, True . 看例子:</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(soupobj.find_all(text=re.compile(<span class="string">'this'</span>)))<span class="comment">#感觉用正则作为参数值效果最好</span></span><br><span class="line"><span class="comment">#output</span></span><br><span class="line">[<span class="string">'this is title'</span>, <span class="string">'this is the content\n\n'</span>, <span class="string">'this is herf to link baidu'</span>]</span><br></pre></td></tr></table></figure><ol><li><p>其余的参数包括limit,recursive,limit的作用是限制搜索结果的数目，recursive参数，调用tag的 find_all() 方法时,Beautiful Soup会检索当前tag的所有子孙节点,如果只想搜索tag的直接子节点,可以使用参数 recursive=False .</p></li><li><p>find_all()方法的简写：BeautifulSoup 对象和 tag 对象可以被当作一个方法来使用,这个方法的执行结果与调用这个对象的 find_all() 方法相同,下面两行代码是等价的:</p></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">oup.find_all(<span class="string">"a"</span>)</span><br><span class="line">soup(<span class="string">"a"</span>) <span class="comment">#通过Beautifulsoup对象直接调用find_all</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">soup.title.find_all(text=<span class="keyword">True</span>)<span class="comment">#通过tag对象直接调用</span></span><br><span class="line">soup.title(text=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p>7.CSS选择器语法来查找Tag，soup.select()，返回类型是 list，用 get_text() 方法来获取它的内容</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">print</span> soup.select(<span class="string">'title'</span>)<span class="comment">#标签名查找</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> soup.select(<span class="string">'.sister'</span>)<span class="comment">#class名查找</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> soup.select(<span class="string">'#link1'</span>)<span class="comment">#id名查找</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> soup.select(<span class="string">"head &gt; title"</span>)<span class="comment">#直接子标签查找</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> soup.select(<span class="string">"#subject_list &gt; ul &gt; li &gt; div.info &gt; div.pub"</span>)  <span class="comment">#抓取作者，出版社信息，稍后我们用spite()</span></span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line"></span><br><span class="line"><span class="string">'nth-of-child'</span> <span class="keyword">is</span> simply <span class="keyword">not</span> implemented <span class="keyword">in</span> beautifulsoup4 (at time of writing), </span><br><span class="line"></span><br><span class="line"><span class="comment">#app &gt; div &gt; div &gt; div.main &gt; dl &gt; dd:nth-child(1) &gt; div &gt; div &gt; div.movie-item-info &gt; p.name &gt; a</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;BS4库的基本用法&quot;&gt;&lt;a href=&quot;#BS4库的基本用法&quot; class=&quot;headerlink&quot; title=&quot;BS4库的基本用法&quot;&gt;&lt;/a&gt;BS4库的基本用法&lt;/h1&gt;&lt;h2 id=&quot;1-简介-四大对象&quot;&gt;&lt;a href=&quot;#1-简介-四大对象&quot; class
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python编码问题学习笔记</title>
    <link href="http://yoursite.com/2018/01/23/Python%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/01/23/Python编码问题学习笔记/</id>
    <published>2018-01-23T14:32:06.000Z</published>
    <updated>2018-01-23T06:38:51.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-现在计算机系统通用的字符编码工作方式："><a href="#1-现在计算机系统通用的字符编码工作方式：" class="headerlink" title="1 现在计算机系统通用的字符编码工作方式："></a>1 现在计算机系统通用的字符编码工作方式：</h2><p>在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。python语言有两种不同的字符串，一个用于存储文本，一个用于存储原始字节。文本字符串(str)内部使用Unicode存储，字节字符串(byte)存储原始字节并显示ASCI</p><h2 id="2-Python3中的​encode和decode"><a href="#2-Python3中的​encode和decode" class="headerlink" title="2 Python3中的​encode和decode"></a>2 Python3中的​encode和decode</h2><p>Python3中字符编码经常会使用到decode和encode函数。特别是在抓取网页中，这两个函数用的熟练非常有好处。我的理解，encode的作用，使我们看到的直观的字符转换成计算机内的字节形式。decode刚好相反，把字节形式的字符转换成我们看的懂的、直观的、“人模人样”的形式</p><h2 id="3-如何查看str在内存中的unicode码"><a href="#3-如何查看str在内存中的unicode码" class="headerlink" title="3 如何查看str在内存中的unicode码"></a>3 如何查看str在内存中的unicode码</h2><p>字符在计算机的内存中统一是以Unicode编码的。只有在字符要被写进文件、存进硬盘或者从服务器发送至客户端（例如网页前端的代码）时会变成utf-8。如何把字符以Unicode的字节形式表现出来，露出它在内存中的庐山正面目？这里有个照妖镜：</p><p>xxxx.encode/decode(‘unicode-escape’),</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s=<span class="string">"中文"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.encode(<span class="string">'unicode-escape'</span>) <span class="comment"># 通过encode得到了“中文”的unicode字节码</span></span><br><span class="line"><span class="string">b'\\u4e2d\\u6587'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=<span class="string">"\u4e2d"</span> <span class="comment"># 把“中”的unicode码赋值给b，注意b是str，这就是str在内存的真实面目了</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(b)</span><br><span class="line">中</span><br></pre></td></tr></table></figure><h2 id="4-unicode码在python里有两种表示方式："><a href="#4-unicode码在python里有两种表示方式：" class="headerlink" title="4 unicode码在python里有两种表示方式："></a>4 unicode码在python里有两种表示方式：</h2><p>u’字符串’或者’\u四位十六进制数’。它们是等价的，而且都是str对象。注意，’\u四位十六进制数’与’\u四位十六进制数’并不相等，’\u四位十六进制数’=’\’（斜杠本身是转义字符要经过转义表示）+’u四位十六进制数’。</p><p>Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式,它定义了Unicode符号集的二进制代码如何保存，具体的保存方式参考下面的链接：</p><p>[参考链接][<a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html</a>]</p><h2 id="5-import-chardet-这个模块可以帮助检测当前的字节流编码"><a href="#5-import-chardet-这个模块可以帮助检测当前的字节流编码" class="headerlink" title="5 import chardet 这个模块可以帮助检测当前的字节流编码"></a>5 import chardet 这个模块可以帮助检测当前的字节流编码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s=<span class="string">'abc'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.encode()</span><br><span class="line"><span class="string">b'abc'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>chardet.detect(s.encode())</span><br><span class="line">&#123;<span class="string">'encoding'</span>: <span class="string">'ascii'</span>, <span class="string">'language'</span>: <span class="string">''</span>, <span class="string">'confidence'</span>: <span class="number">1.0</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s=<span class="string">'中文'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>chardet.detect(s.encode())</span><br><span class="line">&#123;<span class="string">'encoding'</span>: <span class="string">'utf-8'</span>, <span class="string">'language'</span>: <span class="string">''</span>, <span class="string">'confidence'</span>: <span class="number">0.7525</span>&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-现在计算机系统通用的字符编码工作方式：&quot;&gt;&lt;a href=&quot;#1-现在计算机系统通用的字符编码工作方式：&quot; class=&quot;headerlink&quot; title=&quot;1 现在计算机系统通用的字符编码工作方式：&quot;&gt;&lt;/a&gt;1 现在计算机系统通用的字符编码工作方式：&lt;/
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Clickjacking test method</title>
    <link href="http://yoursite.com/2017/09/02/Clickjacking-test-method/"/>
    <id>http://yoursite.com/2017/09/02/Clickjacking-test-method/</id>
    <published>2017-09-01T16:48:19.000Z</published>
    <updated>2017-09-01T08:51:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="how-to-test-the-clickjacking-POC-gen"><a href="#how-to-test-the-clickjacking-POC-gen" class="headerlink" title="how to test the clickjacking (POC gen)"></a>how to test the clickjacking (POC gen)</h1><p>burp有一个功能能够生成POC</p><ol><li>生成js文件</li><li>直接在web console复制执行</li><li>目标页面嵌入了其中</li></ol><h1 id="Ref-link"><a href="#Ref-link" class="headerlink" title="Ref link"></a>Ref link</h1><p><a href="https://support.portswigger.net/customer/en/portal/articles/2363105-using-burp-to-find-clickjacking-vulnerabilities" target="_blank" rel="noopener">https://support.portswigger.net/customer/en/portal/articles/2363105-using-burp-to-find-clickjacking-vulnerabilities</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;how-to-test-the-clickjacking-POC-gen&quot;&gt;&lt;a href=&quot;#how-to-test-the-clickjacking-POC-gen&quot; class=&quot;headerlink&quot; title=&quot;how to test the clic
      
    
    </summary>
    
    
      <category term="Web security" scheme="http://yoursite.com/tags/Web-security/"/>
    
  </entry>
  
</feed>
