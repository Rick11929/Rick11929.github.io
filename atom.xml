<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rick7dology</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-01-24T10:23:05.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Rick7</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java 反序列化漏洞学习笔记</title>
    <link href="http://yoursite.com/2018/01/24/Java-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/01/24/Java-反序列化漏洞学习笔记/</id>
    <published>2018-01-24T15:59:15.000Z</published>
    <updated>2018-01-24T10:23:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-什么是Java序列化和反序列化"><a href="#1-什么是Java序列化和反序列化" class="headerlink" title="1 什么是Java序列化和反序列化:"></a>1 什么是Java序列化和反序列化:</h1><ol><li><p>Java 序列化是指把 Java 对象转换为字节序列的过程便于保存在内存、文件、数据库中，ObjectOutputStream类的 writeObject() 方法可以实现序列化。</p></li><li><p>Java 反序列化是指把字节序列恢复为 Java 对象的过程，ObjectInputStream 类的 readObject() 方法用于反序列化。</p></li><li><p>网络上传输和本地硬盘中存储的是字节流，即01010之类的数据，所以序列化在传输和存储中是必要的,问题的根源在于类ObjectInputStream在反序列化时，没有对生成的对象的类型做限制；</p></li><li><p>首先在序列化和反序列化的过程中，每个类都有自己的readObject与writeObject对应，很多类自己重写了自己的readObject与writeObject函数，是否有漏洞要看程序有没有用了一些指定的库</p></li><li><p>基本的序列化和反序列化代码：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">    String obj = <span class="string">"hello world!"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将序列化对象写入文件object.db中</span></span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"object.db"</span>);</span><br><span class="line">    ObjectOutputStream os = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">    os.writeObject(obj);</span><br><span class="line">    os.close();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从文件object.db中读取数据</span></span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"object.db"</span>);</span><br><span class="line">    ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(fis);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过反序列化恢复对象obj</span></span><br><span class="line">    String obj2 = (String)ois.readObject();</span><br><span class="line">    ois.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-攻击方法"><a href="#2-攻击方法" class="headerlink" title="2 攻击方法:"></a>2 攻击方法:</h1><p>Java的某些库暴露或间接暴露反序列化API ，导致用户可以操作传入数据，两个或多个看似安全的模块在同一运行环境下，共同产生的安全问题，攻击者可以精心构造反序列化对象并执行恶意代码，主要方法是重写readObject()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="comment">//重写readObject()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span>&#123;</span><br><span class="line">        <span class="comment">//执行默认的readObject()方法</span></span><br><span class="line">        in.defaultReadObject();</span><br><span class="line">        <span class="comment">//执行打开计算器程序命令</span></span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">"open /Applications/Calculator.app/"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-经典漏洞："><a href="#3-经典漏洞：" class="headerlink" title="3 经典漏洞："></a>3 经典漏洞：</h1><ol><li>使用了有安全缺陷的Apache Commons Collections jar包 ,调用关系好复杂，Java渣渣看不明白 ，简单总结几句：</li></ol><ul><li><p>三个关键类：AnnotationInvocationHandler，TransformedMap.decorate，InvokerTransformer</p></li><li><p>nvokerTransformer函数只需要传入方法名，参数类型，参数即可调用任意函数。通过这个函数构造调用链能够执行Runtime.exec()。而InvokerTransformer存在于Apache Commons Collections的库中，因此目标应用中需要有这个库，函数才能得到执行</p></li></ul><h1 id="4-利用工具："><a href="#4-利用工具：" class="headerlink" title="4 利用工具："></a>4 利用工具：</h1><p><a href="https://github.com/frohoff/ysoserial" target="_blank" rel="noopener">https://github.com/frohoff/ysoserial</a></p><h1 id="5-发现漏洞："><a href="#5-发现漏洞：" class="headerlink" title="5 发现漏洞："></a>5 发现漏洞：</h1><blockquote><p>1 首先拿到一个Java应用，需要找到一个接受外部输入的序列化对象的接收点，即反序列化漏洞的触发点。我们可以通过审计源码中对反序列化函数的调用readObject来寻找，也可以直接通过对应用交互流量进行抓包，查看流量中是否包含java序列化数据来判断，java序列化数据的特征为以标记（ac ed 00 05）开头。</p><p>2 确定了反序列化输入点后，再考察应用的Class Path中是否包含Apache Commons Collections库（ysoserial所支持的其他库亦可），如果是，就可以使用ysoserial来生成反序列化的payload</p><p>3 从流量中发现序列化的痕迹，关键字：ac ed 00 05，rO0AB</p><p>4 Java RMI 的传输 100% 基于反序列化，Java RMI 的默认端口是1099端口</p><p>5 从源码入手，可以被序列化的类一定实现了Serializable接口<br>观察反序列化时的readObject()方法是否重写，重写中是否有设计不合理，可以被利用之处</p></blockquote><p>Refer link:</p><ul><li>[1][ <a href="https://paper.seebug.org/312/" target="_blank" rel="noopener">https://paper.seebug.org/312/</a>]</li><li>[2][ <a href="http://www.cnblogs.com/alert123/p/5124637.html" target="_blank" rel="noopener">http://www.cnblogs.com/alert123/p/5124637.html</a>]</li><li>[3][ <a href="https://blog.chaitin.cn/2015-11-11_java_unserialize_rce/" target="_blank" rel="noopener">https://blog.chaitin.cn/2015-11-11_java_unserialize_rce/</a>]</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-什么是Java序列化和反序列化&quot;&gt;&lt;a href=&quot;#1-什么是Java序列化和反序列化&quot; class=&quot;headerlink&quot; title=&quot;1 什么是Java序列化和反序列化:&quot;&gt;&lt;/a&gt;1 什么是Java序列化和反序列化:&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p
      
    
    </summary>
    
    
      <category term="Web security" scheme="http://yoursite.com/tags/Web-security/"/>
    
  </entry>
  
  <entry>
    <title>Python MongoDB学习笔记</title>
    <link href="http://yoursite.com/2018/01/23/Python-MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/01/23/Python-MongoDB学习笔记/</id>
    <published>2018-01-23T14:51:08.000Z</published>
    <updated>2018-01-24T06:57:49.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-MongoDB-常用函数实例代码"><a href="#1-MongoDB-常用函数实例代码" class="headerlink" title="1 MongoDB 常用函数实例代码"></a>1 MongoDB 常用函数实例代码</h1><ol><li><p>连接 MongoDB 我们需要使用 PyMongo 库里面的 MongoClient，一般来说传入 MongoDB 的 IP 及端口即可，第一个参数为地址 host，第二个参数为端口 port，端口如果不传默认是 27017</p></li><li><p>MongoDB 中还分为一个个数据库，我们接下来的一步就是指定要操作哪个数据库，在这里我以 test 数据库为例进行说明，所以下一步我们需要在程序中指定要使用的数据库</p></li><li><p>MongoDB 的每个数据库又包含了许多集合 Collection，也就类似与关系型数据库中的表，下一步我们需要指定要操作的集合</p></li><li><p>在 MongoDB 中，每条数据其实都有一个 _id 属性来唯一标识，如果没有显式指明 _id，MongoDB 会自动产生一个 ObjectId 类型的 _id 属性。insert() 方法会在执行后返回的 _id 值</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line">client = pymongo.MongoClient(host=<span class="string">'localhost'</span>, port=<span class="number">27017</span>) <span class="comment"># 链接数据库，得到数据库对象“client"</span></span><br><span class="line">db = client.test <span class="comment"># 新建或者选择”test“数据库</span></span><br><span class="line"><span class="comment"># db = client['test']</span></span><br><span class="line">collection = db.students <span class="comment"># 新建或者选择”students“ collection对象</span></span><br><span class="line"><span class="comment"># collection = db['students']</span></span><br><span class="line"></span><br><span class="line">student1 = &#123;</span><br><span class="line">    <span class="string">'id'</span>: <span class="string">'20170101'</span>,</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'Jordan'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="string">'gender'</span>: <span class="string">'male'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">student2 = &#123;</span><br><span class="line">    <span class="string">'id'</span>: <span class="string">'20170202'</span>,</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'Mike'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">21</span>,</span><br><span class="line">    <span class="string">'gender'</span>: <span class="string">'male'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># result = collection.insert(student) 官方不推荐用这个方法</span></span><br><span class="line"><span class="comment"># print(result)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># result = collection.insert_one(student) # 对collection对象进行数据插入</span></span><br><span class="line"><span class="comment"># print(result)</span></span><br><span class="line"><span class="comment"># print(result.inserted_id)</span></span><br><span class="line"></span><br><span class="line">result = collection.insert_many([student1, student2]) <span class="comment"># 对collection对象进行多个数据插入</span></span><br><span class="line">print(result)</span><br><span class="line">print(result.inserted_ids)</span><br><span class="line"></span><br><span class="line">result = collection.find_one(&#123;<span class="string">'name'</span>: <span class="string">'Mike'</span>&#125;) <span class="comment"># 对collection对象进行查找</span></span><br><span class="line">print(type(result))</span><br><span class="line">print(result) <span class="comment"># 可以发现它多了一个 _id 属性，这就是 MongoDB 在插入的过</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-MongoDB-常用函数实例代码&quot;&gt;&lt;a href=&quot;#1-MongoDB-常用函数实例代码&quot; class=&quot;headerlink&quot; title=&quot;1 MongoDB 常用函数实例代码&quot;&gt;&lt;/a&gt;1 MongoDB 常用函数实例代码&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python Selenium库学习笔记</title>
    <link href="http://yoursite.com/2018/01/23/Python-Selenium%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/01/23/Python-Selenium库学习笔记/</id>
    <published>2018-01-23T14:50:49.000Z</published>
    <updated>2018-01-23T06:56:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-声明浏览器对象"><a href="#1-声明浏览器对象" class="headerlink" title="1 声明浏览器对象"></a>1 声明浏览器对象</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver </span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome() <span class="comment">#得到各类浏览器对象，当然需要先下载各类浏览器驱动</span></span><br><span class="line">browser = webdriver.Firefox()</span><br><span class="line">browser = webdriver.Edge()</span><br><span class="line">browser = webdriver.PhantomJS()</span><br><span class="line">browser = webdriver.Safari()</span><br></pre></td></tr></table></figure><h1 id="2-访问页面"><a href="#2-访问页面" class="headerlink" title="2 访问页面"></a>2 访问页面</h1><p>用 get() 方法来请求一个网页，参数传入链接 URL 即可，比如在这里我们用 get() 方法访问淘宝，然后打印出源代码，代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">'https://www.taobao.com'</span>)<span class="comment">#请求淘宝页面</span></span><br><span class="line">print(browser.page_source)<span class="comment">#得到网页源代码</span></span><br><span class="line">browser.close()<span class="comment">#浏览器关闭</span></span><br></pre></td></tr></table></figure><h1 id="3-查找节点"><a href="#3-查找节点" class="headerlink" title="3 查找节点"></a>3 查找节点</h1><p>用于填充表单、模拟点击等等，比如我们想要完成向某个输入框输入文字的操作，总得需要知道这个输入框在哪里吧？所以 Selenium 提供了一系列查找节点的方法，我们可以用这些方法来获取想要的节点，以便于下一步执行一些动作或者提取信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">'https://www.taobao.com'</span>)</span><br><span class="line">input_first = browser.find_element_by_id(<span class="string">'q'</span>) <span class="comment">#find_element_by_id()方法</span></span><br><span class="line">input_second = browser.find_element_by_css_selector(<span class="string">'#q'</span>)<span class="comment">#find_element_by_css_selector()方法</span></span><br><span class="line">input_third = browser.find_element_by_xpath(<span class="string">'//*[@id="q"]'</span>)<span class="comment">#find_element_by_xpath()方法</span></span><br><span class="line">print(input_first, input_second, input_third)</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure><p>列出所有获取单个节点的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">find_element_by_id</span><br><span class="line">find_element_by_name</span><br><span class="line">find_element_by_xpath</span><br><span class="line">find_element_by_link_text</span><br><span class="line">find_element_by_partial_link_text</span><br><span class="line">find_element_by_tag_name</span><br><span class="line">find_element_by_class_name</span><br><span class="line">find_element_by_css_selector</span><br><span class="line"></span><br><span class="line">find_element_by_id(id) 就等价于 find_element(By.ID, id)，二者得到的结果完全一致。</span><br></pre></td></tr></table></figure><h1 id="4-查找多节点"><a href="#4-查找多节点" class="headerlink" title="4 查找多节点"></a>4 查找多节点</h1><p>用 find_elements() 这样的方法，方法名称中 element 多了一个 s ，注意区分，也就是说，上面列举的方法加“s”就能实现多节点查找<br>如果我们用 find_element() 方法，只能获取匹配的第一个节点，结果是 WebElement 类型，如果用 find_elements() 方法，<br>则结果是<strong>列表类型，列表的每个节点是 WebElement 类型</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">find_elements_by_id</span><br><span class="line">find_elements_by_name</span><br><span class="line">find_elements_by_xpath</span><br><span class="line">find_elements_by_link_text</span><br><span class="line">find_elements_by_partial_link_text</span><br><span class="line">find_elements_by_tag_name</span><br><span class="line">find_elements_by_class_name</span><br><span class="line">find_elements_by_css_selector</span><br></pre></td></tr></table></figure><h1 id="5-节点交互"><a href="#5-节点交互" class="headerlink" title="5 节点交互"></a>5 节点交互</h1><p>Selenium 可以驱动浏览器来执行一些操作，也就是说我们可以让浏览器模拟执行一些动作，比较常见的用法有：<br>输入文字用 send_keys() 方法，清空文字用 clear() 方法，另外还有按钮点击，用 click() 方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()<span class="comment">#得到浏览器对象</span></span><br><span class="line">browser.get(<span class="string">'https://www.taobao.com'</span>)<span class="comment">#请求淘宝网</span></span><br><span class="line">input = browser.find_element_by_id(<span class="string">'q'</span>)<span class="comment">#查找id=q的元素，得到输入框&lt;input&gt;</span></span><br><span class="line">input.send_keys(<span class="string">'iPhone'</span>)<span class="comment">#调用send_keys()方法输入‘iPhone’</span></span><br><span class="line">time.sleep(<span class="number">1</span>)<span class="comment">#等待一秒</span></span><br><span class="line">input.clear()<span class="comment">#清空输入框</span></span><br><span class="line">input.send_keys(<span class="string">'iPad'</span>)<span class="comment">#再次输入新的字符串'iPad'</span></span><br><span class="line">button = browser.find_element_by_class_name(<span class="string">'btn-search'</span>)<span class="comment">#查找class为'btn-search'，得到button节点</span></span><br><span class="line">button.click()<span class="comment">#调用click()进行搜索</span></span><br></pre></td></tr></table></figure><h1 id="6-延时等待-显式等待"><a href="#6-延时等待-显式等待" class="headerlink" title="6 延时等待 - 显式等待"></a>6 延时等待 - 显式等待</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome() <span class="comment">#得到浏览器对象</span></span><br><span class="line">browser.get(<span class="string">'https://www.taobao.com/'</span>) <span class="comment">#发出请求</span></span><br><span class="line">wait = WebDriverWait(browser, <span class="number">10</span>) <span class="comment">#得到WebDriverWait对象</span></span><br><span class="line">input = wait.until(EC.presence_of_element_located((By.ID, <span class="string">'q'</span>))) <span class="comment">#使用EC设置等待条件：等待id为q的元素加载</span></span><br><span class="line">button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, <span class="string">'.btn-search'</span>)))<span class="comment">#等待button按钮可以点击</span></span><br><span class="line">print(input, button)</span><br></pre></td></tr></table></figure><p>所以这样可以做到的效果就是，在 10 秒内如果 ID 为 q 的节点即搜索框成功加载出来了，那就返回该节点，如果超过10 秒还没有加载出来，那就抛出异常。<br>对于按钮，可以更改一下等待条件，比如改为 element_to_be_clickable，也就是可点击，所以查找按钮时是查找 CSS 选择器为 .btn-search 的按钮，如果 10 秒内它是可点击的也就是成功加载出来了，那就返回这个按钮节点，如果超过 10 秒还不可点击，也就是没有加载出来，那就抛出异常。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-声明浏览器对象&quot;&gt;&lt;a href=&quot;#1-声明浏览器对象&quot; class=&quot;headerlink&quot; title=&quot;1 声明浏览器对象&quot;&gt;&lt;/a&gt;1 声明浏览器对象&lt;/h1&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python 正则库学习笔记</title>
    <link href="http://yoursite.com/2018/01/23/Python-%E6%AD%A3%E5%88%99%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/01/23/Python-正则库学习笔记/</id>
    <published>2018-01-23T14:50:12.000Z</published>
    <updated>2018-01-23T06:56:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-要记得的一些常用匹配模式"><a href="#1-要记得的一些常用匹配模式" class="headerlink" title="1 要记得的一些常用匹配模式"></a>1 要记得的一些常用匹配模式</h1><ul><li>\w 匹配字母，数字，和下划线</li><li>\W 匹配非字母数字，和下划线</li><li>\s 匹配任意空白字符，例如[\t\n\r\f]，其中”\t”是制表符</li><li>\S 匹配任意非空白字符</li><li>\d 匹配任意数字，等价于[0-9]</li><li>^  匹配字符串开头</li><li>$  匹配字符串结尾</li><li>.  匹配任意字符，除了换行符</li><li>* 匹配0个或者多个的表达式</li><li><ul><li>匹配1个或者多个的表达式</li></ul></li><li>?  匹配0个或者1个前面的表达式，非贪婪模式</li><li>{n} 匹配前面的表达式n次</li><li>{n,m} 匹配前面的表达式n到m次，贪婪模式</li></ul><h1 id="2-python的re库"><a href="#2-python的re库" class="headerlink" title="2 python的re库"></a>2 python的re库</h1><h2 id="match-方法，一定要从头开始才匹配"><a href="#match-方法，一定要从头开始才匹配" class="headerlink" title="match()方法，一定要从头开始才匹配"></a>match()方法，一定要从头开始才匹配</h2><ol><li>match() 方法会尝试从字符串的起始位置匹配正则表达式，如果匹配，就返回匹配成功的结果，如果不匹配，那就返回 None。match() 方法是从字符串的开头开始匹配，一旦开头不匹配，那么整个匹配就失败了。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">content = <span class="string">'Hello 123 4567 World_This is a Regex Demo'</span></span><br><span class="line"></span><br><span class="line">print(len(content))</span><br><span class="line"></span><br><span class="line">result=re.match(<span class="string">'^Hello\s\d\d\d\s\d&#123;4&#125;\s\w&#123;10&#125;'</span>,content) <span class="comment">#第一个参数是正则，第二个参数是目标字符串</span></span><br><span class="line"></span><br><span class="line">print(result) <span class="comment">#返回一个结果对象：SRE_Match 对象</span></span><br><span class="line">print(result.span()) <span class="comment">#返回匹配的字符串起始位置</span></span><br><span class="line">print(result.group()) <span class="comment"># 返回匹配的结果字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#output：</span></span><br><span class="line"><span class="number">41</span></span><br><span class="line">&lt;_sre.SRE_Match object; span=(<span class="number">0</span>, <span class="number">25</span>), match=<span class="string">'Hello 123 4567 World_This'</span>&gt;</span><br><span class="line">(<span class="number">0</span>, <span class="number">25</span>)</span><br><span class="line">Hello <span class="number">123</span> <span class="number">4567</span> World_This</span><br><span class="line">()</span><br></pre></td></tr></table></figure><ol><li>在这里可以使用 () 括号来将我们想提取的子字符串括起来，() 实际上就是标记了一个子表达式的开始和结束位置，被标记的每个子表达式会依次对应每一个分组，我们可以调用 group() 方法传入分组的索引即可获取提取的结果。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">content = <span class="string">'Hello 123 4567 World_This is a Regex Demo'</span></span><br><span class="line"></span><br><span class="line">print(len(content))</span><br><span class="line"></span><br><span class="line">result=re.match(<span class="string">'^Hello\s\d\d\d\s(\d&#123;4&#125;)\s\w&#123;10&#125;'</span>,content)</span><br><span class="line"></span><br><span class="line">print(result.group(<span class="number">1</span>)) <span class="comment">#</span></span><br><span class="line">print(result.groups())</span><br><span class="line"></span><br><span class="line"><span class="comment">#output:</span></span><br><span class="line"><span class="number">41</span></span><br><span class="line"><span class="number">4567</span></span><br><span class="line">(<span class="string">'4567'</span>,)</span><br></pre></td></tr></table></figure><ol><li>通用匹配，改进上面的正则表达式</li></ol><p>一个万能匹配可以用，也就是 .* （点星），.（点）可以匹配任意字符（除换行符），*（星） 又代表匹配前面的字符无限次，所以它们组合在一起就可以匹配任意的字符了，有了它我们就不用挨个字符地匹配了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">content = <span class="string">'Hello 123 4567 World_This is a Regex Demo'</span></span><br><span class="line"></span><br><span class="line">print(len(content))</span><br><span class="line"></span><br><span class="line">result=re.match(<span class="string">'^Hello.*Demo$'</span>,content) <span class="comment">#使用了.\* （点星）进行通用匹配</span></span><br><span class="line"></span><br><span class="line">print(result.group())</span><br><span class="line"></span><br><span class="line"><span class="comment">#output:</span></span><br><span class="line"></span><br><span class="line"><span class="number">41</span></span><br><span class="line">Hello <span class="number">123</span> <span class="number">4567</span> World_This <span class="keyword">is</span> a Regex Demo</span><br><span class="line">()</span><br></pre></td></tr></table></figure><p>4.贪婪与非贪婪</p><p>这里就涉及一个贪婪匹配与非贪婪匹配的原因了，贪婪匹配下，.* 会匹配尽可能多的字符，我们的正则表达式中 .* 后面是 \d+，也就是至少一个数字，并没有指定具体多少个数字，所以 .* 就尽可能匹配多的字符，所以它把 123456 也匹配了，给 \d+ 留下一个可满足条件的数字 7，所以 \d+ 得到的内容就只有数字 7 了。+</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">content = <span class="string">'Hello 123 4567 World_This is a Regex Demo'</span></span><br><span class="line"></span><br><span class="line">print(len(content))</span><br><span class="line"></span><br><span class="line">result=re.match(<span class="string">'^He.*(\d+).*Demo$'</span>,content) <span class="comment">#贪婪模式</span></span><br><span class="line"></span><br><span class="line">print(result.group())</span><br><span class="line"></span><br><span class="line">print(result.groups())</span><br></pre></td></tr></table></figure><p>贪婪匹配是尽可能匹配多的字符，非贪婪匹配就是尽可能匹配少的字符，.*? 之后是 \d+ 用来匹配数字，当 .*? 匹配到 Hello 后面的空白字符的时候，再往后的字符就是数字了，而 \d+ 恰好可以匹配，那么这里 .*? 就不再进行匹配，交给 \d+ 去匹配后面的数字。所以这样，.*? 匹配了尽可能少的字符，\d+ 的结果就是 1234567 了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">content = <span class="string">'Hello 1234567 World_This is a Regex Demo'</span></span><br><span class="line"></span><br><span class="line">print(len(content))</span><br><span class="line"></span><br><span class="line">result=re.match(<span class="string">'^He.*?(\d+).*Demo$'</span>,content) <span class="comment">#非贪婪模式</span></span><br><span class="line"></span><br><span class="line">print(result.group())</span><br><span class="line"></span><br><span class="line">print(result.groups())</span><br><span class="line"></span><br><span class="line"><span class="comment">#output:</span></span><br><span class="line"></span><br><span class="line"><span class="number">40</span></span><br><span class="line">Hello <span class="number">1234567</span> World_This <span class="keyword">is</span> a Regex Demo</span><br><span class="line">(<span class="string">'1234567'</span>,)</span><br></pre></td></tr></table></figure><p><strong>实验证明，使用 .*? (点星问号) 和 .+?（点加问号）可以实现非贪婪模式匹配,在字符串中间尽量用非贪婪模式匹配，在字符串结尾用贪婪模式匹配</strong></p><p>5 修饰符(match方法的第三个参数)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">content = <span class="string">'''Hello 1234567 World_This</span></span><br><span class="line"><span class="string">is a Regex Demo</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">result = re.match(<span class="string">'^He.*?(\d+).*?Demo$'</span>, content,re.S) <span class="comment">#增加了re.S,使得(.*?)可以匹配换行符</span></span><br><span class="line">print(result.group(<span class="number">1</span>))</span><br></pre></td></tr></table></figure><h2 id="search-方法，匹配第一个结果"><a href="#search-方法，匹配第一个结果" class="headerlink" title="search()方法，匹配第一个结果"></a>search()方法，匹配第一个结果</h2><p>match() 方法是从字符串的开头开始匹配，一旦开头不匹配，那么整个匹配就失败了，search()方法在匹配时会扫描整个字符串，然后返回第一个成功匹配的结果，也就是说，正则表达式可以是字符串的一部分，在匹配时，search() 方法会依次扫描字符串，直到找到第一个符合规则的字符串，然后返回匹配内容，如果搜索完了还没有找到，那就返回 None，为了匹配方便，我们可以尽量使用 search() 方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">html = <span class="string">'''&lt;div id="songs-list"&gt;</span></span><br><span class="line"><span class="string">    &lt;h2 class="title"&gt;经典老歌&lt;/h2&gt;</span></span><br><span class="line"><span class="string">    &lt;p class="introduction"&gt;</span></span><br><span class="line"><span class="string">        经典老歌列表</span></span><br><span class="line"><span class="string">    &lt;/p&gt;</span></span><br><span class="line"><span class="string">    &lt;ul id="list" class="list-group"&gt;</span></span><br><span class="line"><span class="string">        &lt;li data-view="2"&gt;一路上有你&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li data-view="7"&gt;</span></span><br><span class="line"><span class="string">            &lt;a href="/2.mp3" singer="任贤齐"&gt;沧海一声笑&lt;/a&gt;</span></span><br><span class="line"><span class="string">        &lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li data-view="4" class="active"&gt;</span></span><br><span class="line"><span class="string">            &lt;a href="/3.mp3" singer="齐秦"&gt;往事随风&lt;/a&gt;</span></span><br><span class="line"><span class="string">        &lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li data-view="6"&gt;&lt;a href="/4.mp3" singer="beyond"&gt;光辉岁月&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li data-view="5"&gt;&lt;a href="/5.mp3" singer="陈慧琳"&gt;记事本&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;li data-view="5"&gt;</span></span><br><span class="line"><span class="string">            &lt;a href="/6.mp3" singer="邓丽君"&gt;&lt;i class="fa fa-user"&gt;&lt;/i&gt;但愿人长久&lt;/a&gt;</span></span><br><span class="line"><span class="string">        &lt;/li&gt;</span></span><br><span class="line"><span class="string">    &lt;/ul&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;'''</span></span><br><span class="line"></span><br><span class="line">result=re.search(<span class="string">'&lt;li.*?4.*?active.*?singer="(.*?)"&gt;(.*?)&lt;/a&gt;'</span>,html,re.S)</span><br><span class="line">print(result.group())</span><br><span class="line">print(result.group(<span class="number">1</span>))</span><br><span class="line">print(result.group(<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#output:</span></span><br><span class="line">&lt;li data-view="2"&gt;一路上有你&lt;/li&gt;</span><br><span class="line">        &lt;li data-view=<span class="string">"7"</span>&gt;</span><br><span class="line">            &lt;a href="/2.mp3" singer="任贤齐"&gt;沧海一声笑&lt;/a&gt;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">        &lt;li data-view="4" class="active"&gt;</span><br><span class="line">            &lt;a href="/3.mp3" singer="齐秦"&gt;往事随风&lt;/a&gt;</span><br><span class="line">齐秦</span><br><span class="line">往事随风</span><br></pre></td></tr></table></figure><h2 id="findall-方法-返回列表"><a href="#findall-方法-返回列表" class="headerlink" title="findall()方法,返回列表"></a>findall()方法,返回列表</h2><p>在前面我们说了 search()方法的用法，它可以返回匹配正则表达式的第一个内容，但是如果我们想要获取匹配正则表达式的所有内容的话怎么办？这时就需要借助于 findall() 方法了。如果有返回结果的话就是列表类型，所以我们需要遍历一下来获依次获取每组内容。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">result=re.findall(<span class="string">'&lt;li.*?href="(.*?)".*?singer="(.*?)"&gt;(.*?)&lt;/a&gt;'</span>,html,re.S)</span><br><span class="line"><span class="comment"># print(result.group())</span></span><br><span class="line">print(isinstance(result,list))</span><br><span class="line">print(type(result))</span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line"><span class="comment">#output:</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">list</span>'&gt;</span></span><br><span class="line">[('/2.mp3', '任贤齐', '沧海一声笑'), ('/3.mp3', '齐秦', '往事随风'), ('/4.mp3', 'beyond', '光辉岁月'), ('/5.mp3', '陈慧琳', '记事本'), ('/6.mp3', '邓丽君', '&lt;i class="fa fa-user"&gt;&lt;/i&gt;但愿人长久')]</span><br></pre></td></tr></table></figure><p>所以，如果只是获取第一个内容，可以用 search() 方法，当需要提取多个内容时，就可以用 findall() 方法。+</p><h2 id="sub-方法，用于修改文本-返回修改后的字符串"><a href="#sub-方法，用于修改文本-返回修改后的字符串" class="headerlink" title="sub()方法，用于修改文本,返回修改后的字符串"></a>sub()方法，用于修改文本,返回修改后的字符串</h2><p>第一个参数传入正则表达式来匹配需要替换的内容，然后第二个参数是替换成的字符串，要去掉的话就可以赋值为空，第三个参数就是原字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">content = <span class="string">'''Hello 1234567 World_This</span></span><br><span class="line"><span class="string">is a Regex Demo</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">result = re.sub(<span class="string">'\d+'</span>,<span class="string">''</span>,content,re.S)</span><br><span class="line">print(result)<span class="comment">#返回一个字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#output:</span></span><br><span class="line"></span><br><span class="line">Hello  World_This</span><br><span class="line"><span class="keyword">is</span> a Regex Demo</span><br></pre></td></tr></table></figure><h2 id="compile-方法，提前封装好正则表达式"><a href="#compile-方法，提前封装好正则表达式" class="headerlink" title="compile()方法，提前封装好正则表达式"></a>compile()方法，提前封装好正则表达式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">content1 = <span class="string">'2016-12-15 12:00'</span></span><br><span class="line"></span><br><span class="line">pattern=re.compile(<span class="string">'\d&#123;2&#125;:\d&#123;2&#125;'</span>)<span class="comment">#提前编译好正则表达式，可以提供运行效率</span></span><br><span class="line"></span><br><span class="line">result=re.sub(pattern,<span class="string">''</span>,content1)</span><br><span class="line"></span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-要记得的一些常用匹配模式&quot;&gt;&lt;a href=&quot;#1-要记得的一些常用匹配模式&quot; class=&quot;headerlink&quot; title=&quot;1 要记得的一些常用匹配模式&quot;&gt;&lt;/a&gt;1 要记得的一些常用匹配模式&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;\w 匹配字母，数字，和下划线&lt;
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python requests学习笔记</title>
    <link href="http://yoursite.com/2018/01/23/Python-requests%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/01/23/Python-requests学习笔记/</id>
    <published>2018-01-23T14:49:41.000Z</published>
    <updated>2018-01-23T06:56:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Requests-库的基本用法"><a href="#Requests-库的基本用法" class="headerlink" title="Requests 库的基本用法"></a>Requests 库的基本用法</h1><h2 id="1-基本发送GET请求"><a href="#1-基本发送GET请求" class="headerlink" title="1 基本发送GET请求"></a>1 基本发送GET请求</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 get 方式请求</span></span><br><span class="line">response = requests.get(<span class="string">'https://tieba.baidu.com/'</span>)</span><br><span class="line">print(response.text)</span><br></pre></td></tr></table></figure><h2 id="2-发送GET带参数，对变量params传入字典类型即可"><a href="#2-发送GET带参数，对变量params传入字典类型即可" class="headerlink" title="2 发送GET带参数，对变量params传入字典类型即可"></a>2 发送GET带参数，对变量params传入字典类型即可</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">'http://httpbin.org/get'</span></span><br><span class="line">payload = &#123;<span class="string">'name'</span>: <span class="string">'Numb'</span>, <span class="string">'author'</span>: <span class="string">'Linkin Park'</span>&#125;</span><br><span class="line"></span><br><span class="line">response = requests.get(url, params=payload)</span><br><span class="line">print(response.url)</span><br><span class="line">print(response.text)</span><br></pre></td></tr></table></figure><h3 id="2-1-params-同时支持传入列表，达到一个变量赋两个值的效果"><a href="#2-1-params-同时支持传入列表，达到一个变量赋两个值的效果" class="headerlink" title="2.1 params 同时支持传入列表，达到一个变量赋两个值的效果"></a>2.1 params 同时支持传入列表，达到一个变量赋两个值的效果</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">payload = &#123;<span class="string">'key1'</span>: <span class="string">'value1'</span>, <span class="string">'key2'</span>: [<span class="string">'value2'</span>, <span class="string">'value3'</span>]&#125;</span><br><span class="line"></span><br><span class="line">r = requests.get(<span class="string">'http://httpbin.org/get'</span>, params=payload)</span><br><span class="line"></span><br><span class="line">print(r.url)</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出 ： http://httpbin.org/get?key1=value1&amp;key2=value2&amp;key2=value3</span></span><br></pre></td></tr></table></figure><h2 id="3-发送Post请求，使用data参数传输数据"><a href="#3-发送Post请求，使用data参数传输数据" class="headerlink" title="3 发送Post请求，使用data参数传输数据"></a>3 发送Post请求，使用data参数传输数据</h2><h3 id="3-1-直接传输字典类型到data参数，会自动编码为表单形式发送"><a href="#3-1-直接传输字典类型到data参数，会自动编码为表单形式发送" class="headerlink" title="3.1 直接传输字典类型到data参数，会自动编码为表单形式发送"></a>3.1 直接传输字典类型到data参数，会自动编码为表单形式发送</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">'http://httpbin.org/post'</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">'user'</span>: <span class="string">'abc123'</span>,</span><br><span class="line">    <span class="string">'pass'</span>: <span class="string">'admin'</span></span><br><span class="line">&#125;</span><br><span class="line">response = requests.post(url, data=data) </span><br><span class="line">print(response.text)</span><br></pre></td></tr></table></figure><h3 id="3-2-通过json参数传递json数据到服务器，Requests库会自动编码，这是新特性-如果还是依靠data参数传递json数据，则需要使用json模块进行数据编码再传递给data参数，复杂了一点，不推荐了吧"><a href="#3-2-通过json参数传递json数据到服务器，Requests库会自动编码，这是新特性-如果还是依靠data参数传递json数据，则需要使用json模块进行数据编码再传递给data参数，复杂了一点，不推荐了吧" class="headerlink" title="3.2 通过json参数传递json数据到服务器，Requests库会自动编码，这是新特性,如果还是依靠data参数传递json数据，则需要使用json模块进行数据编码再传递给data参数，复杂了一点，不推荐了吧"></a>3.2 通过json参数传递json数据到服务器，Requests库会自动编码，这是新特性,如果还是依靠data参数传递json数据，则需要使用json模块进行数据编码再传递给data参数，复杂了一点，不推荐了吧</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">'https://api.github.com/some/endpoint'</span></span><br><span class="line">payload = &#123;<span class="string">'some'</span>: <span class="string">'data'</span>&#125;</span><br><span class="line">r = requests.post(url, json=payload)<span class="comment">##传递json数据给json参数</span></span><br></pre></td></tr></table></figure><h2 id="4-Request库发送get或者post请求后会得到一个response对象，这个对象包含了很多有用的属性"><a href="#4-Request库发送get或者post请求后会得到一个response对象，这个对象包含了很多有用的属性" class="headerlink" title="4 Request库发送get或者post请求后会得到一个response对象，这个对象包含了很多有用的属性"></a>4 Request库发送get或者post请求后会得到一个response对象，这个对象包含了很多有用的属性</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">"http://httpbin.org/post"</span></span><br><span class="line"></span><br><span class="line">data = &#123;<span class="string">'user'</span>:<span class="string">'abc123'</span>,<span class="string">'passwd'</span>:<span class="string">'admin123'</span>&#125;</span><br><span class="line"></span><br><span class="line">r = request.post(url,data=data)</span><br><span class="line"></span><br><span class="line">print(r.text) <span class="comment"># 返回请求的文本字符串</span></span><br><span class="line">print(r.headers) <span class="comment"># 返回请求头</span></span><br><span class="line">print(r.cookies) <span class="comment"># 返回cookies</span></span><br><span class="line">print(r.status_code) <span class="comment"># 返回请求的状态码</span></span><br></pre></td></tr></table></figure><h2 id="5-Session机制：requests库如何保持session，详细参考下面的官方代码示例"><a href="#5-Session机制：requests库如何保持session，详细参考下面的官方代码示例" class="headerlink" title="5 Session机制：requests库如何保持session，详细参考下面的官方代码示例"></a>5 Session机制：requests库如何保持session，详细参考下面的官方代码示例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s = requests.Session() <span class="comment"># 生成一个session对象</span></span><br><span class="line"></span><br><span class="line">s.get(<span class="string">'http://httpbin.org/cookies/set/sessioncookie/123456789'</span>) <span class="comment"># 有示例网站取得sessioncookie</span></span><br><span class="line"></span><br><span class="line">r = s.get(<span class="string">"http://httpbin.org/cookies"</span>) <span class="comment"># 再次发送请求到示例网站，示例网站会返回你的cookie</span></span><br><span class="line"></span><br><span class="line">print(r.text) <span class="comment">#由此回复证明第二次请求也带上了sessioncookie</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出：'&#123;"cookies": &#123;"sessioncookie": "123456789"&#125;&#125;'</span></span><br></pre></td></tr></table></figure><p>不过需要注意，就算使用了会话，方法级别的参数也不会被跨请求保持。下面的例子只会和第一个请求发送 cookie ，而非第二个：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s = requests.Session()</span><br><span class="line"></span><br><span class="line">r = s.get(<span class="string">'http://httpbin.org/cookies'</span>, cookies=&#123;<span class="string">'from-my'</span>: <span class="string">'browser'</span>&#125;) <span class="comment">#使用了方法级别的参数cookies</span></span><br><span class="line">print(r.text)</span><br><span class="line"><span class="comment"># '&#123;"cookies": &#123;"from-my": "browser"&#125;&#125;'</span></span><br><span class="line"></span><br><span class="line">r = s.get(<span class="string">'http://httpbin.org/cookies'</span>) <span class="comment">#第二次请求cookies方法设置的请求消失了</span></span><br><span class="line">print(r.text)</span><br><span class="line"><span class="comment"># '&#123;"cookies": &#123;&#125;&#125;'</span></span><br></pre></td></tr></table></figure><h2 id="6-会话也可用来为请求方法提供缺省数据。这是通过为会话对象的属性提供数据来实现的："><a href="#6-会话也可用来为请求方法提供缺省数据。这是通过为会话对象的属性提供数据来实现的：" class="headerlink" title="6 会话也可用来为请求方法提供缺省数据。这是通过为会话对象的属性提供数据来实现的："></a>6 会话也可用来为请求方法提供缺省数据。这是通过为会话对象的属性提供数据来实现的：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s = requests.Session()</span><br><span class="line">s.auth = (<span class="string">'user'</span>, <span class="string">'pass'</span>) <span class="comment">#提供缺省数据</span></span><br><span class="line">s.headers.update(&#123;<span class="string">'x-test'</span>: <span class="string">'true'</span>&#125;) <span class="comment">#提供缺省数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># both 'x-test' and 'x-test2' are sent</span></span><br><span class="line">r=s.get(<span class="string">'http://httpbin.org/headers'</span>, headers=&#123;<span class="string">'x-test2'</span>: <span class="string">'true'</span>&#125;) <span class="comment">#headers是方法参数</span></span><br><span class="line">print(r.text)</span><br></pre></td></tr></table></figure><h2 id="7-编码问题"><a href="#7-编码问题" class="headerlink" title="7 编码问题"></a>7 编码问题</h2><p>当你收到一个响应时，Requests 会猜测响应的编码方式，用于在你调用 Response.text 方法时对响应进行解码。Requests 首先在 HTTP 头部检测是否存在指定的编码方式，如果不存在，则会使用 charade 来尝试猜测编码方式。</p><h2 id="8-认证问题"><a href="#8-认证问题" class="headerlink" title="8 认证问题"></a>8 认证问题</h2><p>Ref ：<a href="http://requests-oauthlib.readthedocs.io/en/latest/oauth2_workflow.html#introduction" target="_blank" rel="noopener">http://requests-oauthlib.readthedocs.io/en/latest/oauth2_workflow.html#introduction</a></p><h2 id="9-相关中文参考文档"><a href="#9-相关中文参考文档" class="headerlink" title="9 相关中文参考文档"></a>9 相关中文参考文档</h2><p><a href="http://docs.python-requests.org/zh_CN/latest/index.html" target="_blank" rel="noopener">http://docs.python-requests.org/zh_CN/latest/index.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Requests-库的基本用法&quot;&gt;&lt;a href=&quot;#Requests-库的基本用法&quot; class=&quot;headerlink&quot; title=&quot;Requests 库的基本用法&quot;&gt;&lt;/a&gt;Requests 库的基本用法&lt;/h1&gt;&lt;h2 id=&quot;1-基本发送GET请求&quot;&gt;
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python BS4学习笔记</title>
    <link href="http://yoursite.com/2018/01/23/Python-BS4%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/01/23/Python-BS4学习笔记/</id>
    <published>2018-01-23T14:49:17.000Z</published>
    <updated>2018-01-23T06:52:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BS4库的基本用法"><a href="#BS4库的基本用法" class="headerlink" title="BS4库的基本用法"></a>BS4库的基本用法</h1><h2 id="1-简介-四大对象"><a href="#1-简介-四大对象" class="headerlink" title="1 简介,四大对象"></a>1 简介,四大对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BeautifulSoup 就是 Python 的一个 HTML 或 XML 的解析库，我们可以用它来方便地从网页中提取数据，</span><br><span class="line"></span><br><span class="line">BeautifulSoup 在解析的时候实际上是依赖于解析器的，它除了支持 Python 标准库中的 HTML 解析器，还支持一些第三方的解析器比如 LXML,日常中推荐LXML ，这个解析器有解析 HTML 和 XML 的功能，而且速度快，容错能力强，所以推荐使用这个解析器来进行解析。</span><br><span class="line"></span><br><span class="line">BeautifulSoup将复杂的HTML文档装换成一个复杂的树形结构，每个节点都是python对象，可归纳为四种：Tag、Navigablestring、Comment、BeautifulSoup.</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">soupobj=BeautifulSoup(html,<span class="string">'lxml'</span>)</span><br><span class="line">print(type(soupobj)) </span><br><span class="line">print(type(soupobj.a))</span><br><span class="line">print(type(soupobj.p.string))</span><br><span class="line"></span><br><span class="line"><span class="comment">#output</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">bs4</span>.<span class="title">BeautifulSoup</span>'&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">bs4</span>.<span class="title">element</span>.<span class="title">Tag</span>'&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">bs4</span>.<span class="title">element</span>.<span class="title">NavigableString</span>'&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-BeautifulSoup四大对象之Tag对象：html中的一个个标签，html标签加上里面的内容就是Tag。"><a href="#2-BeautifulSoup四大对象之Tag对象：html中的一个个标签，html标签加上里面的内容就是Tag。" class="headerlink" title="2 BeautifulSoup四大对象之Tag对象：html中的一个个标签，html标签加上里面的内容就是Tag。"></a>2 BeautifulSoup四大对象之Tag对象：html中的一个个标签，html标签加上里面的内容就是Tag。</h2><ol><li>可以利用soup_obj加标签名获取这些标签内容，但它只返回所有内容中的第一个符合要求的标签。</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">soupobj=BeautifulSoup(html,<span class="string">'lxml'</span>)</span><br><span class="line">print(soupobj.head)</span><br><span class="line">print(soupobj.head.title) <span class="comment">#直接输出节点里面的内容，包括节点本身</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#output</span></span><br><span class="line">&lt;head&gt;&lt;title&gt;The HTML is for test BeautifulSoup&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;title&gt;The HTML is for test BeautifulSoup&lt;/title&gt;</span><br></pre></td></tr></table></figure><ol><li>Tag的两个重要属性name和attrs</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">soupobj=BeautifulSoup(html,<span class="string">'lxml'</span>)</span><br><span class="line">print(soupobj.a.name)</span><br><span class="line">print(soupobj.a.attrs) <span class="comment">#返回字典</span></span><br><span class="line">print(soupobj.a.attrs[<span class="string">'class'</span>])<span class="comment">#几种访问具体属性的方法</span></span><br><span class="line">print(soupobj.a[<span class="string">'class'</span>])</span><br><span class="line">print(soupobj.a.get(<span class="string">'class'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#output</span></span><br><span class="line">a</span><br><span class="line">&#123;<span class="string">'id'</span>: <span class="string">'link1'</span>, <span class="string">'href'</span>: <span class="string">'http://www.baidu.com'</span>, <span class="string">'class'</span>: [<span class="string">'sister'</span>]&#125;</span><br><span class="line">[<span class="string">'sister'</span>]</span><br><span class="line">[<span class="string">'sister'</span>]</span><br><span class="line">[<span class="string">'sister'</span>]</span><br></pre></td></tr></table></figure><h2 id="3-NavigableString对象"><a href="#3-NavigableString对象" class="headerlink" title="3 NavigableString对象"></a>3 NavigableString对象</h2><p>已经得到了标签，如何获得标签内的文字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">soupobj=BeautifulSoup(html,<span class="string">'lxml'</span>)</span><br><span class="line">print(soupobj.p.string)</span><br><span class="line">print(soupobj.p.get_text()) <span class="comment">#两种方法访问节点的字符串</span></span><br><span class="line">print(type(soupobj.p.string))</span><br><span class="line"><span class="comment">#output:</span></span><br><span class="line">this <span class="keyword">is</span> title</span><br><span class="line">this <span class="keyword">is</span> title</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">bs4</span>.<span class="title">element</span>.<span class="title">NavigableString</span>'&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-Comment对象-比较少用"><a href="#4-Comment对象-比较少用" class="headerlink" title="4 Comment对象,比较少用"></a>4 Comment对象,比较少用</h2><p>Tag , NavigableString , BeautifulSoup 几乎覆盖了html和xml中的所有内容,<br>但是还有一些特殊对象.容易让人担心的内容是文档的注释部分,Comment 对象是一个特殊类型的 NavigableString 对象:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">markup = <span class="string">"&lt;b&gt;&lt;!--Hey, buddy. Want to buy a used parser?--&gt;&lt;/b&gt;"</span></span><br><span class="line">soup = BeautifulSoup(markup,<span class="string">'lxml'</span>)</span><br><span class="line">comment = soup.b.string</span><br><span class="line">print(comment)</span><br><span class="line">print(type(comment))</span><br><span class="line"></span><br><span class="line"><span class="comment">#output</span></span><br><span class="line">Hey, buddy. Want to buy a used parser?</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">bs4</span>.<span class="title">element</span>.<span class="title">Comment</span>'&gt;</span></span><br></pre></td></tr></table></figure><h2 id="5-BeautifulSoup对象"><a href="#5-BeautifulSoup对象" class="headerlink" title="5 BeautifulSoup对象"></a>5 BeautifulSoup对象</h2><p>BeautifulSoup 对象表示的是一个文档的全部内容.大部分时候,可以把它当作 Tag 对象,它支持 遍历文档树 和 搜索文档树 中描述的大部分的方法.</p><p>因为 BeautifulSoup 对象并不是真正的HTML或XML的tag,所以它没有name和attribute属性.但有时查看它的 .name 属性是很方便的,所以 BeautifulSoup 对象包含了一个值为 “[document]” 的特殊属性 .name</p><h2 id="6-遍历文档树"><a href="#6-遍历文档树" class="headerlink" title="6 遍历文档树"></a>6 遍历文档树</h2><ol><li>理解子节点</li></ol><p>一个Tag可能包含多个字符串或其它的Tag,这些都是这个Tag的子节点.Beautiful Soup提供了许多操作和遍历子节点的属性.</p><p>注意: Beautiful Soup中字符串节点不支持这些属性,因为字符串没有子节点</p><ol><li>.contents 和 .children</li></ol><ul><li>tag的 .contents 属性可以将tag的子节点以列表的方式输出:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">soupobj=BeautifulSoup(html,<span class="string">'lxml'</span>)</span><br><span class="line"></span><br><span class="line">print(soupobj.body.contents) <span class="comment">#tag的 .contents 属性可以将tag的子节点以列表的方式输出:</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> soupobj.body.contents:</span><br><span class="line">    print(i.name)<span class="comment">#输出直接子节点,内嵌在子节点里面的节点不输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#output</span></span><br><span class="line"><span class="keyword">None</span></span><br><span class="line">p</span><br><span class="line"><span class="keyword">None</span></span><br><span class="line">p</span><br><span class="line"><span class="keyword">None</span></span><br><span class="line">p</span><br><span class="line"><span class="keyword">None</span></span><br></pre></td></tr></table></figure><ul><li>.children属性返回一个子节点的列表迭代器</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">soupobj=BeautifulSoup(html,<span class="string">'lxml'</span>)</span><br><span class="line">i=soupobj.body.children <span class="comment">#返回一个子节点的列表迭代器</span></span><br><span class="line">print(i)</span><br><span class="line"><span class="keyword">for</span> elem <span class="keyword">in</span> i:</span><br><span class="line">    print(elem.name)</span><br><span class="line"></span><br><span class="line"><span class="comment">#output:</span></span><br><span class="line">&lt;list_iterator object at <span class="number">0x101a88160</span>&gt;</span><br><span class="line"><span class="keyword">None</span></span><br><span class="line">p</span><br><span class="line"><span class="keyword">None</span></span><br><span class="line">p</span><br><span class="line"><span class="keyword">None</span></span><br><span class="line">p</span><br><span class="line"><span class="keyword">None</span></span><br></pre></td></tr></table></figure><ul><li>.contents 和 .children 属性仅包含tag的直接子节点.例如,<head>标签只有一个直接子节点<title></title></head></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">soupobj=BeautifulSoup(html,<span class="string">'lxml'</span>)</span><br><span class="line">i=soupobj.body.descendants <span class="comment">#返回一个子孙节点的生成器</span></span><br><span class="line">print(i)</span><br><span class="line"><span class="keyword">for</span> elem <span class="keyword">in</span> i:</span><br><span class="line">    print(elem.name)</span><br><span class="line"></span><br><span class="line"><span class="comment">#output</span></span><br><span class="line"></span><br><span class="line">&lt;generator object descendants at <span class="number">0x1041de728</span>&gt;</span><br><span class="line"><span class="keyword">None</span></span><br><span class="line">p</span><br><span class="line">b</span><br><span class="line"><span class="keyword">None</span></span><br><span class="line"><span class="keyword">None</span></span><br><span class="line">p</span><br><span class="line"><span class="keyword">None</span></span><br><span class="line">a</span><br><span class="line"><span class="keyword">None</span></span><br><span class="line"><span class="keyword">None</span></span><br><span class="line">a</span><br><span class="line"><span class="keyword">None</span></span><br><span class="line"><span class="keyword">None</span></span><br><span class="line"><span class="keyword">None</span></span><br><span class="line">p</span><br><span class="line"><span class="keyword">None</span></span><br><span class="line"><span class="keyword">None</span></span><br></pre></td></tr></table></figure><ul><li>兄弟节点的 .next_sibling, .previous_sibling属性,全部兄弟节点的.next_siblings, .previous_siblings属性</li></ul><h2 id="7-搜索文档树"><a href="#7-搜索文档树" class="headerlink" title="7 搜索文档树"></a>7 搜索文档树</h2><ol><li>find_all(name,attrs,recursive,text,limit,**kwargs)方法</li></ol><p>搜索当前tag的所有tag子节点，并判断是否符合过滤器条件。</p><ul><li>name参数：可以查找所有名字为name的tag，字符串对象会被自动忽略掉,函数返回一个list,name参数可以是字符串，正则，列表，True，<br>还可以传方法等</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">soupobj=BeautifulSoup(html,<span class="string">'lxml'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> soupobj.find_all(re.compile(<span class="string">'e'</span>)):<span class="comment">#传入正则，调用search()方法</span></span><br><span class="line">    print(i.name)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> soupobj.find_all([<span class="string">'a'</span>,<span class="string">'b'</span>]):<span class="comment">#传入列表</span></span><br><span class="line">    print(i.name)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> soupobj.find_all(<span class="string">'title'</span>):<span class="comment">#传入字符串</span></span><br><span class="line">    print(i.name)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> soupobj.find_all(<span class="keyword">True</span>):<span class="comment">#传入TRUE</span></span><br><span class="line">    print(i.name)</span><br><span class="line"></span><br><span class="line"><span class="comment">#output:</span></span><br><span class="line">body</span><br><span class="line">b</span><br></pre></td></tr></table></figure><ol><li>**kwargs参数：关键字参数，如果一个关键字参数不是搜索内置的参数名,搜索时会把该参数当作tag的属性来搜索,如果包含一个名字为 id 的参数,Beautiful Soup会搜索每个tag的”id”属性.</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> soupobj.find_all(id=<span class="string">'link2'</span>): <span class="comment">#传入关键字参数，函数会搜索id属性等于link2的tag</span></span><br><span class="line">    print(i.name)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> soupobj.find_all(href=re.compile(<span class="string">'baidu'</span>),id=<span class="string">'link2'</span>):<span class="comment">#使用关键字参数过滤多个属性：href,id</span></span><br><span class="line">    print(i.name)</span><br><span class="line"><span class="comment">#output</span></span><br><span class="line">a</span><br><span class="line">a</span><br></pre></td></tr></table></figure><ol><li>按CSS搜索（其实是继续使用关键字参数），可以通过 class<em> 参数搜索有指定CSS类名的tag,class</em> 参数同样接受不同类型的 过滤器 ,字符串,正则表达式,方法或 True</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> soupobj.find_all(class_=<span class="string">'story'</span>): <span class="comment">#单一使用'class_'属性查询</span></span><br><span class="line">    print(i.name)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> soupobj.find_all(href=re.compile(<span class="string">'baidu'</span>),class_=<span class="string">'sister'</span>): <span class="comment">#联合多条件查询</span></span><br><span class="line">    print(i.name)</span><br></pre></td></tr></table></figure><ol><li>通过 text 参数可以搜搜文档中的字符串内容.与 name 参数的可选值一样, text 参数接受 字符串 , 正则表达式 , 列表, True . 看例子:</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(soupobj.find_all(text=re.compile(<span class="string">'this'</span>)))<span class="comment">#感觉用正则作为参数值效果最好</span></span><br><span class="line"><span class="comment">#output</span></span><br><span class="line">[<span class="string">'this is title'</span>, <span class="string">'this is the content\n\n'</span>, <span class="string">'this is herf to link baidu'</span>]</span><br></pre></td></tr></table></figure><ol><li><p>其余的参数包括limit,recursive,limit的作用是限制搜索结果的数目，recursive参数，调用tag的 find_all() 方法时,Beautiful Soup会检索当前tag的所有子孙节点,如果只想搜索tag的直接子节点,可以使用参数 recursive=False .</p></li><li><p>find_all()方法的简写：BeautifulSoup 对象和 tag 对象可以被当作一个方法来使用,这个方法的执行结果与调用这个对象的 find_all() 方法相同,下面两行代码是等价的:</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">oup.find_all(<span class="string">"a"</span>)</span><br><span class="line">soup(<span class="string">"a"</span>) <span class="comment">#通过Beautifulsoup对象直接调用find_all</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">soup.title.find_all(text=<span class="keyword">True</span>)<span class="comment">#通过tag对象直接调用</span></span><br><span class="line">soup.title(text=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p>7.CSS选择器语法来查找Tag，soup.select()，返回类型是 list，用 get_text() 方法来获取它的内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> soup.select(<span class="string">'title'</span>)<span class="comment">#标签名查找</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> soup.select(<span class="string">'.sister'</span>)<span class="comment">#class名查找</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> soup.select(<span class="string">'#link1'</span>)<span class="comment">#id名查找</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> soup.select(<span class="string">"head &gt; title"</span>)<span class="comment">#直接子标签查找</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> soup.select(<span class="string">"#subject_list &gt; ul &gt; li &gt; div.info &gt; div.pub"</span>)  <span class="comment">#抓取作者，出版社信息，稍后我们用spite()</span></span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line"></span><br><span class="line"><span class="string">'nth-of-child'</span> <span class="keyword">is</span> simply <span class="keyword">not</span> implemented <span class="keyword">in</span> beautifulsoup4 (at time of writing), </span><br><span class="line"></span><br><span class="line"><span class="comment">#app &gt; div &gt; div &gt; div.main &gt; dl &gt; dd:nth-child(1) &gt; div &gt; div &gt; div.movie-item-info &gt; p.name &gt; a</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;BS4库的基本用法&quot;&gt;&lt;a href=&quot;#BS4库的基本用法&quot; class=&quot;headerlink&quot; title=&quot;BS4库的基本用法&quot;&gt;&lt;/a&gt;BS4库的基本用法&lt;/h1&gt;&lt;h2 id=&quot;1-简介-四大对象&quot;&gt;&lt;a href=&quot;#1-简介-四大对象&quot; class
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python编码问题学习笔记</title>
    <link href="http://yoursite.com/2018/01/23/Python%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/01/23/Python编码问题学习笔记/</id>
    <published>2018-01-23T14:32:06.000Z</published>
    <updated>2018-01-23T06:38:51.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-现在计算机系统通用的字符编码工作方式："><a href="#1-现在计算机系统通用的字符编码工作方式：" class="headerlink" title="1 现在计算机系统通用的字符编码工作方式："></a>1 现在计算机系统通用的字符编码工作方式：</h2><p>在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。python语言有两种不同的字符串，一个用于存储文本，一个用于存储原始字节。文本字符串(str)内部使用Unicode存储，字节字符串(byte)存储原始字节并显示ASCI</p><h2 id="2-Python3中的​encode和decode"><a href="#2-Python3中的​encode和decode" class="headerlink" title="2 Python3中的​encode和decode"></a>2 Python3中的​encode和decode</h2><p>Python3中字符编码经常会使用到decode和encode函数。特别是在抓取网页中，这两个函数用的熟练非常有好处。我的理解，encode的作用，使我们看到的直观的字符转换成计算机内的字节形式。decode刚好相反，把字节形式的字符转换成我们看的懂的、直观的、“人模人样”的形式</p><h2 id="3-如何查看str在内存中的unicode码"><a href="#3-如何查看str在内存中的unicode码" class="headerlink" title="3 如何查看str在内存中的unicode码"></a>3 如何查看str在内存中的unicode码</h2><p>字符在计算机的内存中统一是以Unicode编码的。只有在字符要被写进文件、存进硬盘或者从服务器发送至客户端（例如网页前端的代码）时会变成utf-8。如何把字符以Unicode的字节形式表现出来，露出它在内存中的庐山正面目？这里有个照妖镜：</p><p>xxxx.encode/decode(‘unicode-escape’),</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s=<span class="string">"中文"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.encode(<span class="string">'unicode-escape'</span>) <span class="comment"># 通过encode得到了“中文”的unicode字节码</span></span><br><span class="line"><span class="string">b'\\u4e2d\\u6587'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=<span class="string">"\u4e2d"</span> <span class="comment"># 把“中”的unicode码赋值给b，注意b是str，这就是str在内存的真实面目了</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(b)</span><br><span class="line">中</span><br></pre></td></tr></table></figure><h2 id="4-unicode码在python里有两种表示方式："><a href="#4-unicode码在python里有两种表示方式：" class="headerlink" title="4 unicode码在python里有两种表示方式："></a>4 unicode码在python里有两种表示方式：</h2><p>u’字符串’或者’\u四位十六进制数’。它们是等价的，而且都是str对象。注意，’\u四位十六进制数’与’\u四位十六进制数’并不相等，’\u四位十六进制数’=’\’（斜杠本身是转义字符要经过转义表示）+’u四位十六进制数’。</p><p>Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式,它定义了Unicode符号集的二进制代码如何保存，具体的保存方式参考下面的链接：</p><p>[参考链接][<a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html</a>]</p><h2 id="5-import-chardet-这个模块可以帮助检测当前的字节流编码"><a href="#5-import-chardet-这个模块可以帮助检测当前的字节流编码" class="headerlink" title="5 import chardet 这个模块可以帮助检测当前的字节流编码"></a>5 import chardet 这个模块可以帮助检测当前的字节流编码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s=<span class="string">'abc'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.encode()</span><br><span class="line"><span class="string">b'abc'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>chardet.detect(s.encode())</span><br><span class="line">&#123;<span class="string">'encoding'</span>: <span class="string">'ascii'</span>, <span class="string">'language'</span>: <span class="string">''</span>, <span class="string">'confidence'</span>: <span class="number">1.0</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s=<span class="string">'中文'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>chardet.detect(s.encode())</span><br><span class="line">&#123;<span class="string">'encoding'</span>: <span class="string">'utf-8'</span>, <span class="string">'language'</span>: <span class="string">''</span>, <span class="string">'confidence'</span>: <span class="number">0.7525</span>&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-现在计算机系统通用的字符编码工作方式：&quot;&gt;&lt;a href=&quot;#1-现在计算机系统通用的字符编码工作方式：&quot; class=&quot;headerlink&quot; title=&quot;1 现在计算机系统通用的字符编码工作方式：&quot;&gt;&lt;/a&gt;1 现在计算机系统通用的字符编码工作方式：&lt;/
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Clickjacking test method</title>
    <link href="http://yoursite.com/2017/09/02/Clickjacking-test-method/"/>
    <id>http://yoursite.com/2017/09/02/Clickjacking-test-method/</id>
    <published>2017-09-01T16:48:19.000Z</published>
    <updated>2017-09-01T08:51:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="how-to-test-the-clickjacking-POC-gen"><a href="#how-to-test-the-clickjacking-POC-gen" class="headerlink" title="how to test the clickjacking (POC gen)"></a>how to test the clickjacking (POC gen)</h1><p>burp有一个功能能够生成POC</p><ol><li>生成js文件</li><li>直接在web console复制执行</li><li>目标页面嵌入了其中</li></ol><h1 id="Ref-link"><a href="#Ref-link" class="headerlink" title="Ref link"></a>Ref link</h1><p><a href="https://support.portswigger.net/customer/en/portal/articles/2363105-using-burp-to-find-clickjacking-vulnerabilities" target="_blank" rel="noopener">https://support.portswigger.net/customer/en/portal/articles/2363105-using-burp-to-find-clickjacking-vulnerabilities</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;how-to-test-the-clickjacking-POC-gen&quot;&gt;&lt;a href=&quot;#how-to-test-the-clickjacking-POC-gen&quot; class=&quot;headerlink&quot; title=&quot;how to test the clic
      
    
    </summary>
    
    
      <category term="Web security" scheme="http://yoursite.com/tags/Web-security/"/>
    
  </entry>
  
  <entry>
    <title>Pyenv &amp; virtualenv</title>
    <link href="http://yoursite.com/2017/06/23/pyenv-virtualenv/"/>
    <id>http://yoursite.com/2017/06/23/pyenv-virtualenv/</id>
    <published>2017-06-23T14:41:14.000Z</published>
    <updated>2018-01-23T06:39:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Pyenv"><a href="#Pyenv" class="headerlink" title="Pyenv"></a>Pyenv</h1><ul><li><p>pyenv 是针对 python 版本的管理，通过修改环境变量的方式实现；</p></li><li><p>pyenv 原理</p></li></ul><p>pyenv 的美好之处在于，它并没有使用将不同的 $PATH 植入不同的 shell 这种高耦合的工作方式，而是简单地在 $PATH 的最前面插入了一个垫片路径（shims）：~/.pyenv/shims:/usr/local/bin:/usr/bin:/bin。所有对 Python 可执行文件的查找都会首先被这个 shims 路径截获，从而架空了后面的系统路径。</p><p>作者原文如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Understanding Shims</span><br><span class="line"></span><br><span class="line">pyenv works by inserting a directory of shims at the front of your PATH:</span><br><span class="line"></span><br><span class="line">$(pyenv root)/shims:/usr/local/bin:/usr/bin:/bin</span><br><span class="line">Through a process called rehashing, pyenv maintains shims <span class="keyword">in</span> that directory to match every Python command across every installed version of Python—python, pip, <span class="keyword">and</span> so on.</span><br><span class="line"></span><br><span class="line">Shims are lightweight executables that simply <span class="keyword">pass</span> your command along to pyenv. So <span class="keyword">with</span> pyenv installed, when you run, say, pip, your operating system will do the following:</span><br><span class="line"></span><br><span class="line">Search your PATH <span class="keyword">for</span> an executable file named pip</span><br><span class="line">Find the pyenv shim named pip at the beginning of your PATH</span><br><span class="line">Run the shim named pip, which <span class="keyword">in</span> turn passes the command along to pyenv</span><br></pre></td></tr></table></figure><p><a href="https://github.com/pyenv/pyenv#how-it-works" target="_blank" rel="noopener">具体的下载和使用教程请点击我！！！</a><br><a href="http://python.jobbole.com/85587/" target="_blank" rel="noopener">具体的命令使用详解请点击我！！！</a></p><h2 id="python切换"><a href="#python切换" class="headerlink" title="python切换"></a>python切换</h2><ol><li><p>pyenv global 3.4.0 — 设置全局的 Python 版本，通过将版本号写入 ~/.pyenv/version 文件的方式。</p></li><li><p>pyenv local 2.7.3 — 设置面向程序的本地版本，通过将版本号写入当前目录下的 .python-version 文件的方式。通过这种方式设置的 Python 版本优先级较 global 高。</p></li></ol><p>pyenv 会从当前目录开始向上逐级查找 .python-version 文件，直到根目录为止。若找不到，就用 global 版本。<br>$ pyenv shell pypy-2.2.1 — 设置面向 shell 的 Python 版本，通过设置当前 shell 的 PYENV_VERSION<br>环境变量的方式。这个版本的优先级比 local 和 global 都要高。–unset 参数可以用于取消当前 shell 设定的版本。</p><ol><li><p>pyenv shell –unset</p></li><li><p>python优先级</p></li></ol><p>shell &gt; local &gt; global</p><h1 id="virtualenv"><a href="#virtualenv" class="headerlink" title="virtualenv"></a>virtualenv</h1><ul><li>virtualenv 用处</li></ul><p>处理python环境的多版本和模块依赖，以及相应的权限是一个很常见的问题。比如，你有个应用使用的是LibFoo V1.0，但另一个应用却要用到LibFoo V2.0。 如何处理呢？如果把所有模块都安装到 /usr/lib/python2.7/site-packages (或是你本机python默认的模块安装目录)，那你极有可能无意中升级一些不该升级的模块。</p><ul><li>在Pyenv中有相应插件：pyenv-virtualenv 或者使用virtualenvwrapper，这是 virtualenv 的扩展工具，提供了一系列命令行命令</li></ul><p>使用pyenv来管理python，使用 pyenv-virtualenv 插件来管理多版本 python包。</p><p><a href="http://virtualenv-chinese-docs.readthedocs.io/en/latest/#" target="_blank" rel="noopener">中文参考链接</a></p><h1 id="关于环境变量"><a href="#关于环境变量" class="headerlink" title="关于环境变量"></a>关于环境变量</h1><p>OS X系统的环境变量，加载顺序为：</p><p>/etc/profile<br>/etc/paths<br>~/.bash_profile<br>~/.bash_login<br>~/.profile<br>~/.bashrc<br>/etc/profile和/etc/paths是系统级别的，系统启动就会加载，<br>后面几个是当前用户级的环境变量。</p><p>~/.bash_profile，~/.bash_login，~/.profile按照从前往后的顺序读取，<br>如果~/.bash_profile文件存在，则后面的几个文件就会被忽略不读了，<br>如果~/.bash_profile文件不存在，才会以此类推读取后面的文件。</p><p>~/.bashrc没有上述规则，它是bash shell打开的时候载入的。</p><p>修改完后记得source一下让其快速生效</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Pyenv&quot;&gt;&lt;a href=&quot;#Pyenv&quot; class=&quot;headerlink&quot; title=&quot;Pyenv&quot;&gt;&lt;/a&gt;Pyenv&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;pyenv 是针对 python 版本的管理，通过修改环境变量的方式实现；&lt;/p&gt;
&lt;/li&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>iOS security testing</title>
    <link href="http://yoursite.com/2017/06/22/iOS-security-testing/"/>
    <id>http://yoursite.com/2017/06/22/iOS-security-testing/</id>
    <published>2017-06-21T17:52:25.000Z</published>
    <updated>2018-01-23T06:53:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Basics-of-iOS-and-application"><a href="#Basics-of-iOS-and-application" class="headerlink" title="Basics of iOS and application"></a>Basics of iOS and application</h1><h2 id="ios开发证书，描述文件，bundle-ID的关系"><a href="#ios开发证书，描述文件，bundle-ID的关系" class="headerlink" title="ios开发证书，描述文件，bundle ID的关系"></a>ios开发证书，描述文件，bundle ID的关系</h2><p><a href="http://www.jianshu.com/p/21ebca8cadf6" target="_blank" rel="noopener">refer link</a><br><a href="http://www.jianshu.com/p/6a6f4a574328" target="_blank" rel="noopener">refer link</a></p><h2 id="Some-key-features-of-the-iOS-security-model-are-as-follows"><a href="#Some-key-features-of-the-iOS-security-model-are-as-follows" class="headerlink" title="Some key features of the iOS security model are as follows:"></a>Some key features of the iOS security model are as follows:</h2><ul><li>Security architecture is layered as hardware level, OS level, and application level </li><li>Encryption right from hardware/firmware level</li><li>Application sandboxing <strong>Robust sandboxing features have been built by iOS that prevent the applications from accessing the data or files of other applications.</strong></li><li>Data protection using encryption </li><li>Code signing</li></ul><h2 id="iOS-secure-boot-chain"><a href="#iOS-secure-boot-chain" class="headerlink" title="iOS secure boot chain"></a>iOS secure boot chain</h2><ul><li>Boot ROM</li></ul><blockquote><p>This is implicitly trusted It is known as a hardware root of trust This code is contained in the processor and cannot be updated or changed This also contains the Apple root certificate with authentic public key and uses it to verify that the low-level boot loader is properly signed and has not been tampered before loading</p></blockquote><ul><li>Low-level boot loader</li></ul><blockquote><p>This is the lowest level of code that can be updated It also verifies the signatures of firmware of iBoot before loading it</p></blockquote><ul><li>iBoot</li></ul><blockquote><p>It verifies the signature of the iOS kernel before starting the kernel This secure boot chain also prevents any malwares that can affect at the boot level</p></blockquote><h2 id="iOS-application-signing"><a href="#iOS-application-signing" class="headerlink" title="iOS application signing"></a>iOS application signing</h2><p>The following is the overall process about how Apple publishes an iOS app on App Store:</p><ul><li>All applications running on iDevice are signed by Apple </li><li>The developer signs the apps and submits application to Apple Apple verifies it (performs some rudimentary checks, not vulnerability assessment of app) If app meets with Apple requirements, Apple signs the application </li><li>Finally the app is available on Apple App Store</li></ul><h2 id="Jailbreak"><a href="#Jailbreak" class="headerlink" title="Jailbreak"></a>Jailbreak</h2><p>Jailbreaking allows us to do the following:</p><ul><li>Access complete filesystem on iDevice </li><li>Install any app from outside App Store</li></ul><blockquote><p>With iOS 8.3, Apple has blocked each application’s sandbox directory. It means that you cannot access application files using widely used tools, such as iExplorer, iFunbox, and so on, even if the device is rooted. Cydia has introduced Apple File Conduit 2, which allows third-party tools to access application files</p></blockquote><h2 id="Some-tools-for-Jailbroken-Device"><a href="#Some-tools-for-Jailbroken-Device" class="headerlink" title="Some tools for Jailbroken Device"></a>Some tools for Jailbroken Device</h2><ul><li>Transferring files to iDevice : <strong>any SFTP client such as FileZilla or WinSCP on your PC/Mac</strong></li><li>Connecting to iDevice using VNC : <strong>You can connect to iDevice over VNC using tools such as Veency, which comes with Cydia.</strong></li><li>manually reverse-engineer the code from binary : <strong>class-dump-z</strong></li><li><strong>Cycript</strong>: It’s a command-line debugger, which we will require while conducting dynamic analysis of the app. You can install it from Cydia.</li><li>In our pentesting process, we will look at both, manual and automated, ways to exploit the vulnerabilities. The <strong>idb tool</strong> can help to automate many tasks.</li><li>install the third-party application using command line : AppSync, Installipa</li></ul><p><strong>You can find all the installed third-party applications under  /var/mobile/Containers/Data/Application directory</strong><br>Each application is assigned a universally unique identifier (UUID). You can find specific application files using simple search command or by looking into the iOS plist file.</p><h1 id="Test-methodology"><a href="#Test-methodology" class="headerlink" title="Test methodology"></a>Test methodology</h1><h2 id="Identifying-the-Flaws-in-Local-Storage"><a href="#Identifying-the-Flaws-in-Local-Storage" class="headerlink" title="Identifying the Flaws in Local Storage"></a>Identifying the Flaws in Local Storage</h2><ul><li>Insecure data in the plist files</li></ul><p>plist保存的地方</p><p>1，工程沙盒里（就是程序user Document文件夹下，以读取文件，写入文件方式）<br>2，工程自身里（就是在工程里手动创建一个如.plist文件，把固定的内容写入，这个需要人工手动写入）<br>3，工程沙盒里（保存到user Document下，不过不需要读写文件，用系统的 NSUserDefaults 可以快速保存添加读取删除基本数据类型，类似于android里的Sharedpreferences ）</p><p>plist是什么？</p><p>它全名是：Property List，属性列表文件，它是一种用来存储串行化后的对象的文件。属性列表文件的扩展名为.plist ，因此通常被称为<br>plist文件。文件是xml格式的。Plist文件通常用于储存用户设置，也可以用于存储捆绑的信息。</p><ul><li>Insecure storage in the NSUserDefaults class</li></ul><blockquote><p>As per the Apple documentation, NSUserDefaults is used for customization as per the user’s preferences. Many times, the developer uses the NSUderDefaults format to store sensitive information.</p></blockquote><ul><li>Insecure storage in SQLite database</li></ul><blockquote><p>You can make use of SQLCipher to encrypt the data that will make it impossible to view the contents unless you have the encryption key.</p></blockquote><ul><li>SQL injection in iOS applications</li></ul><blockquote><p>The developers should always perform escaping/sanitizing on the user input before proceeding for it. You can make use of parameterized queries that will prevent the SQL injection-like attacks</p></blockquote><ul><li>Insecure storage in Core Data</li></ul><blockquote><p>Core Data is an object-relational mapping (ORM) that creates a layer between user interface and database. The developers prefer Core Data as it is faster in terms of record creation than the traditional SQLite format.<br>From security point of view, these files are similar to SQLite, with the only difference being that the tables are prefixed with Z.</p><p>You may have noticed all tables starting with prefix Z and credentials are stored in plain text. You can check ZUSERNAME and ZPASSWORD column values.<br>Although Core Data is easy to use and fast, it should never be used to store sensitive information.</p></blockquote><ul><li>Insecure storage in keychain</li></ul><p>There are different conditions depending on which a developer can decide when a keychain item can be readable by an application. These various conditions are known as data protection accessibility constants that can be classified as:</p><p>kSecAttrAccessibleWhenUnlocked<br>kSecAttrAccessibleAfterFirstUnlock<br>kSecAttrAccessibleAlways<br>kSecAttrAccessibleWhenUnlockedThisDeviceOnly<br>kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly<br>kSecAttrAccessibleAlwaysThisDeviceOnly</p><p><a href="https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/01introduction/introduction.html" target="_blank" rel="noopener">Keychain refer link</a></p><blockquote><p>You can get keychain_dumper from GitHub and then use SFTP to copy files on Device. Once you copy the files, use the #./keychain_dumper command to dump the keychain data.</p></blockquote><p>As per preceding constants, the data is accessible when the device is in an unlocked condition or when it got first unlocked after reboot. Developers can also set constant to make the data accessible all the time.</p><p>Keychain is known to be a secure place and requires many prerequisites for an attack, such as iDevice should be rooted, unlocked, and so on, to view the contents.</p><p>Developers should also avoid storing sensitive information locally. You can store sensitive information on server side. If the information is required to be stored locally, use an encrypted format of database over plain-text formats.</p><h2 id="Traffic-Analysis-for-iOS-Application"><a href="#Traffic-Analysis-for-iOS-Application" class="headerlink" title="Traffic Analysis for iOS Application"></a>Traffic Analysis for iOS Application</h2><p>You can bypass SSL pinning by using tools such as SSL Kill Switch. However, note that this is available only for jailbroken devices. I would encourage you to go further and study from its wiki on how it helps in bypassing SSL verification.</p><h2 id="Sealing-up-Side-Channel-Data-Leakage"><a href="#Sealing-up-Side-Channel-Data-Leakage" class="headerlink" title="Sealing up Side Channel Data Leakage"></a>Sealing up Side Channel Data Leakage</h2><ul><li>Data leakage via application screenshot</li></ul><blockquote><p>One of the features of iOS is that it takes a screenshot of the application when it moves into the background. An attacker having physical access to the system can easily access this screenshot and view sensitive information contained in it.</p></blockquote><p>You can also automate this process using the idb tool.</p><ul><li>Pasteboard leaking sensitive information</li></ul><blockquote><p>use Cycript or Idb to find the sensitive data </p></blockquote><p>It’s recommended to use custom pasteboard for sensitive data of your application. You should always clear pasteboard when the application is going in the background.</p><ul><li>Device logs leaking application sensitive data</li></ul><blockquote><p>You can use the Organizer utility provided with Xcode. Connect the iDevice to Mac, start the Organizer and dump the device logs:</p><p>You can automate this process using the idb tool. Use the Log option to capture all device logs and check whether the iDevice is leaking any sensitive information:</p></blockquote><p>This issue arises when the developers forget to remove logs during the release of the application. So, make sure that you have not enabled logs after debug mode.</p><h2 id="Analyzing-iOS-Binary-Protections"><a href="#Analyzing-iOS-Binary-Protections" class="headerlink" title="Analyzing iOS Binary Protections"></a>Analyzing iOS Binary Protections</h2><ul><li>Decrypting unsigned iOS applications </li></ul><blockquote><p>We will first study how to decrypt unsigned applications, <strong>which means decrypting applications that are not downloaded from App Store.</strong> Let’s decrypt the apps provided with the book. These apps are not signed by Apple. In Chapter 2, Setting up Lab for iOS App Pentesting you have already installed <strong>class-dump-z</strong>, which is used for dumping code of iOS applications.</p></blockquote><ul><li>Decrypting signed iOS applications </li></ul><ol><li><p>select the app that you want to decrypt and provide a name to <strong>clutch</strong>; it will decrypt the app and show the location where it’s been decrypted:</p></li><li><p>Once the application is decrypted, you can use class-dump-z. Provide a decrypted IPA file to class-dump-z and it will show you the source code of the application:</p></li></ol><ul><li>Analyzing code by reverse engineering </li></ul><p>Hopper Disassembler<br>iGoat application </p><ul><li>Analyzing iOS binary </li></ul><blockquote><p>Along with reversing iOS apps and analyzing code, you can also perform analysis on binary to check whether it has implemented address space layout randomization (ASLR), and stack smashing protection.</p></blockquote><p>use Mobile Security Framework (MobSF) to try try </p><ul><li>Hardening binary against reverse engineering</li></ul><h2 id="The-iOS-App-Dynamic-Analysis"><a href="#The-iOS-App-Dynamic-Analysis" class="headerlink" title="The iOS App Dynamic Analysis"></a>The iOS App Dynamic Analysis</h2><ul><li>Understanding Objective-C runtime </li><li><p>Dynamic analysis using Cycript<br>The idea is to hook Cycript in the target application’s process ID and perform actions using JavaScript or Objective-C or both.</p></li><li><p>Dynamic analysis using Snoop-it </p></li><li>Dynamic analysis on iOS Simulator</li></ul><p><strong>How to prevent Ptrace</strong></p><blockquote><p>So, dynamic analysis is one of the most important aspects when it comes to iOS applications developed in Objective-C. An attacker can change the application’s behavior as per requirement.</p><p>Here, the problem is that the application allows debuggers to attach files. Application should crash if any debuggers try to attach it, which would prevent you from performing dynamic analysis for application. You can prevent debugging to some extent, at least for important methods that handle sensitive data.</p><p>You can make use of the ptrace function in order to prevent debuggers from getting attached to your application. I would encourage you to go through the ptrace function’s documentation provided by Apple at:</p></blockquote><p>[refer link]<a href="https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man2/ptrac" target="_blank" rel="noopener">https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man2/ptrac</a></p><blockquote><p>You can import the ptrace.h file and add the following code in the main function:</p><p>ifndef DEBUG ptrace(PT_DENY_ATTACH, 0, 0, 0); #endif</p><p>This function will prevent debuggers who trace an application while debugging from getting attached to it. There could be many ways to make it difficult for attacker to perform debugging. For sensitive application such as those in the financial sector, you can apply check whether the device is jailbroken; if it is, you can stop executing the application, which will not allow any debuggers to attach it. Developers can also make use of multiple techniques together in order to make it almost impossible to debug the sensitive part of the application.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Basics-of-iOS-and-application&quot;&gt;&lt;a href=&quot;#Basics-of-iOS-and-application&quot; class=&quot;headerlink&quot; title=&quot;Basics of iOS and application&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Android security testing</title>
    <link href="http://yoursite.com/2017/06/20/Andrid-Security-testing/"/>
    <id>http://yoursite.com/2017/06/20/Andrid-Security-testing/</id>
    <published>2017-06-19T23:16:36.000Z</published>
    <updated>2018-01-23T06:39:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="Android-基本机构"><a href="#Android-基本机构" class="headerlink" title="Android 基本机构"></a>Android 基本机构</h2><ul><li>安卓分4层吧，底层为linux，上层是安卓本地库，主要为C或者C++，有sqllite，webkit <strong>(The Webkit rendering engine was used prior to Android version 4.4 to load these web pages. On the latest versions (after 4.4) of Android, it is done using Chromium)</strong> 之类的东西，通过安卓应用程序框架展示为程序员，同时这一层还有安卓运行时，以核心java和Dalvik虚拟机，再上面就是应用程序与框架，程序员使用此框架API开发更加复杂的应用程序</li></ul><h2 id="Android-app-包结构"><a href="#Android-app-包结构" class="headerlink" title="Android app 包结构"></a>Android app 包结构</h2><ul><li>AndroidManifest.xml: </li></ul><blockquote><p>The AndroidManifest.xml file is the control file that tells the system what to do with all the top-level components (specifically activities, services, broadcast receivers, and content providers described below) in an application. This also specifies which permissions are required. This file may be in Android binary XML that can be converted into human-readable plaintext XML with tools such as android-apktool, or Androguard which we will cover in the upcoming post.</p></blockquote><ul><li><p>META-INF directory:</p><ul><li>MANIFEST.MF: the Manifest File</li><li>CERT.RSA: The certificate of the application.</li><li>CERT.SF: The list of resources and SHA-1 digest of the corresponding lines in the MANIFEST.MF file.</li></ul></li><li><p>lib: the directory containing the compiled code that is specific to a software layer of a processor, the directory is split into more directories within it:</p><ul><li>armeabi: compiled code for all ARM based processors only</li><li>armeabi-v7a: compiled code for all ARMv7 and above based processors only</li><li>x86: compiled code for X86</li><li>mips: compiled code for MIPS processors only</li></ul></li><li><p>res: the directory containing resources not compiled into resources.arsc (see below).</p></li><li><p>assets: a directory containing applications assets, which can be retrieved by AssetManager.</p></li><li><p>classes.dex: The classes compiled in the dex file format understandable by the Dalvik virtual machine</p></li><li><p>resources.arsc: a file containing precompiled resources, such as binary XML for example</p></li></ul><h2 id="How-to-root-or-install-a-custom-Rom-in-your-device"><a href="#How-to-root-or-install-a-custom-Rom-in-your-device" class="headerlink" title="How to root or install a custom Rom in your device:"></a>How to root or install a custom Rom in your device:</h2><ul><li>unlock bootloader </li><li>Installing recovery softwares like <strong>TWRP</strong> or CF</li><li>Installing the Super Su app.</li><li>Flashing the custom ROM to the phone.</li></ul><h2 id="What-happens-when-an-app-is-run"><a href="#What-happens-when-an-app-is-run" class="headerlink" title="What happens when an app is run?"></a>What happens when an app is run?</h2><p>When the Android Operating System boots, a process called <strong>Zygote</strong> is started and<br>it listens for new app launch requests. Whenever a user clicks on an application, Zygote is used to launch it. Zygote creates a copy of itself using a fork system call when it receives a request to launch a new app. This process of launching a new app is considered more ef cient and faster. The newly launched app process loads all the code that is required for it to run. What we read earlier is that the classes. dex  le contains all the byte code compatible with Dalvik Virtual Machine. In the latest version of Android devices starting from Android 5.0, the default runtime environment is ART. In this new runtime environment, the classes.dex  le will be converted into something called OAT using a tool called dex2oat.</p><h2 id="Sandbox"><a href="#Sandbox" class="headerlink" title="Sandbox"></a>Sandbox</h2><blockquote><p>In the traditional linux system, we are able to see both the processes under the same User ID.<br>Now, it’s not true in the case of Android app. Every single app installed on your device will have a separate User ID (UID). This ensures that each application and its resources are being sand-boxed and will not be accessible to any other application.<br>Note: Applications signed with the same key (it is possible if two apps are developed by the same developer), can access each other’s data.<br>If you notice the  le permissions in the preceding output, each application’s directory is owned by itself and they are not readable/writeable by other users.</p></blockquote><h2 id="SSL-certificate-pinning"><a href="#SSL-certificate-pinning" class="headerlink" title="SSL certificate pinning"></a>SSL certificate pinning</h2><ul><li><p>一些有用的参考：<br><a href="http://dieyidezui.com/talk-about-android-https/" target="_blank" rel="noopener">refer link</a><br><a href="http://www.jianshu.com/p/f725f63f8314" target="_blank" rel="noopener">refer link</a><br><a href="https://developer.android.com/reference/javax/net/ssl/HttpsURLConnection.html" target="_blank" rel="noopener">refer link</a><br><a href="https://developer.android.com/training/articles/security-ssl.html" target="_blank" rel="noopener">offical link</a></p></li><li><p>使用HttpURLConnection<br>首先，获取访问地址的URL对象；<br>然后，利用该url实例的openConnection()方法获取HttpURLConnection实例；<br>之后，利用HttpURLConnection实例，可以设置HTTP请求所使用的方法，主要有两种，GET和POST，分别是请求数据和提交数据；<br>之后，可以进行一些自由的设置，比如设置连接超时时间、请求超时时间等；<br>最后，调用getInputStream()方法即可获得服务器传输过来的输入流了。可以对该输入流进行读取。<br>读取完之后，需要关闭HTTP连接，调用disconnect()方法。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">String result = <span class="keyword">null</span>;</span><br><span class="line">HttpURLConnection urlConnection =<span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    URL requestedUrl = <span class="keyword">new</span> URL(url);</span><br><span class="line">    urlConnection = (HttpURLConnection)requestedUrl.openConnection();</span><br><span class="line">    <span class="keyword">if</span>(urlConnection <span class="keyword">instanceof</span> HttpsURLConnection) &#123;  </span><br><span class="line">        ((HttpsURLConnection)urlConnection).setSSLSocketFactory(sslContext.getSocketFactory());</span><br><span class="line">    &#125;</span><br><span class="line">    urlConnection.setRequestMethod(<span class="string">"GET"</span>);   </span><br><span class="line">    urlConnection.setConnectTimeout(<span class="number">1500</span>);</span><br><span class="line">    urlConnection.setReadTimeout(<span class="number">1500</span>);</span><br><span class="line">    lastResponseCode = urlConnection.getResponseCode();</span><br><span class="line">    result = IOUtil.readFully(urlConnection.getInputStream());</span><br><span class="line">    lastContentType = urlConnection.getContentType();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    result = ex.toString();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">    <span class="keyword">if</span> (urlConnection != <span class="keyword">null</span>) &#123;</span><br><span class="line">        urlConnection.disconnect();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>但我们的证书是自签名的,这意味着SSLContext中默认的TrustManager是不会信任服务端证书的,并且也无法达成SSL连接。<br>如果你尝试着在网络上搜索如何实现自信任证书的HTTPS连接,可能会得到很多错误的建议,绝大多数的答案都是教给开发者直接信任任何证书就可以了。这当然算是一个误导了,也是不安全的,因为这样做会有被中间人攻击[译注1]的风险。<br>我们真正想做的是创建一个自定义的TrustManager,这个TrustManager可以信任我们的自签名证书,并且能被我们的自定义SSLContext使用.因此我们需要一份服务端证书链的副本,这个副本必须包括CA的自签名证书,至少也是CA签署的中级证书。如果你正常地导出服务器的证书,你会得到一个文件,这个文件包含有三个证书- CA认证的证书,中级证书和服务器的证书。这是OK的,额外的证书不是必须的,但也不会有坏处</p></blockquote><ul><li>如何使用HttpsURLConnection</li></ul><p>我们把证书装载到KeyStore中,使用KeyStore来生成一个TrustManger的数组,然后使用这些TrustManager来创建SSLContext。</p><h1 id="Test-methodology"><a href="#Test-methodology" class="headerlink" title="Test methodology"></a>Test methodology</h1><h2 id="1-利用Qark，Mobsf等综合性扫描软件对APP进行一次全面扫描"><a href="#1-利用Qark，Mobsf等综合性扫描软件对APP进行一次全面扫描" class="headerlink" title="1 利用Qark，Mobsf等综合性扫描软件对APP进行一次全面扫描"></a>1 利用Qark，Mobsf等综合性扫描软件对APP进行一次全面扫描</h2><h2 id="2-利用Burp等工具分析应用数据，检查certificate-pinning和各种传输问题和服务器端问题，例如session，xss，injection，logic-flow等"><a href="#2-利用Burp等工具分析应用数据，检查certificate-pinning和各种传输问题和服务器端问题，例如session，xss，injection，logic-flow等" class="headerlink" title="2 利用Burp等工具分析应用数据，检查certificate pinning和各种传输问题和服务器端问题，例如session，xss，injection，logic flow等"></a>2 利用Burp等工具分析应用数据，检查certificate pinning和各种传输问题和服务器端问题，例如session，xss，injection，logic flow等</h2><p>With SSL pinning, it is assumed that the app knows which servers it communicates with. We take the SSL certificate of this server and add it to the application. Now the application doesn’t need to rely on the device’s trust store, rather it makes its own checks verifying if it is communicating with the server whose certificate is already stored inside this application（看机制，不一定存在本地，可能从远处下载）. This is how SSL pinning works.</p><h2 id="3-检查手机data-data目录各种存储数据，看看有没有敏感数据-再检查unintend数据泄露问题"><a href="#3-检查手机data-data目录各种存储数据，看看有没有敏感数据-再检查unintend数据泄露问题" class="headerlink" title="3 检查手机data/data目录各种存储数据，看看有没有敏感数据,再检查unintend数据泄露问题"></a>3 检查手机data/data目录各种存储数据，看看有没有敏感数据,再检查unintend数据泄露问题</h2><p>• Shared preferences<br>• SQLite databases<br>• Internal storage<br>• External storage</p><p>Example Scenarios for Unintended Data Leakage</p><p>Leaking content providers<br>Copy/paste buffer caching<br>Logging  adb logcat &gt; output.txt<br>URL caching<br>Browser cookie objects<br>Analytics data sent to third parties</p><h2 id="4-使用Drozer检查攻击面，重点查看四大组件各种export，进行各种扫描，检查有无注入，目录遍历等漏洞"><a href="#4-使用Drozer检查攻击面，重点查看四大组件各种export，进行各种扫描，检查有无注入，目录遍历等漏洞" class="headerlink" title="4 使用Drozer检查攻击面，重点查看四大组件各种export，进行各种扫描，检查有无注入，目录遍历等漏洞"></a>4 使用Drozer检查攻击面，重点查看四大组件各种export，进行各种扫描，检查有无注入，目录遍历等漏洞</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- Listing out all the modules : dz&gt; list</span><br><span class="line">- Retrieving package information : dz&gt; run app.package.list</span><br><span class="line">- Finding out the package name of your target application : dz&gt; run app.package.list --filter **notes**</span><br><span class="line">- Getting information about a package : dz&gt; run app.package.info -a **com.sonyericsson.notes**</span><br><span class="line">- Dumping the AndroidManifes.xml file : dz&gt; run app.package.manifest **com.sonyericsson.notes**</span><br><span class="line">- Finding out the attack surface : dz&gt; run app.package.attacksurface **com.sonyericsson.notes**</span><br><span class="line">                                   dz&gt; run app.package.attacksurface **org.owasp.goatdroid.fourgoats**</span><br><span class="line"></span><br><span class="line">- Attacks on activities :   dz&gt; run app.service.info -a org.owasp.goatdroid.fourgoats -u</span><br><span class="line">                            dz&gt; run app.activity.start --component org.owasp.goatdroid.fourgoats org.</span><br><span class="line">owasp.goatdroid.fourgoats.activities.ViewProfile  </span><br><span class="line"></span><br><span class="line">- Attacks on services : dz&gt; run app.service.info -a org.owasp.goatdroid.fourgoats</span><br><span class="line">                        dz&gt; run app.service.start --component org.owasp.goatdroid.fourgoats org.</span><br><span class="line">owasp.goatdroid.fourgoats.services.LocationService</span><br><span class="line"></span><br><span class="line">- Attacks on broadcast receivers : dz&gt; run app.broadcast.info -a org.owasp.goatdroid.fourgoats</span><br><span class="line">                                    </span><br><span class="line">- Running the following command will tell us if there are any injection vulnerabilities in the content providers:</span><br><span class="line">dz&gt; run scanner.provider.injection -a com.sonyericsson.notes</span><br><span class="line"></span><br><span class="line">- Path traversal attacks in content providers : dz&gt; run scanner.provider.traversal -a **com.adobe.reader**</span><br><span class="line">                                                dz&gt; run app.provider.read content://com.adobe.reader.fileprovider/../../../../etc/hosts</span><br></pre></td></tr></table></figure><h2 id="5-使用各种hook工具进行动态测试"><a href="#5-使用各种hook工具进行动态测试" class="headerlink" title="5 使用各种hook工具进行动态测试"></a>5 使用各种hook工具进行动态测试</h2><ul><li>Xposed</li><li>Cydia </li><li>Frida</li><li>Magisk v8 (systemless) 「解鎖 -&gt; 安裝 Magisk -&gt; 安裝 Systemless phh’s SuperUser -&gt; 安裝 Systemless Xposed -&gt; 重新上鎖」<br><strong>Frida 和 Xposed 都是非常出色的框架，后面会增加一些相关博文</strong></li></ul><h2 id="6-Root-Dectection-（systemless-root）"><a href="#6-Root-Dectection-（systemless-root）" class="headerlink" title="6 Root Dectection （systemless root）"></a>6 Root Dectection （systemless root）</h2><ul><li><p>可以使用xposed或者Magisk去bypass root checking</p></li><li><p>Superuser.apk is the most common package many apps look for in root detection. This application allows other applications to run as root on the device.</p></li><li><p>Many applications look for applications with specific package names. An example is show below.</p></li><li><p>There are some specific applications which run only on rooted devices. Checking for those applications would also be a good idea to detect if the device is rooted.<br>Example: Busybox.</p></li><li><p>Executing “su” and “id” commands and looking at the UID to see if it is root.</p></li><li><p>Checking the BUILD tag for test-keys: This check is generally to see if the device is running with a custom ROM. By default, Google gives ‘release-keys’ as its tag for stock ROMs. If it is something like “test-keys”, then it is most likely built with a custom ROM.</p></li></ul><h2 id="7-关于Debug"><a href="#7-关于Debug" class="headerlink" title="7 关于Debug"></a>7 关于Debug</h2><p><strong>JDB is a Java debugger, a simple command line debugger for Java classes. It comes preinstalled with JDK.如果是native开发，要用gdb</strong></p><p><a href="http://resources.infosecinstitute.com/android-hacking-security-part-5-debugging-java-applications-using-jdb/#article" target="_blank" rel="noopener">Refer link</a></p><p>Checking for Vulnerability</p><p>In fact, this is the easiest part of the entire article.</p><ol><li>Decompile the application using APKTOOL to get the AndroidManifest.xml file using the following command.</li></ol><p>apktool d vulnerableapp.apk</p><ol><li>Inspect Androidmanifest.xml file for the following line.</li></ol><p>android:debuggable=”true”</p><p>If you find the above line in the AndroidManifest.xml file, the application is debuggable and it can be exploited.</p><h2 id="8-Backup-techniques"><a href="#8-Backup-techniques" class="headerlink" title="8 Backup techniques"></a>8 Backup techniques</h2><p>Now let’s use the backup technique of android to find security issues by following these steps:</p><ol><li>Backup the app data using the adb backup command.<br> adb backup –f backup.ab com.whatsapplock</li><li>Convert the .ab format to the .tar format using the android backup extractor.<br> Android backup extractor, to convert our .ab  le into .tar format.<br> <code>C:\backup&gt;java -jar abe.jar -debug unpack backup.ab backup.tar</code></li><li>Extract the TAR file using the pax or star utility.</li><li>Analyze the extracted content from the previous step for security issues.</li></ol><p>How to protect our apps</p><p>If your app holds sensitive data, you can stop allowing users from making a backup of the app. This can be done by placing the following line in the AndroidManifest.xml file</p><p>android:allowBackup=”false”</p><h2 id="9-检查webview相关问题"><a href="#9-检查webview相关问题" class="headerlink" title="9 检查webview相关问题"></a>9 检查webview相关问题</h2><p><a href="http://resources.infosecinstitute.com/android-hacking-security-part-7-attacks-android-webviews/#article" target="_blank" rel="noopener">Refer link</a></p><p>As mentioned in the beginning, WebView supports usage of JavaScript. If the application being loaded into WebView requires JavaScript support, it can be enabled by using the following line.</p><p>WebView webview = (WebView) findViewById(R.id.mywebview);</p><p>WebSettings webSettings = myWebView.getSettings();</p><p>webSettings.setJavaScriptEnabled(true);</p><p>Another powerful feature in WebView is exposing a Java object’s methods to be accessed from JavaScript.</p><p>This is one of the important features which requires a keen eye when implementing, as it can be exploited by passing malicious JavaScript to the application’s interface. </p><p>Below is a sample code snippet by @jduck on how it can be implemented and exploited.</p><p><a href="https://github.com/jduck/VulnWebView/" target="_blank" rel="noopener">https://github.com/jduck/VulnWebView/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h1&gt;&lt;h2 id=&quot;Android-基本机构&quot;&gt;&lt;a href=&quot;#Android-基本机构&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
</feed>
