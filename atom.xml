<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rick7dology</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-05-07T08:04:16.886Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Rick7</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git的基本概念和remote的支持</title>
    <link href="http://yoursite.com/2018/05/07/Git%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8Cremote%E7%9A%84%E6%94%AF%E6%8C%81/"/>
    <id>http://yoursite.com/2018/05/07/Git的基本概念和remote的支持/</id>
    <published>2018-05-07T15:58:00.000Z</published>
    <updated>2018-05-07T08:04:16.886Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x01-Git基本概念"><a href="#0x01-Git基本概念" class="headerlink" title="0x01 Git基本概念"></a>0x01 Git基本概念</h1><ul><li>工作区：就是你在电脑里能看到的目录。</li><li>暂存区：英文叫stage, 或index。一般存放在 “.git目录下” 下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。</li><li>版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。</li></ul><p>当执行 “git reset HEAD” 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。<br>当执行 “git rm –cached <file>“ 命令时，会直接从暂存区删除文件，工作区则不做出改变。<br>当执行 “git checkout .” 或者 “git checkout – <file>“ 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。<br>当执行 “git checkout HEAD .” 或者 “git checkout HEAD <file>“ 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。</file></file></file></p><h1 id="0x02-同步远程库到本地"><a href="#0x02-同步远程库到本地" class="headerlink" title="0x02 同步远程库到本地"></a>0x02 同步远程库到本地</h1><ol><li>git clone</li><li>git pull</li></ol><p>参考：</p><p><a href="http://www.ruanyifeng.com/blog/2014/06/git_remote.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/06/git_remote.html</a></p><p><a href="https://help.github.com/articles/fetching-a-remote/" target="_blank" rel="noopener">https://help.github.com/articles/fetching-a-remote/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x01-Git基本概念&quot;&gt;&lt;a href=&quot;#0x01-Git基本概念&quot; class=&quot;headerlink&quot; title=&quot;0x01 Git基本概念&quot;&gt;&lt;/a&gt;0x01 Git基本概念&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;工作区：就是你在电脑里能看到的目录。&lt;/li&gt;

      
    
    </summary>
    
    
      <category term="Github" scheme="http://yoursite.com/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>SS和锐速的配置链接</title>
    <link href="http://yoursite.com/2018/04/21/SS%E5%92%8C%E9%94%90%E9%80%9F%E7%9A%84%E9%85%8D%E7%BD%AE%E9%93%BE%E6%8E%A5/"/>
    <id>http://yoursite.com/2018/04/21/SS和锐速的配置链接/</id>
    <published>2018-04-21T10:04:42.000Z</published>
    <updated>2018-04-21T02:08:55.975Z</updated>
    
    <content type="html"><![CDATA[<p>记录一些配置VPS中找到的有用链接：</p><p>SS：</p><p><a href="https://teddysun.com/486.html" target="_blank" rel="noopener">https://teddysun.com/486.html</a></p><p>锐速：</p><p><a href="https://github.com/91yun/serverspeeder" target="_blank" rel="noopener">https://github.com/91yun/serverspeeder</a></p><p><a href="https://www.91yun.co/serverspeeder91yun" target="_blank" rel="noopener">https://www.91yun.co/serverspeeder91yun</a></p><p>关于锐速的内核版本匹配问题现在越来越麻烦了，版本更新跟不上啊</p><p>Debian的用这个链接找吧：</p><p><a href="https://www.zhihu.in/archives/538" target="_blank" rel="noopener">https://www.zhihu.in/archives/538</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录一些配置VPS中找到的有用链接：&lt;/p&gt;
&lt;p&gt;SS：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://teddysun.com/486.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://teddysun.com/486.html
      
    
    </summary>
    
    
      <category term="其他" scheme="http://yoursite.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>iOS 安全特性学习简单</title>
    <link href="http://yoursite.com/2018/04/20/iOS-%E5%AE%89%E5%85%A8%E7%89%B9%E6%80%A7%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/04/20/iOS-安全特性学习笔记/</id>
    <published>2018-04-19T17:59:07.000Z</published>
    <updated>2018-04-23T09:56:20.348Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>抽空看一下Apple的iOS11的安全文档，并做简单笔记</p><p><img src="/images/Security architecture diagram of iOS.png" alt="iOS安全架构"></p><h1 id="0x01-System-security"><a href="#0x01-System-security" class="headerlink" title="0x01 System security"></a>0x01 System security</h1><ul><li>Secure boot chain</li></ul><p>这个特性就是由bootloader开始对每一步启动都验证签名,如果验证失败了就会去到recovery mode了</p><blockquote><p>The Boot ROM code contains the Apple Root CA public key, which is used to verify that the iBoot bootloader is signed by Apple before allowing it to load</p></blockquote><ul><li>System Software Authorization server</li></ul><p>这个好贱，防止你downgrade的一个远程服务器，还有一个叫nonce的机制防止服务器的应答被存储，从而绕过验证。。。</p><blockquote><p>The nonce prevents an attacker from saving the server’s response and using it to tamper with a device or otherwise alter the system software.</p></blockquote><ul><li>Secure Enclave</li></ul><p>Secure Enclave是一个协调处理器焊接在A11芯片中，主要用于加密数据，还内置了一个硬件随机数生成器。Secure Enclave的内部有一个4MB的闪存，储存椭圆曲线算法的私钥，操作系统不能直接访问这个私钥，只能把要加密或者解密的数据传给SE，然后SE返回结果。并且处理器和SE的通讯是独立隔离的。这里有个名词叫：interrupt-driven mailbox，不是太懂。</p><p>同时，第三方应用也是可以SE中创建和保存private key，但永远不能访问，只能把需要加解密的数据发送到SE，让SE进行处理得出结果</p><p>参考链接：</p><p><a href="https://www.howtogeek.com/339705/what-is-apples-secure-enclave-and-how-does-it-protect-my-iphone-or-mac/" target="_blank" rel="noopener">https://www.howtogeek.com/339705/what-is-apples-secure-enclave-and-how-does-it-protect-my-iphone-or-mac/</a></p><p><a href="https://developer.apple.com/documentation/security/certificate_key_and_trust_services/keys/storing_keys_in_the_secure_enclave" target="_blank" rel="noopener">https://developer.apple.com/documentation/security/certificate_key_and_trust_services/keys/storing_keys_in_the_secure_enclave</a></p><ul><li>Touch ID, Face ID,</li></ul><p>Touch ID, Face ID的解锁都是借助Secure Enclave来解密的，这个就不细看了，以后用到再查，下面是知乎(Kvenux Sun)的简单解释</p><blockquote><ol><li>Touch ID的数据读进来，处理器转发给Secure Enclave，处理器读不到这部分数据</li><li>SE(Secure Enclave)读取数据，通过密钥加解密，比对本地数据（SE自身密钥加密）</li><li>SE将结果返回给处理器这个过程中的密钥只有Touch ID和SE能知道，它们通过预设的key来协商得到这个密钥。可以看到这个过程中，处理器只转发了数据，它一方面没有办法拿到数据，另一方面也没有处理这部分数据的密钥，从硬件层面杜绝了外界截获Touch ID的可能。</li></ol></blockquote><h1 id="0x02-Encryption-and-Data-Protection"><a href="#0x02-Encryption-and-Data-Protection" class="headerlink" title="0x02 Encryption and Data Protection"></a>0x02 Encryption and Data Protection</h1><p>这部分的硬件加密和文件系统加密略过</p><ul><li>keychain</li></ul><p>说到底keychain就是一个小型SQLite数据库，用于储存APP的password等敏感信息。在iOS中，手机unlock了，keychain也会跟着unlock的。所有APP公用一个keychain，但每个一个app只能访问自己的keychain item，这是由securityd daemon所管理的。os x 和 iCloud keychain就不深究了</p><p>参考链接：</p><p><a href="https://medium.com/ios-os-x-development/securing-user-data-with-keychain-for-ios-e720e0f9a8e2" target="_blank" rel="noopener">https://medium.com/ios-os-x-development/securing-user-data-with-keychain-for-ios-e720e0f9a8e2</a></p><p><a href="https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/02concepts/concepts.html#//apple_ref/doc/uid/TP30000897-CH204-TP9" target="_blank" rel="noopener">https://developer.apple.com/library/content/documentation/Security/Conceptual/keychainServConcepts/02concepts/concepts.html#//apple_ref/doc/uid/TP30000897-CH204-TP9</a></p><h1 id="0x03-App-Security"><a href="#0x03-App-Security" class="headerlink" title="0x03 App Security"></a>0x03 App Security</h1><ul><li>App code signing</li></ul><p>应用代码签名特性，由系统启动开始，内核就会验证运行的应用是否经过Apple的certificate签名，包括iOS的内置应用和第三方应用。所以如果开发者想开发苹果应用，就必须要参加苹果的开发者计划，目的就是要得到有Apple签发的证书，从而使用这个证书为自己的应用进行签名。所以能够上架App Store的应用都是有名有姓的，有效的防止了恶意应用。当然，应用被苹果审查是难免的了，规则由别人制定。</p><p>详解的苹果开发者计划参考下面的链接：</p><p><a href="https://developer.apple.com/support/compare-memberships/" target="_blank" rel="noopener">https://developer.apple.com/support/compare-memberships/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;抽空看一下Apple的iOS11的安全文档，并做简单笔记&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/ima
      
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Meltdown（熔毁）和Spectre（幽灵）</title>
    <link href="http://yoursite.com/2018/04/10/Meltdown%EF%BC%88%E7%86%94%E6%AF%81%EF%BC%89%E5%92%8CSpectre%EF%BC%88%E5%B9%BD%E7%81%B5%EF%BC%89/"/>
    <id>http://yoursite.com/2018/04/10/Meltdown（熔毁）和Spectre（幽灵）/</id>
    <published>2018-04-10T15:01:09.000Z</published>
    <updated>2018-04-10T12:52:48.323Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>领导要求简单解释一下这个CPU级别的漏洞，只能上网找找资料学习一下原理，为了速度学习注意考虑了freebuf的文章</p><h1 id="0x01-乱序执行与预测执行"><a href="#0x01-乱序执行与预测执行" class="headerlink" title="0x01 乱序执行与预测执行"></a>0x01 乱序执行与预测执行</h1><p>传统CPU的指令是一条一条执行的，但现代的高性能CPU为了提高指令的执行效率，引入了一些新特性，其中就有指令的乱序执行和预测执行。</p><ul><li>乱序执行</li></ul><blockquote><p>比如当处理器中的某些指令需要等待某些资源，处理器不会真的在这里等待而停止指令的执行，而是利用等待资源的时间继续执行后续的指令。在支持乱序执行的CPU中，后面的指令可能在前面指令执行结束前就开始执行了。</p></blockquote><ul><li>预测执行</li></ul><blockquote><p>预测执行涉及到程序的控制流，现在处理器不是去解析所有分支指令后然后决定执行哪个操作，而是预测哪个控制流会更有可能被运行再提取相应的指令代码执行。如果预测正确的话，会带来很高的性能提升并提高处理器的并行性。如果预测错误，那些被预测执行的不正确结果会被丢弃，处理器会将状态恢复到预测执行行前的正确状态，再重新跳转到正确执行的分支或指令中运行。与乱序执行类似，预测执行对处理器缓存的操作会被保留。</p></blockquote><h1 id="0x02-问题点：CPU的缓存没有安全检查"><a href="#0x02-问题点：CPU的缓存没有安全检查" class="headerlink" title="0x02 问题点：CPU的缓存没有安全检查"></a>0x02 问题点：CPU的缓存没有安全检查</h1><p>乱序执行和预测执行这两个CPU的性能都有一个共同点，就是会提前把要准备要执行的，预测要执行的指令缓存到CPU的缓存上，然后再缓存到寄存器去执行指令。但由于处理器的缓存（cache）机制，那些被预测执行或乱序执行的指令会被先加载到缓存中，但在处理器恢复状态时并不会恢复处理器缓存的内容。这里就存在了一个致命的安全问题：<strong>在CPU缓存的指令是不用经过安全检查的，没有任何权限的检查，只有由缓存加载到寄存器的指令才会执行访问权限和地址合法性检查</strong></p><h1 id="0x03-缓存侧信道攻击"><a href="#0x03-缓存侧信道攻击" class="headerlink" title="0x03 缓存侧信道攻击"></a>0x03 缓存侧信道攻击</h1><p>既然CPU的缓存没有安全检查，那就成为了攻击的对象。这里在漏洞发现者的论文中都有提到，无时间继续研究了，水平所限，哈哈，希望以后有机会继续这个漏洞的学习</p><h1 id="0x04-TotalMeltdown"><a href="#0x04-TotalMeltdown" class="headerlink" title="0x04 TotalMeltdown"></a>0x04 TotalMeltdown</h1><p>微软2018年1月和2月的Windows7 x64 和 Windows Server 2008 R2 关于Meltdown安全补丁中被发现存在严重漏洞(Total Meltdown)，补丁中错误地将PML4权限设定成用户级，导致任意用户态进程可对系统内核进行任意读写。</p><p>关于这个可以看一下链接：</p><p><a href="http://blog.frizk.net/" target="_blank" rel="noopener">http://blog.frizk.net/</a></p><p><a href="https://github.com/ufrisk/pcileech" target="_blank" rel="noopener">https://github.com/ufrisk/pcileech</a></p><p><a href="https://www.anquanke.com/post/id/103324" target="_blank" rel="noopener">https://www.anquanke.com/post/id/103324</a></p><h1 id="本文参考链接："><a href="#本文参考链接：" class="headerlink" title="本文参考链接："></a>本文参考链接：</h1><p><a href="https://meltdownattack.com/" target="_blank" rel="noopener">https://meltdownattack.com/</a></p><p><a href="http://www.freebuf.com/vuls/159269.html" target="_blank" rel="noopener">http://www.freebuf.com/vuls/159269.html</a></p><p><a href="http://www.freebuf.com/articles/system/159811.html" target="_blank" rel="noopener">http://www.freebuf.com/articles/system/159811.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;领导要求简单解释一下这个CPU级别的漏洞，只能上网找找资料学习一下原理，为了速度学习注意考虑了fre
      
    
    </summary>
    
    
      <category term="漏洞学习" scheme="http://yoursite.com/tags/%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Android开发基础复习_2</title>
    <link href="http://yoursite.com/2018/04/05/Android%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0-2/"/>
    <id>http://yoursite.com/2018/04/05/Android开发基础复习-2/</id>
    <published>2018-04-04T22:58:40.000Z</published>
    <updated>2018-04-11T15:22:02.697Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>继续写“第一行代码”的读书笔记，这次看看Android的广播机制</p><h1 id="0x01-广播机制"><a href="#0x01-广播机制" class="headerlink" title="0x01 广播机制"></a>0x01 广播机制</h1><p>广播机制分为两类：</p><ul><li><p>标准广播：异步的，广播发送之后，所有的广播接收器几乎同时接受广播，广播效率比较高。但不能截断。</p></li><li><p>有序广播：同步执行的，优先级高的先接受到，之前的广播接收器可以截断广播。</p></li></ul><h1 id="0x02-动态注册广播接收器和静态注册广播接收器"><a href="#0x02-动态注册广播接收器和静态注册广播接收器" class="headerlink" title="0x02 动态注册广播接收器和静态注册广播接收器"></a>0x02 动态注册广播接收器和静态注册广播接收器</h1><p>先来看如何写动态注册，关键函数是：registerReceiver(networkChangReceiver,intentFilter)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    private IntentFilter intentFilter;</span><br><span class="line">    private NetworkChangReceiver networkChangReceiver;</span><br><span class="line"></span><br><span class="line">    class NetworkChangReceiver extends BroadcastReceiver &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onReceive(Context context,Intent intent) &#123;</span><br><span class="line">            Toast.makeText(context,&quot;Netwokchange&quot;,Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void onDestroy() &#123;</span><br><span class="line">        super.onDestroy();</span><br><span class="line">        unregisterReceiver(networkChangReceiver);//注销广播接收器</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.first_layout);</span><br><span class="line">        Button button1 = (Button) findViewById(R.id.button_1);</span><br><span class="line">        intentFilter = new IntentFilter();</span><br><span class="line">        intentFilter.addAction(&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;);//定义广播接收器的接收动作</span><br><span class="line">        networkChangReceiver = new NetworkChangReceiver();//新建一个广播接收器</span><br><span class="line">        registerReceiver(networkChangReceiver,intentFilter);//动态注册广播接收器</span><br></pre></td></tr></table></figure><p>静态注册的编写方法就简单多了，直接定义一个接收类，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> This method is called when the BroadcastReceiver is receiving</span></span><br><span class="line">        <span class="comment">// an Intent broadcast.</span></span><br><span class="line">        Toast.makeText(context, <span class="string">"开机 "</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Not yet implemented"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在AndroidManifest.xml中注册,添加Intentfileter；并且开启权限:RECEIVE_BOOT_COMPLETED</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.RECEIVE_BOOT_COMPLETED"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">receiver</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">".MyReceiver"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:enabled</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.BOOT_COMPLETED"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="0x03-发送广播"><a href="#0x03-发送广播" class="headerlink" title="0x03 发送广播"></a>0x03 发送广播</h1><ul><li>发送标准广播</li></ul><p>基本步骤为：新建一个广播接收器，在然后AndroidManifest.xml中注册,添加Intentfileter，发送自定义广播，也就是Intent。</p><p>这里的广播接收器我用上面的就OK了，只需要添加一个Intentfileter就完成。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//发送标准广播到我们定义的广播接收器</span><br><span class="line">        Button button5 = (Button) findViewById(R.id.button_5);</span><br><span class="line">        button3.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                Intent intent=new Intent(&quot;com.example.broadcastdemo.MY_BROADCAST&quot;);//还是要用到Intent</span><br><span class="line">                sendBroadcast(intent);</span><br></pre></td></tr></table></figure><ul><li>发送有序广播</li></ul><p>发送广播方式改为：sendOrderedBroadcast(intent, null);</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Button button5 = (Button) findViewById(R.id.button_5);</span><br><span class="line">        button3.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                Intent intent=<span class="keyword">new</span> Intent(<span class="string">"com.example.broadcastdemo.MY_BROADCAST"</span>);</span><br><span class="line">                sendOrderedBroadcast(intent,<span class="keyword">null</span>);<span class="comment">//发送有序广播</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>广播截断:abortBroadcast();</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line">    <span class="comment">//自定义的广播接收器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> This method is called when the BroadcastReceiver is receiving</span></span><br><span class="line">        <span class="comment">// an Intent broadcast.</span></span><br><span class="line">        Toast.makeText(context, <span class="string">"接收信息成功"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">        abortBroadcast(); <span class="comment">//截断广播</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>本地广播</li></ul><p>前面解释的都是全局广播，其他应用程序可以接收，本地广播只能够在应用程序的内部进行传递，有效更加安全性。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">   protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">       super.onCreate(savedInstanceState);</span><br><span class="line">       setContentView(R.layout.second_layout);</span><br><span class="line">       localBroadcastManager = LocalBroadcastManager.getInstance(this);</span><br><span class="line">       Button button5 = (Button) findViewById(R.id.button_5);</span><br><span class="line">       button5.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void onClick(View v) &#123;</span><br><span class="line">               Intent intent=new Intent(&quot;com.example.broadcastdemo.MY_BROADCAST_LOCAL&quot;);</span><br><span class="line">               //发送本地广播</span><br><span class="line">               localBroadcastManager.sendBroadcast(intent);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure><hr><p>静态注册本地广播接收器：localBroadcastManager.registerReceiver(localReceiver,intentFilter);</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">intentFilter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">        <span class="comment">//定义广播接收器的接收动作</span></span><br><span class="line">        intentFilter.addAction(<span class="string">"com.example.broadcastdemo.MY_BROADCAST_LOCAL"</span>);</span><br><span class="line"></span><br><span class="line">        localReceiver = <span class="keyword">new</span> LocalReceiver();</span><br><span class="line">        <span class="comment">//静态注册本地广播接收器</span></span><br><span class="line">        localBroadcastManager.registerReceiver(localReceiver,intentFilter);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;继续写“第一行代码”的读书笔记，这次看看Android的广播机制&lt;/p&gt;
&lt;h1 id=&quot;0x01-
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Json web token vs session id</title>
    <link href="http://yoursite.com/2018/04/04/Json-web-token-vs-session-id/"/>
    <id>http://yoursite.com/2018/04/04/Json-web-token-vs-session-id/</id>
    <published>2018-04-03T21:58:19.000Z</published>
    <updated>2018-04-09T10:16:31.615Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>JWT是现代web中常见的持续认证手段，也是针对http无状态的其中一个认证的解决方案，今日特地看了写JWT和传统的session id方案作比较的文章</p><h1 id="0x01-Json-Web-Token"><a href="#0x01-Json-Web-Token" class="headerlink" title="0x01 Json Web Token"></a>0x01 Json Web Token</h1><p>JWT是开发的标准，主要的特点是简洁，自包含。通过数字签名确保信息的完整性，真实性</p><h2 id="JWT的结构"><a href="#JWT的结构" class="headerlink" title="JWT的结构"></a>JWT的结构</h2><p>主要包括三大块：header, payload and signature。</p><p>详细的信息主要参考官方说明：</p><p><a href="https://jwt.io/introduction/" target="_blank" rel="noopener">https://jwt.io/introduction/</a></p><h2 id="JWT的认证过程"><a href="#JWT的认证过程" class="headerlink" title="JWT的认证过程"></a>JWT的认证过程</h2><p>当然登录应用成功后，应用会返回一个JWT给用户保存，用户后续的请求都会带上这个JWT作为token取得授权的资源。常见的JWT会以以下的请求头部出现：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Authorization: Bearer &lt;token&gt;</span><br></pre></td></tr></table></figure><p>具体的认证过程如下：</p><p><img src="/images/JWT_workflow.png" alt="JWT认证图"></p><h1 id="0x02-与传统session-id的比较"><a href="#0x02-与传统session-id的比较" class="headerlink" title="0x02 与传统session id的比较"></a>0x02 与传统session id的比较</h1><ul><li>在扩展性上，JWT的扩展性比session更加好，毕竟session需要存储在服务器，如果需要做服务器迁移或者扩展，JWT的基于token认证的无状态显示出了优势。</li><li>在安全性上，本人感觉JWT没有比session更加有优势，JWT使用了数字签名确保了数据的完整性和防篡改，但还是要存储在用户本地，这样和普通cookie一样会受到XSS攻击的威胁，有被盗取的风险。而却JWT对于防CSRF也是显得力不从心的，特别在攻击者诱骗授权用户点击操作的场景，还是需要CSRF token。在重放攻击(replay attack)中，JWT也是不能防止这类攻击的。</li><li>在 RESTful API Services 上，JWT简直是为这个而生，无状态的最佳实现，再配合(CORS)进行跨越，这样调用API就更加方便了</li></ul><h1 id="0x03-JWT已知漏洞"><a href="#0x03-JWT已知漏洞" class="headerlink" title="0x03 JWT已知漏洞"></a>0x03 JWT已知漏洞</h1><ul><li>NONE hashing algorithm ：某些JWT库对token的验证出现了bug，详细资料参考以下链接：</li></ul><p><a href="https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/" target="_blank" rel="noopener">https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/</a></p><h1 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h1><p><a href="https://ponyfoo.com/articles/json-web-tokens-vs-session-cookies" target="_blank" rel="noopener">https://ponyfoo.com/articles/json-web-tokens-vs-session-cookies</a></p><p><a href="https://github.com/teesloane/Auth-Boss" target="_blank" rel="noopener">https://github.com/teesloane/Auth-Boss</a></p><p><a href="https://www.owasp.org/index.php/JSON_Web_Token_(JWT)_Cheat_Sheet_for_Java#Issues" target="_blank" rel="noopener">https://www.owasp.org/index.php/JSON_Web_Token_(JWT)_Cheat_Sheet_for_Java#Issues</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;JWT是现代web中常见的持续认证手段，也是针对http无状态的其中一个认证的解决方案，今日特地看了
      
    
    </summary>
    
    
      <category term="Web security" scheme="http://yoursite.com/tags/Web-security/"/>
    
  </entry>
  
  <entry>
    <title>Android开发基础读书笔记_1</title>
    <link href="http://yoursite.com/2018/03/23/Android%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0_1/"/>
    <id>http://yoursite.com/2018/03/23/Android开发基础复习_1/</id>
    <published>2018-03-22T23:46:54.000Z</published>
    <updated>2018-03-28T14:43:46.820Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>又看了一遍“第一行代码”的第二版，这次跟着书里面的代码随便敲了一下，顺便写一遍读书笔记</p><h2 id="0x01-Android项目中的资源"><a href="#0x01-Android项目中的资源" class="headerlink" title="0x01 Android项目中的资源"></a>0x01 Android项目中的资源</h2><p>src: 各种java程序在此，包括主程序<br>gen: 最重要的是R.java，所有res资源都在这里编号，通过R.xx.xx或@xx查询<br>res: 各种资源都在这里，包括drawable, layout, values等<br>另外还有menifest文件，统筹兼顾全局的，Android四大组件都要在此注册。</p><p><strong>重点说一下gradle，这里有两个build.gradle目录，一个在项目的最外层，负责项目全局的构建，另外一个build.gradle在app模块的构建脚本，里面有超级多的构建配置，关于gradle会另外在自行学习一点</strong></p><h2 id="0x02-Activity"><a href="#0x02-Activity" class="headerlink" title="0x02 Activity"></a>0x02 Activity</h2><p>创建Activity步骤：<br>1、首先，在app目录右击创建一个空的activity，重写Activity的onCreate()方法<br>2、建立布局文件并关联，用setContentView(R.layout.myactivity)将布局加载进来。<br>3、所有四大组件的使用，都需要在AndroidManifest.xml文件中注册。AS自动帮我解决了，下面是手动方式<br>注册方法为：<br>在<application>中添加<activity>标签，将需要注册的activity使用android:name=”.MainActivity”注册。如果是主activity，即打开application时看到的activity，则需要添加</activity></application></p><p><action android:name="android.intent.action.MAIN"></action></p><p><category android:name="android.intent.category.LAUNCHER"><br>4、加一个button到新创建的activity，然后用toast对象的show方法进行输出提示</category></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.first_layout);</span><br><span class="line">        Button button1 = (Button)findViewById(R.id.button_1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//建立一个button并调用Toast显示短信息</span></span><br><span class="line">        button1.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>&#123;</span><br><span class="line">                Toast.makeText(MainActivity.<span class="keyword">this</span>,<span class="string">"You click button_1"</span>,</span><br><span class="line">                        Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><h2 id="0x03-Intent"><a href="#0x03-Intent" class="headerlink" title="0x03 Intent"></a>0x03 Intent</h2><ul><li>显式Intent</li></ul><p>首先，按照上面的步骤重新创建一个SecondActivity（记得注册），采用Intent实现跳转</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Button button2 = (Button)findViewById(R.id.button_2);</span><br><span class="line">        button2.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>&#123;</span><br><span class="line">                Intent intent = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>,Main2Activity.class);</span><br><span class="line">                startActivity(intent);<span class="comment">//使用显示intent调用Main2Activity</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><ul><li>隐式Intent</li></ul><p>隐式Intent并不能实现直接跳转，需要指定两个条件（intent-filter）：action和category。<strong>要两个同时匹配才能相应这个intent。</strong></p><p>intent-filter在注册activity时添加，intentfilter中只能有一个action，但可以有多个category，满足其中一个category即可。</p><p>跳转方法为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用隐式Intent调用第三个page，Category使用默认的，自定义的实验失败</span></span><br><span class="line">        Button button3 = (Button)findViewById(R.id.button_3);</span><br><span class="line">        button3.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>&#123;</span><br><span class="line">                Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.example.rick7.rickapplication.ACTION_START"</span>);<span class="comment">//使用隐式Intent，只传入一个自定义的动作名称</span></span><br><span class="line">                <span class="comment">//intent.addCategory("com.example.rick7.rickapplication.MY_CATEGORY");</span></span><br><span class="line">                startActivity(intent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><ul><li><p>使用隐式Intent的系统内置方法，打开系统编写的activity，比如浏览器，打电话等</p></li><li><p>使用Intent传递数据</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用隐式Intent调用系统浏览器界面并打开百度，并传输数据到BrowserActivity</span></span><br><span class="line">        Button button4 = (Button)findViewById(R.id.button_4);</span><br><span class="line">        button4.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>&#123;</span><br><span class="line">                String data = <span class="string">"i want to open baidu"</span>;</span><br><span class="line">                Intent intent= <span class="keyword">new</span> Intent(Intent.ACTION_VIEW);<span class="comment">//传入系统内置动作ACTION_VIEW</span></span><br><span class="line">                intent.setData(Uri.parse(<span class="string">"http://www.baidu.com"</span>));<span class="comment">//设置Intent携带的数据</span></span><br><span class="line">                intent.putExtra(<span class="string">"extra_data"</span>,data);</span><br><span class="line">                startActivity(intent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><h2 id="0x04-activity生存期"><a href="#0x04-activity生存期" class="headerlink" title="0x04 activity生存期"></a>0x04 activity生存期</h2><p>完整生存期：onCreate() -&gt; onDestory()<br>可见生存期：onStart() -&gt; onStop()<br>前台生存期：onResume() -&gt; onPause()</p><p><img src="/images/activity生存周期.png" alt="生存周期"></p><h2 id="0x05-activity的启动模式"><a href="#0x05-activity的启动模式" class="headerlink" title="0x05 activity的启动模式"></a>0x05 activity的启动模式</h2><p>四种启动模式，可以在<activity>标签中android:launchMode定义。</activity></p><ul><li>standard：打开activity，就放入栈顶</li><li>singleTop：打开activity，检查栈顶是否已经存在该activity，存在了就不创建。不存在才创建。不过，如果该activity不在栈顶，但也存在，则也会重新创建一个。</li><li>singleTask：检查整个返回栈，如果存在某个activity，则不会重新创建。</li><li>singleInstance：创建一个activity，重新在一个新的返回栈(或Task)中创建，该activity与其他activity不在同一个Task中，其他程序也可以调用这个activity的实例。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;又看了一遍“第一行代码”的第二版，这次跟着书里面的代码随便敲了一下，顺便写一遍读书笔记&lt;/p&gt;
&lt;h
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>英文面试速背指南_持续更新</title>
    <link href="http://yoursite.com/2018/03/21/%E8%8B%B1%E6%96%87%E9%9D%A2%E8%AF%95%E9%80%9F%E8%83%8C%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2018/03/21/英文面试速背指南/</id>
    <published>2018-03-20T18:04:27.000Z</published>
    <updated>2018-04-10T13:37:08.062Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>为了面试外企做准备的速背表，一定要精简,精简，再精简，每个概念尽量一到两句话进行速记</p><h1 id="0x01-What-is-Penetration-Testing"><a href="#0x01-What-is-Penetration-Testing" class="headerlink" title="0x01 What is Penetration Testing?"></a>0x01 What is Penetration Testing?</h1><p>Penetration testing is a type of security testing that is used to test the insecurity of an application. It is conducted to find the security risk which might be present in the system.</p><h1 id="0x02-Penetration-Testing-Methodologies-seven-steps"><a href="#0x02-Penetration-Testing-Methodologies-seven-steps" class="headerlink" title="0x02 Penetration Testing Methodologies (seven steps)"></a>0x02 Penetration Testing Methodologies (seven steps)</h1><p>Penetration Testing Execution Standard (PTES) defines penetration testing as 7 phases.</p><ul><li><p>Pre-engagement Interactions<br>It includes gathering the required tools, OS, and software to start the penetration testing. In addition, there are some basic tools that are required to complete penetration testing with expected results.</p></li><li><p>Intelligence Gathering (Information Gathering)(DNS,IP,Email,Google hacking,etc…)<br>The data is collected to help in completing the assessment actions. The information is gathered using a process that helps us to get access to any information that is relevant to the target.</p></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tools：</span><br><span class="line">1.theHarvester is a tool for gathering e-mail accounts, subdomain names, virtual</span><br><span class="line">hosts, open ports/ banners, and employee names from different public sources</span><br><span class="line">(search engines, pgp key servers).</span><br><span class="line">https://github.com/laramies/theHarvester</span><br><span class="line">2.Social Engineer Toolkit</span><br><span class="line">Social Engineer Toolkit (SET) is an open source Python-based tool aimed at penetration testing around Social Engineering.</span><br></pre></td></tr></table></figure><ul><li><p>Threat Modeling<br>Threat modeling allows you to strengthen network security by tracking the vulnerabilities and then defining measures to prevent or reduce the effect of the threat.</p></li><li><p>Vulnerability Analysis(Scanning,manual testing)<br>Identification: Vulnerabilities are discovered<br>Validation: Validate the identified vulnerabilities</p></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tools:</span><br><span class="line">1.OpenVAS</span><br><span class="line">2.Nexpose/Nessus</span><br><span class="line">3.Netsparker </span><br><span class="line">4.Acunetix(AWS)</span><br></pre></td></tr></table></figure><ul><li>Exploitation<br>The identified vulnerabilities are exploited to breach the security</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tools:</span><br><span class="line">1.BeEF(Browser Exploitation Framework (Beef))</span><br><span class="line">2.Metasploit</span><br><span class="line">3.sqlmap</span><br></pre></td></tr></table></figure><ul><li>Post Exploitation<br>In this phase, the compromised machine’s value is determined by the sensitivity of the data stored on it. It also evaluates the machine usefulness in further exploiting the network.</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tools:</span><br><span class="line">1.PowerShell Empire</span><br><span class="line">2.Meterpreter</span><br><span class="line">3.Netcat</span><br></pre></td></tr></table></figure><ul><li>Reporting<br>The findings are reported in a way that is easily understandable. </li></ul><h1 id="0x03-Web-Vulnerability"><a href="#0x03-Web-Vulnerability" class="headerlink" title="0x03 Web Vulnerability"></a>0x03 Web Vulnerability</h1><h2 id="What-is-SQLinjection-attack"><a href="#What-is-SQLinjection-attack" class="headerlink" title="What is SQLinjection attack"></a>What is SQLinjection attack</h2><p>A SQL injection attack consists of insertion or “injection” of a SQL query via the input data from the client to the application. A successful SQL injection exploit can read sensitive data from the database, modify database data (Insert/Update/Delete), execute administration operations on the database (such as shutdown the DBMS), recover the content of a given file present on the DBMS file system and in some cases issue commands to the operating system. SQL injection attacks are a type of injection attack, in which SQL commands are injected into data-plane input in order to effect the execution of predefined SQL commands.</p><ul><li>In-band SQLi (Classic SQLi):Error-based SQLi and Union-based SQLi.</li><li>Inferential SQLi (Blind SQLi):Boolean-based (content-based) Blind SQLi and Time-based Blind SQLi</li></ul><h2 id="What-is-Cross-site-Scripting-XSS-attack"><a href="#What-is-Cross-site-Scripting-XSS-attack" class="headerlink" title="What is Cross-site Scripting (XSS) attack"></a>What is Cross-site Scripting (XSS) attack</h2><p>Cross-Site Scripting (XSS) attacks are a type of injection, in which malicious scripts are injected into otherwise benign and trusted web sites. XSS attacks occur when an attacker uses a web application to send malicious code, generally in the form of a browser side script, to a different end user. Flaws that allow these attacks to succeed are quite widespread and occur anywhere a web application uses input from a user within the output it generates without validating or encoding it.</p><ul><li>Reflected XSS Attacks</li><li>Stored XSS Attacks</li><li>DOM Based XSS </li></ul><h2 id="OWASP-top-10-2017"><a href="#OWASP-top-10-2017" class="headerlink" title="OWASP top 10 2017"></a>OWASP top 10 2017</h2><p>Top 10<br>A1:2017-Injection (SQL, LDAP, XPath, or NoSQL queries, OS commands, XML parsers, SMTP headers, expression languages, and ORM queries.)</p><p>A2:2017-Broken Authentication</p><p>A3:2017-Sensitive Data Exposure</p><p>A4:2017-XML External Entities (XXE) Any of the XML processors in the application or SOAP based web services has document type definitions (DTDs) enabled.</p><p>A5:2017-Broken Access Control</p><p>A6:2017-Security Misconfiguration</p><p>A7:2017-Cross-Site Scripting (XSS)</p><p>A8:2017-Insecure Deserialization</p><p>A9:2017-Using Components with Known Vulnerabilities</p><p>A10:2017-Insufficient Logging&amp;Monitoring</p><h1 id="0x04-Check-list-amp-testing-case"><a href="#0x04-Check-list-amp-testing-case" class="headerlink" title="0x04 Check list &amp; testing case"></a>0x04 Check list &amp; testing case</h1><ul><li>input validation (sql injection,xss,os command,LDAP,path manipulation,file upload,header injection,xml injection)</li><li>information disclosure (error handling,code comments,platform information disclosure,)</li><li>Authentication (Credentials in plant text,Captcha is not random,SSO,broken authentication,username and password can be enumerated)</li><li>password management(hard code password…)</li><li>session management(timeout,fixation,not terminate,flag for secure and httponly)</li><li>Authoriztion(privilege escalation)</li><li>logging/Auditing (sensitive data logged)</li><li>Configuration (Network device misconfig,Firewall misconfig)</li><li>Logic error(bypass security control)</li><li>Web service(SOAP , restful)</li><li>Json(Json hijacking )</li></ul><h1 id="05-Question-for-the-interviewee"><a href="#05-Question-for-the-interviewee" class="headerlink" title="05 Question for the interviewee"></a>05 Question for the interviewee</h1><ol><li>Could you pls introduce the daily work for this position ?</li><li>Could you pls introduce the team structure ?</li><li>What pentest tooling was using in the daily work and do the team purchase any license for the tools ?</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;为了面试外企做准备的速背表，一定要精简,精简，再精简，每个概念尽量一到两句话进行速记&lt;/p&gt;
&lt;h1
      
    
    </summary>
    
    
      <category term="其他" scheme="http://yoursite.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>OAuth2.0 笔记_2</title>
    <link href="http://yoursite.com/2018/03/13/OAuth2-0-%E7%AC%94%E8%AE%B02/"/>
    <id>http://yoursite.com/2018/03/13/OAuth2-0-笔记2/</id>
    <published>2018-03-12T19:27:59.000Z</published>
    <updated>2018-03-15T07:56:40.349Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>在上一遍学习笔记中整理了授权码模式的交换流程和csrf攻击的知识，这次继续总结OAuth其他攻击面</p><h1 id="0x01-“redirect-uri”"><a href="#0x01-“redirect-uri”" class="headerlink" title="0x01 “redirect uri”"></a>0x01 “redirect uri”</h1><p>根据OAuth的认证流程,用户授权凭证会由服务器转发到redirect_uri对应的地址,如果攻击者伪造redirect_uri为自己的地址,然后诱导用户发送该请求,之后获取的凭证就会发送给攻击者伪造的回调地址.攻击者使用该凭证即可登录用户账号,造成授权劫持.</p><p>近日有安全测试团队又发布了一些关于redirect_url过滤不严格的问题，详情看下面的链接，就是redirect_uri只过滤了主域名，而没有对子域名进行过滤，如果子域名存在漏洞，攻击者则可以通过子域名构造构造恶意的redirect_uri，从refer头部盗取用户的 “authorization code”</p><p><a href="https://bbs.ichunqiu.com/thread-34168-1-1.html" target="_blank" rel="noopener">https://bbs.ichunqiu.com/thread-34168-1-1.html</a></p><p>Refer:</p><p><a href="http://www.freebuf.com/articles/web/110757.html" target="_blank" rel="noopener">http://www.freebuf.com/articles/web/110757.html</a></p><p><a href="https://dhavalkapil.com/blogs/Attacking-the-OAuth-Protocol/" target="_blank" rel="noopener">https://dhavalkapil.com/blogs/Attacking-the-OAuth-Protocol/</a></p><p><a href="https://sakurity.com/oauth" target="_blank" rel="noopener">https://sakurity.com/oauth</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;在上一遍学习笔记中整理了授权码模式的交换流程和csrf攻击的知识，这次继续总结OAuth其他攻击面&lt;
      
    
    </summary>
    
    
      <category term="Web security" scheme="http://yoursite.com/tags/Web-security/"/>
    
  </entry>
  
  <entry>
    <title>经典sqlmap命令</title>
    <link href="http://yoursite.com/2018/03/09/%E7%BB%8F%E5%85%B8sqlmap%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/03/09/经典sqlmap命令/</id>
    <published>2018-03-09T15:33:21.000Z</published>
    <updated>2018-03-09T10:07:51.195Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x01-查看当前数据库，得到数据库名字"><a href="#0x01-查看当前数据库，得到数据库名字" class="headerlink" title="0x01 查看当前数据库，得到数据库名字"></a>0x01 查看当前数据库，得到数据库名字</h1><p>sqlmap.py -u “存在注入url” –current-db</p><p>python sqlmap.py -u “<a href="http://127.0.0.1:65412/?id=2" target="_blank" rel="noopener">http://127.0.0.1:65412/?id=2</a>“ –current-db</p><h1 id="0x02-查看tables-得到指定数据库的表名字"><a href="#0x02-查看tables-得到指定数据库的表名字" class="headerlink" title="0x02 查看tables,得到指定数据库的表名字"></a>0x02 查看tables,得到指定数据库的表名字</h1><p>python sqlmap.py -u “存在注入url” -D “当前数据库名” –tables   //解释说明：-D是指定数据库名称</p><p>python sqlmap.py -u “<a href="http://127.0.0.1:65412/?id=2" target="_blank" rel="noopener">http://127.0.0.1:65412/?id=2</a>“ –tables</p><h1 id="0x03-查看columns，得到指定数据库，指定表的列名字"><a href="#0x03-查看columns，得到指定数据库，指定表的列名字" class="headerlink" title="0x03 查看columns，得到指定数据库，指定表的列名字"></a>0x03 查看columns，得到指定数据库，指定表的列名字</h1><p>sqlmap.py -u “存在注入url” -D “当前数据库名” -T “数据库中的随意一张表(选取表需要自己判断)” –columns</p><p>python sqlmap.py -u “<a href="http://127.0.0.1:65412/?id=2" target="_blank" rel="noopener">http://127.0.0.1:65412/?id=2</a>“ -T “users” –columns</p><h1 id="0x04-根据上面得到的columns查看具体字段"><a href="#0x04-根据上面得到的columns查看具体字段" class="headerlink" title="0x04 根据上面得到的columns查看具体字段"></a>0x04 根据上面得到的columns查看具体字段</h1><p>sqlmap.py -u “存在注入url ” -D “当前数据库名” -T “数据库中的随意一张表(选取表需要自己判断)” -C “username,password,email” –dump</p><p>python sqlmap.py -u “<a href="http://127.0.0.1:65412/?id=2" target="_blank" rel="noopener">http://127.0.0.1:65412/?id=2</a>“ -T “users” -C “password” –dump</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x01-查看当前数据库，得到数据库名字&quot;&gt;&lt;a href=&quot;#0x01-查看当前数据库，得到数据库名字&quot; class=&quot;headerlink&quot; title=&quot;0x01 查看当前数据库，得到数据库名字&quot;&gt;&lt;/a&gt;0x01 查看当前数据库，得到数据库名字&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="Web security" scheme="http://yoursite.com/tags/Web-security/"/>
    
  </entry>
  
  <entry>
    <title>数字证书的理解</title>
    <link href="http://yoursite.com/2018/03/07/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/03/07/数字证书的理解/</id>
    <published>2018-03-07T11:27:18.000Z</published>
    <updated>2018-03-10T07:47:14.445Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>数字证书是公钥密码学的典型应用，是信息安全的基础，今日好好复习一下</p><h1 id="0x01-简单应用原理"><a href="#0x01-简单应用原理" class="headerlink" title="0x01 简单应用原理"></a>0x01 简单应用原理</h1><p><strong>最重要的一点，数字证书是保障公钥的可靠性</strong></p><p>以下流程参考阮一峰老师的经典流程：</p><p>假设A给B写一份信。</p><p>那么这封将包含如下三部分内容：</p><p>1.信本身的内容（直接可以看到，未加密）</p><p>2.A的数字签名 （是由信本身的内容经过hash算法计算得到digest摘要，然后用 A的私钥 加密而来的）</p><p>3.A的数字证书 （是A 向数字证书中心（CA）申请的，是由 A的个人信息，A的公钥 等经过CA的私钥 加密而来的）</p><p>然后B先用CA提供的公钥解开数字证书，根据得到的内容，如A的个人信息，确定是A发过来的，然后拿到了A的公钥。</p><p>接着，用A的公钥解开A的数字签名 就能得到信本身内容的摘要。然后将信的第一部分，即信的本身内容 经hash计算得到一个新的摘要，将两个摘要比较，如果相同 说明信的内容没有被篡改。</p><p><strong>这里B要做的就是查询CA是否可信，然后用可信CA的公钥解开A的数字证书，得到A的个人信息和公钥，然后利用A的可信公钥验证A的数字签名，可见，数字证书的最大作用就是保证A的公钥的真实性，抗抵赖</strong></p><h1 id="0x02-Https的应用"><a href="#0x02-Https的应用" class="headerlink" title="0x02 Https的应用"></a>0x02 Https的应用</h1><p>https传输，访问google网站：<br>握手时用非对称加密传输对称加密的密码，数据传输时用对称加密的密码加密数据（对称加密解密速度比非对称加密快）</p><p>过程：</p><ul><li>浏览器发送自己支持的加密规则给google</li><li>google选择一组加密算法和HASH算法，并将自己的数字证书发给浏览器</li><li>浏览器验证数字证书的合法性（验证证书的数字签名），然后生成一个随机数，从google的数字证书里面获取google的公钥，用这个公钥加密随机数。用约定的hash算法生成握手消息的摘要，并用生成的随机数加密摘要。把握手消息、加密的摘要、加密的随机数发给google</li><li>google用自己的私钥解密随机数，然后用随机数解密摘要，再用hash生成收到的握手消息的摘要与解密的摘要对比，验证正确性。</li><li>google一样用hash算法生成握手消息的摘要，并用解密的随机数加密摘要。然后把握手消息、加密的摘要发给浏览器</li><li>浏览器验证摘要成功后，握手完成。之后通信的数据用之前浏览器生成的随机密码加密后传输。</li></ul><h1 id="0x03-问题的根源：-证书中的公钥的真实性和完整性）"><a href="#0x03-问题的根源：-证书中的公钥的真实性和完整性）" class="headerlink" title="0x03 问题的根源：(证书中的公钥的真实性和完整性）"></a>0x03 问题的根源：(证书中的公钥的真实性和完整性）</h1><p>由上面的例子中我们看到，https传输的过程中，Google会发来自己的证书，里面包含了Google的公钥，用户浏览器要使用这个公钥加密消息再发送到Google服务器进行协商，其中，这个公钥的完整性和真实性就是关键，如何保证这个证书里面的公钥真的是Google的呢？这就是为什么要验证证书的数字签名的理由，那么如何验证呢？就是通过CA了，CA会通过自己的私钥对可信的包含正确公钥的Google证书进行数字签名，用户浏览器要使用CA的公钥验证证书的数字签名。</p><h1 id="0x04-证书链"><a href="#0x04-证书链" class="headerlink" title="0x04 证书链"></a>0x04 证书链</h1><p>根据上面的说明，证书的出现是为了保证双方的公钥是合法的，没有被篡改的，那么谁保证证书的合法性和完整呢？那就是CA，但是直接从知名的CA获得签名证书是昂贵的，所以，就出现了由知名CA签发了一个证书A，再又证书A签发证书B的方式，这就是证书链。<br><strong>本质来说，就是顶级CA认证了A的公钥，然后A的公钥再认证B的公钥。</strong> </p><h2 id="证书链的构成："><a href="#证书链的构成：" class="headerlink" title="证书链的构成："></a>证书链的构成：</h2><p>end-user ：baidu.com 包含用来加密传输数据的公钥的证书，是HTTPS中使用的证书</p><p>intermediates CA ：CA用来认证公钥持有者身份的证书，即确认HTTPS使用的end-user证书是属于baidu.com的证书。这类intermediates证书甚至可以有很多级。</p><p>root CA ：用来认证intermediates证书是合法证书的证书。</p><p>简单来说，end-user证书上面几级证书都是为了保证end-user证书未被篡改，保证是CA签发的合法证书，进而保证end-user证书中的公钥未被篡改</p><p><img src="/images/certificate chain.png" alt="证书链图片"></p><h2 id="如何验证证书链"><a href="#如何验证证书链" class="headerlink" title="如何验证证书链"></a>如何验证证书链</h2><p>链式向上验证证书，直到Root Certificates，先验证用intermediates CA 签发的end-user的证书的数字签名，再利用root CA验证intermediates CA的数字签名。下图就是访问百度获得的三张证书</p><p><img src="/images/end-user.png" alt="证书链图片1"><br><img src="/images/intermediates CA.png" alt="证书链图片2"><br><img src="/images/root CA.png" alt="证书链图片3"></p><p>下面的图片很好的表达了如何进行证书链的认证：</p><p><img src="/images/verify.png" alt="证书链图片4"></p><p>从哪获取非根证书的颁发者证书？</p><p>网站的证书里是包含上级颁发机构的证书获取地址的</p><h2 id="总体来说浏览器对证书的验证包括下面几项："><a href="#总体来说浏览器对证书的验证包括下面几项：" class="headerlink" title="总体来说浏览器对证书的验证包括下面几项："></a>总体来说浏览器对证书的验证包括下面几项：</h2><ul><li><p>验证证书是否在有效期内</p></li><li><p>验证证书是否在有效期内</p></li></ul><p>验证吊销有CRL和OCSP两种方法</p><ul><li>验证证书是否是上级CA签发的(上面讨论的重点)</li></ul><h1 id="x-509-证书编码格式"><a href="#x-509-证书编码格式" class="headerlink" title="x.509 证书编码格式"></a>x.509 证书编码格式</h1><p>我们平时会见到一大堆后缀名不同的证书，但先抛开后缀名字不谈，x.509就只有两种常用的编码格式</p><ul><li><p>PEM - Privacy Enhanced Mail,打开看文本格式,以”—–BEGIN…”开头, “—–END…”结尾,内容是BASE64编码.<br>查看PEM格式证书的信息:openssl x509 -in certificate.pem -text -noout<br>Apache和*NIX服务器偏向于使用这种编码格式.</p></li><li><p>DER - Distinguished Encoding Rules,打开看是二进制格式,不可读.<br>查看DER格式证书的信息:openssl x509 -in certificate.der -inform der -text -noout<br>Java和Windows服务器偏向于使用这种编码格式.</p></li></ul><h2 id="相关的文件扩展名-引用一下别人的"><a href="#相关的文件扩展名-引用一下别人的" class="headerlink" title="相关的文件扩展名,引用一下别人的"></a>相关的文件扩展名,引用一下别人的</h2><blockquote><p>这是比较误导人的地方,虽然我们已经知道有PEM和DER这两种编码格式,但文件扩展名并不一定就叫”PEM”或者”DER”,常见的扩展名除了PEM和DER还有以下这些,它们除了编码格式可能不同之外,内容也有差别,但大多数都能相互转换编码格式.</p></blockquote><ul><li><p>CRT - CRT应该是certificate的三个字母,其实还是证书的意思,常见于*NIX系统,有可能是PEM编码,也有可能是DER编码,大多数应该是PEM编码,</p></li><li><p>CER - 还是certificate,还是证书,常见于Windows系统,同样的,可能是PEM编码,也可能是DER编码,大多数应该是DER编码.</p></li><li><p>PFX/P12 - predecessor of PKCS#12,对*nix服务器来说,一般CRT和KEY是分开存放在不同文件中的,但Windows的IIS则将它们存在一个PFX文件中,(因此这个文件包含了证书及私钥)这样会不会不安全？应该不会,PFX通常会有一个”提取密码”,你想把里面的东西读取出来的话,它就要求你提供提取密码,PFX使用的时DER编码,如何把PFX转换为PEM编码？<br>openssl pkcs12 -in for-iis.pfx -out for-iis.pem -nodes<br>这个时候会提示你输入提取代码. for-iis.pem就是可读的文本.<br>生成pfx的命令类似这样:openssl pkcs12 -export -in certificate.crt -inkey privateKey.key -out certificate.pfx -certfile CACert.crt</p></li></ul><p>其中CACert.crt是CA(权威证书颁发机构)的根证书,有的话也通过-certfile参数一起带进去.这么看来,PFX其实是个证书密钥库.</p><p>参考：</p><p><a href="http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html</a></p><p><a href="https://www.jianshu.com/p/46e48bc517d0" target="_blank" rel="noopener">https://www.jianshu.com/p/46e48bc517d0</a></p><p><a href="https://security.stackexchange.com/questions/56389/ssl-certificate-framework-101-how-does-the-browser-actually-verify-the-validity" target="_blank" rel="noopener">https://security.stackexchange.com/questions/56389/ssl-certificate-framework-101-how-does-the-browser-actually-verify-the-validity</a></p><p><a href="https://www.zhihu.com/question/37370216" target="_blank" rel="noopener">https://www.zhihu.com/question/37370216</a></p><p><a href="http://www.cnblogs.com/guogangj/p/4118605.html" target="_blank" rel="noopener">http://www.cnblogs.com/guogangj/p/4118605.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;数字证书是公钥密码学的典型应用，是信息安全的基础，今日好好复习一下&lt;/p&gt;
&lt;h1 id=&quot;0x01
      
    
    </summary>
    
    
      <category term="Web security" scheme="http://yoursite.com/tags/Web-security/"/>
    
  </entry>
  
  <entry>
    <title>Python 常用套路总结_1</title>
    <link href="http://yoursite.com/2018/03/03/Python%20%E5%B8%B8%E7%94%A8%E5%A5%97%E8%B7%AF%E6%80%BB%E7%BB%93-1/"/>
    <id>http://yoursite.com/2018/03/03/Python 常用套路总结-1/</id>
    <published>2018-03-02T16:15:14.000Z</published>
    <updated>2018-03-05T13:47:59.350Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>跟着“菜鸟学Python”这个我最喜欢的公众号文章做点练习和巩固基本套路</p><h1 id="0x01-字符串-string-的使用"><a href="#0x01-字符串-string-的使用" class="headerlink" title="0x01 字符串(string)的使用"></a>0x01 字符串(string)的使用</h1><ul><li>主要复习了字符串分割，字符串列表按长度排序的方法</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">text1=<span class="string">'A dict that contains arbitrary metadata for this request. '</span> \</span><br><span class="line">      <span class="string">'This dict is empty for new Requests, '</span> \</span><br><span class="line">      <span class="string">'and is usually populated by different Scrapy components . '</span> \</span><br><span class="line">      <span class="string">'So the data contained in this dict depends on the extensions you have enabled.'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">text2 = text1.split(<span class="string">' '</span>) <span class="comment">#分割字符串,得到下面的由字符串组成的列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#['A', 'dict', 'that', 'contains', 'arbitrary', 'metadata', 'for', 'this', 'request.', 'This', 'dict', 'is', 'empty', 'for', 'new', 'Requests,', 'and', 'is', 'usually', 'populated', 'by', 'different', 'Scrapy', 'components', '.', 'So', 'the', 'data', 'contained', 'in', 'this', 'dict', 'depends', 'on', 'the', 'extensions', 'you', 'have', 'enabled.']</span></span><br><span class="line"></span><br><span class="line">text3 = sorted(text2,key = <span class="keyword">lambda</span> x:len(x),reverse=<span class="keyword">True</span>) <span class="comment">#按分割后的每个字符串长度排序</span></span><br><span class="line"></span><br><span class="line">print(text3[<span class="number">0</span>]) <span class="comment">#得到最长的那个字符串</span></span><br></pre></td></tr></table></figure><ul><li>找单词的长度是5或6，主要复习了列表生成式</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list = [x <span class="keyword">for</span> x <span class="keyword">in</span> text2 <span class="keyword">if</span> <span class="number">6</span>&gt;=len(x)&gt;=<span class="number">5</span>] <span class="comment">#利用列表生成式</span></span><br><span class="line"></span><br><span class="line">print(list)</span><br></pre></td></tr></table></figure><ul><li>统计每个字符串出现的次数，主要复习了Counter类的使用，常用于统计</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter <span class="comment">#统计每个字符串的出现次数</span></span><br><span class="line"></span><br><span class="line">result = dict(Counter(text2))</span><br><span class="line"></span><br><span class="line"><span class="comment">#output:输出字典形式的统计结果</span></span><br><span class="line">&#123;<span class="string">'empty'</span>: <span class="number">1</span>, <span class="string">'metadata'</span>: <span class="number">1</span>, <span class="string">'Scrapy'</span>: <span class="number">1</span>, <span class="string">'by'</span>: <span class="number">1</span>, <span class="string">'dict'</span>: <span class="number">3</span>, <span class="string">'the'</span>: <span class="number">2</span>, <span class="string">'contains'</span>: <span class="number">1</span>, <span class="string">'enabled.'</span>: <span class="number">1</span>, <span class="string">'So'</span>: <span class="number">1</span>, <span class="string">'contained'</span>: <span class="number">1</span>, <span class="string">'.'</span>: <span class="number">1</span>, <span class="string">'is'</span>: <span class="number">2</span>, <span class="string">'in'</span>: <span class="number">1</span>, <span class="string">'new'</span>: <span class="number">1</span>, <span class="string">'that'</span>: <span class="number">1</span>, <span class="string">'components'</span>: <span class="number">1</span>, <span class="string">'Requests,'</span>: <span class="number">1</span>, <span class="string">'different'</span>: <span class="number">1</span>, <span class="string">'This'</span>: <span class="number">1</span>, <span class="string">'depends'</span>: <span class="number">1</span>, <span class="string">'extensions'</span>: <span class="number">1</span>, <span class="string">'on'</span>: <span class="number">1</span>, <span class="string">'and'</span>: <span class="number">1</span>, <span class="string">'you'</span>: <span class="number">1</span>, <span class="string">'this'</span>: <span class="number">2</span>, <span class="string">'request.'</span>: <span class="number">1</span>, <span class="string">'arbitrary'</span>: <span class="number">1</span>, <span class="string">'for'</span>: <span class="number">2</span>, <span class="string">'have'</span>: <span class="number">1</span>, <span class="string">'populated'</span>: <span class="number">1</span>, <span class="string">'A'</span>: <span class="number">1</span>, <span class="string">'usually'</span>: <span class="number">1</span>, <span class="string">'data'</span>: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><ul><li>字符串的拼接, join()函数和字符串拼接符“+”的运用和对比，建议大型拼接用join()</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">names=[<span class="string">'Hello'</span>,<span class="string">' James'</span>,<span class="string">','</span>,<span class="string">' how'</span>,<span class="string">' are'</span>,<span class="string">' you'</span>, <span class="string">'!'</span>]</span><br><span class="line"></span><br><span class="line">print(<span class="string">''</span>.join(names))</span><br><span class="line"></span><br><span class="line">---------------------------</span><br><span class="line">s=<span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> names:</span><br><span class="line">    s=s+i</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure><h1 id="0x02-字典-dict-的使用"><a href="#0x02-字典-dict-的使用" class="headerlink" title="0x02 字典(dict)的使用"></a>0x02 字典(dict)的使用</h1><ul><li>通过key,value排序，这里需要借助 dict.items() 方法以列表方式返回键值对</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">print(result.items())<span class="comment">#得到由元组组成的列表</span></span><br><span class="line"></span><br><span class="line">dict_items([(<span class="string">'empty'</span>, <span class="number">1</span>), (<span class="string">'metadata'</span>, <span class="number">1</span>), (<span class="string">'Scrapy'</span>, <span class="number">1</span>), (<span class="string">'by'</span>, <span class="number">1</span>), (<span class="string">'dict'</span>, <span class="number">3</span>), (<span class="string">'the'</span>, <span class="number">2</span>), (<span class="string">'contains'</span>, <span class="number">1</span>), (<span class="string">'enabled.'</span>, <span class="number">1</span>), (<span class="string">'So'</span>, <span class="number">1</span>), (<span class="string">'contained'</span>, <span class="number">1</span>), (<span class="string">'.'</span>, <span class="number">1</span>), (<span class="string">'is'</span>, <span class="number">2</span>), (<span class="string">'in'</span>, <span class="number">1</span>), (<span class="string">'new'</span>, <span class="number">1</span>), (<span class="string">'that'</span>, <span class="number">1</span>), (<span class="string">'components'</span>, <span class="number">1</span>), (<span class="string">'Requests,'</span>, <span class="number">1</span>), (<span class="string">'different'</span>, <span class="number">1</span>), (<span class="string">'This'</span>, <span class="number">1</span>), (<span class="string">'depends'</span>, <span class="number">1</span>), (<span class="string">'extensions'</span>, <span class="number">1</span>), (<span class="string">'on'</span>, <span class="number">1</span>), (<span class="string">'and'</span>, <span class="number">1</span>), (<span class="string">'you'</span>, <span class="number">1</span>), (<span class="string">'this'</span>, <span class="number">2</span>), (<span class="string">'request.'</span>, <span class="number">1</span>), (<span class="string">'arbitrary'</span>, <span class="number">1</span>), (<span class="string">'for'</span>, <span class="number">2</span>), (<span class="string">'have'</span>, <span class="number">1</span>), (<span class="string">'populated'</span>, <span class="number">1</span>), (<span class="string">'A'</span>, <span class="number">1</span>), (<span class="string">'usually'</span>, <span class="number">1</span>), (<span class="string">'data'</span>, <span class="number">1</span>)])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(sorted(result.items(),key = <span class="keyword">lambda</span> x:x[<span class="number">0</span>],reverse=<span class="keyword">True</span>)) <span class="comment">#以字典的key排序</span></span><br><span class="line"></span><br><span class="line">print(sorted(result.items(),key = <span class="keyword">lambda</span> x:x[<span class="number">1</span>],reverse=<span class="keyword">True</span>)) <span class="comment">#以字典的value排序</span></span><br></pre></td></tr></table></figure><ul><li>有序字典OrderedDict()，按照插入顺序进行输出</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"></span><br><span class="line">orderdict = OrderedDict() <span class="comment">#按输入的顺序有序输出</span></span><br><span class="line"></span><br><span class="line">orderdict[<span class="string">'a'</span>] = <span class="number">1</span></span><br><span class="line">orderdict[<span class="string">'b'</span>] = <span class="number">2</span></span><br><span class="line">orderdict[<span class="string">'c'</span>] = <span class="number">3</span></span><br><span class="line">orderdict[<span class="string">'d'</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">print(orderdict)</span><br><span class="line"></span><br><span class="line">dict = &#123;&#125; <span class="comment">#普通字典不能按输入的顺序输出，无序输出</span></span><br><span class="line"></span><br><span class="line">dict[<span class="string">'a'</span>] = <span class="number">1</span></span><br><span class="line">dict[<span class="string">'b'</span>] = <span class="number">2</span></span><br><span class="line">dict[<span class="string">'c'</span>] = <span class="number">3</span></span><br><span class="line">dict[<span class="string">'d'</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">print(dict)</span><br></pre></td></tr></table></figure><ul><li>字典的取值，建议用get()方法代替传统方法，增加代码健壮性</li></ul><p>传统的取值dict[key],当key不是字典dict的键，会引起异常，但get()当key不存在时会返回空，不会导致程序异常</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict = &#123;&#125;</span><br><span class="line"></span><br><span class="line">dict[<span class="string">'a'</span>] = <span class="number">1</span></span><br><span class="line">dict[<span class="string">'b'</span>] = <span class="number">2</span></span><br><span class="line">dict[<span class="string">'c'</span>] = <span class="number">3</span></span><br><span class="line">dict[<span class="string">'d'</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">print(dict(<span class="string">'e'</span>)) <span class="comment">#报错，程序终止</span></span><br><span class="line"></span><br><span class="line">print(dict.get(<span class="string">'e'</span>)) <span class="comment">#返回none，程序继续运行</span></span><br><span class="line"></span><br><span class="line">print(dict.get(<span class="string">'e'</span>,<span class="string">'not found'</span>)) <span class="comment">#自定义异常信息，返回not found，程序继续运行</span></span><br></pre></td></tr></table></figure><h1 id="0x03-Python操作集合的三架马车-filter、map-reduce、sorted-zip"><a href="#0x03-Python操作集合的三架马车-filter、map-reduce、sorted-zip" class="headerlink" title="0x03 Python操作集合的三架马车(filter、map/reduce、sorted)+zip()"></a>0x03 Python操作集合的三架马车(filter、map/reduce、sorted)+zip()</h1><ul><li>map()/reduce()</li></ul><p>map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line">r = map(f, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"></span><br><span class="line">print(r) <span class="comment">#函数返回一个map object，通过遍历得到每个值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> r:</span><br><span class="line">    print(item)</span><br><span class="line">    print(type(item))</span><br><span class="line"></span><br><span class="line">print(list(map(f,[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])))<span class="comment"># 一句话解决问题</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#output</span></span><br><span class="line">&lt;map object at <span class="number">0x10e7d2d68</span>&gt;</span><br><span class="line"><span class="number">1</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">int</span>'&gt;</span></span><br><span class="line"><span class="class">4</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">int</span>'&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">.......</span></span><br><span class="line"><span class="class"></span></span><br><span class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81]</span><br></pre></td></tr></table></figure><p>reduce()把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算</p><ul><li>filter()</li></ul><p>和map()类似，filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">not_empty</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> s <span class="keyword">and</span> s.strip()</span><br><span class="line"></span><br><span class="line">print(filter(not_empty, [<span class="string">'A'</span>, <span class="string">''</span>, <span class="string">'B'</span>, <span class="keyword">None</span>, <span class="string">'C'</span>, <span class="string">'  '</span>]))</span><br><span class="line"></span><br><span class="line">print(list(filter(not_empty, [<span class="string">'A'</span>, <span class="string">''</span>, <span class="string">'B'</span>, <span class="keyword">None</span>, <span class="string">'C'</span>, <span class="string">'  '</span>])))</span><br><span class="line"></span><br><span class="line"><span class="comment">#output</span></span><br><span class="line"></span><br><span class="line">&lt;filter object at <span class="number">0x100da1cf8</span>&gt; <span class="comment">#返回一个惰性序列</span></span><br><span class="line"></span><br><span class="line">[<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]<span class="comment">#用list()函数遍历求解</span></span><br></pre></td></tr></table></figure><ul><li>sorted()</li></ul><p>sorted()函数就可以对list进行排序,此外，sorted()函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">L = [(<span class="string">'Bob'</span>, <span class="number">75</span>), (<span class="string">'Adam'</span>, <span class="number">92</span>), (<span class="string">'Bart'</span>, <span class="number">66</span>), (<span class="string">'Lisa'</span>, <span class="number">88</span>)]</span><br><span class="line"></span><br><span class="line">print(sorted(L,key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>],reverse=<span class="keyword">True</span>)) <span class="comment">#对数字又高到低排列</span></span><br><span class="line"></span><br><span class="line">print(sorted(L,key=<span class="keyword">lambda</span> x:str(x[<span class="number">0</span>].lower))) <span class="comment">#对名字进行大小写不敏感排列</span></span><br></pre></td></tr></table></figure><ul><li>zip()</li></ul><p>zip()是 Python 的一个内建函数，它接受一系列可迭代的对象作为参数，将对象中对应的元素打包成一个个tuple（元组），然后返回由这些tuples组成的list（列表）。若传入参数的长度不等，则返回 list 的长度和参数中长度最短的对象相同。利用*号操作符，可以将list unzip（解压）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">l2 = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</span><br><span class="line"></span><br><span class="line">l4 = zip(l1,l2) </span><br><span class="line"></span><br><span class="line">print(l4)<span class="comment">#输出惰性序列</span></span><br><span class="line"></span><br><span class="line">l4 = tuple(zip(l1,l2)) <span class="comment">#使用tuple()函数遍历得到元组</span></span><br><span class="line"></span><br><span class="line">print(l4)</span><br><span class="line"></span><br><span class="line">l5 = dict(l4) <span class="comment">#转化为字典</span></span><br><span class="line"></span><br><span class="line">print(l5)</span><br><span class="line"></span><br><span class="line"><span class="comment">#output</span></span><br><span class="line"></span><br><span class="line">&lt;zip object at <span class="number">0x1078e0848</span>&gt;</span><br><span class="line">((<span class="number">1</span>, <span class="string">'a'</span>), (<span class="number">2</span>, <span class="string">'b'</span>), (<span class="number">3</span>, <span class="string">'c'</span>), (<span class="number">4</span>, <span class="string">'d'</span>))</span><br><span class="line">&#123;<span class="number">1</span>: <span class="string">'a'</span>, <span class="number">2</span>: <span class="string">'b'</span>, <span class="number">3</span>: <span class="string">'c'</span>, <span class="number">4</span>: <span class="string">'d'</span>&#125;</span><br></pre></td></tr></table></figure><h1 id="0x04-枚举-enumerate-–-Python内置函数"><a href="#0x04-枚举-enumerate-–-Python内置函数" class="headerlink" title="0x04 枚举(enumerate) – Python内置函数"></a>0x04 枚举(enumerate) – Python内置函数</h1><p>常常会在别人的代码中看到它的身影,它允许我们遍历数据并自动计数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'grapes'</span>, <span class="string">'pear'</span>]</span><br><span class="line"><span class="keyword">for</span> c, value <span class="keyword">in</span> enumerate(my_list,<span class="number">1</span>):</span><br><span class="line">    print(c, value)</span><br><span class="line"></span><br><span class="line">print(enumerate(my_list,<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">print(dict(enumerate(my_list,<span class="number">1</span>)))</span><br><span class="line">print(list(enumerate(my_list,<span class="number">1</span>)))</span><br><span class="line">print(tuple(enumerate(my_list,<span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment">#output:</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> apple</span><br><span class="line"><span class="number">2</span> banana</span><br><span class="line"><span class="number">3</span> grapes</span><br><span class="line"><span class="number">4</span> pear</span><br><span class="line">&lt;enumerate object at <span class="number">0x103d10828</span>&gt; <span class="comment">#输出惰性序列</span></span><br><span class="line">&#123;<span class="number">1</span>: <span class="string">'apple'</span>, <span class="number">2</span>: <span class="string">'banana'</span>, <span class="number">3</span>: <span class="string">'grapes'</span>, <span class="number">4</span>: <span class="string">'pear'</span>&#125;</span><br><span class="line">[(<span class="number">1</span>, <span class="string">'apple'</span>), (<span class="number">2</span>, <span class="string">'banana'</span>), (<span class="number">3</span>, <span class="string">'grapes'</span>), (<span class="number">4</span>, <span class="string">'pear'</span>)]</span><br><span class="line">((<span class="number">1</span>, <span class="string">'apple'</span>), (<span class="number">2</span>, <span class="string">'banana'</span>), (<span class="number">3</span>, <span class="string">'grapes'</span>), (<span class="number">4</span>, <span class="string">'pear'</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;跟着“菜鸟学Python”这个我最喜欢的公众号文章做点练习和巩固基本套路&lt;/p&gt;
&lt;h1 id=&quot;0
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Scrapy使用简介_2</title>
    <link href="http://yoursite.com/2018/03/02/Scrapy%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B-2/"/>
    <id>http://yoursite.com/2018/03/02/Scrapy使用简介-2/</id>
    <published>2018-03-02T10:22:12.000Z</published>
    <updated>2018-03-02T06:03:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>继续介绍Scrapy的其他用法，丰富一下各种姿势</p><h1 id="0x01-Scrapy里面的request对象"><a href="#0x01-Scrapy里面的request对象" class="headerlink" title="0x01 Scrapy里面的request对象"></a>0x01 Scrapy里面的request对象</h1><p>request对象是在Scrapy编写中经常要用到的，你要发送一个请求给调度器爬娶，就必须构造request对象，这个对象里面有各种属性可以使用，例如设置request的header，cookie等，下面是request基础参数：</p><ul><li><p>url —— 请求的url</p></li><li><p>callback —— 请求回来的reseponse处理函数，也叫回调函数</p></li><li><p>headers —— 页面的headers数据</p></li><li><p>cookies —— 设置页面的cookies，下面是一些小例子。<strong>这里没有设置callback，Scrapy会默认调用parse()函数作为callback函数传入</strong></p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#传入多个键值对：列表</span></span><br><span class="line">request_with_cookies = Request(url=<span class="string">"http://www.example.com"</span>,</span><br><span class="line">                               cookies=[&#123;<span class="string">'name'</span>: <span class="string">'currency'</span>,</span><br><span class="line">                                        <span class="string">'value'</span>: <span class="string">'USD'</span>,</span><br><span class="line">                                        <span class="string">'domain'</span>: <span class="string">'example.com'</span>,</span><br><span class="line">                                        <span class="string">'path'</span>: <span class="string">'/currency'</span>&#125;])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#传入单一键值对：字典</span></span><br><span class="line">request_with_cookies = Request(url=<span class="string">"http://www.example.com"</span>,</span><br><span class="line">                               cookies=&#123;<span class="string">'currency'</span>: <span class="string">'USD'</span>, <span class="string">'country'</span>: <span class="string">'UY'</span>&#125;)</span><br></pre></td></tr></table></figure><ul><li>meta —— 最神奇的参数，它是一个字典，可以用来做页面间传值，但同时又一大堆重要的健值，适当设置可以精细化你的request，先看看如何传值</li></ul><p>我对前面的猫眼做了一点改写，把保存了数据的item对象传了meta字典保存：meta = {“key” : item} ，然后通过这个新的Request对象调用的新的url，传到新的callback：parse2 ，然后取出meta里面的数据交给pipeline处理，这样我就实现了数据在页面间传递了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line"></span><br><span class="line">    nodelist = response.xpath(<span class="string">"//div[@class='board-item-main']"</span>)</span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> nodelist:</span><br><span class="line">        item = MaoyanItem()</span><br><span class="line">        item[<span class="string">'name'</span>] = node.xpath(<span class="string">".//a/text()"</span>).extract()[<span class="number">0</span>]</span><br><span class="line">        item[<span class="string">'actors'</span>] = node.xpath(<span class="string">".//p[@class='star']/text()"</span>).extract()[<span class="number">0</span>].split()</span><br><span class="line">        integer = node.xpath(<span class="string">".//i[@class='integer']/text()"</span>).extract()[<span class="number">0</span>]</span><br><span class="line">        fraction = node.xpath(<span class="string">".//i[@class='fraction']/text()"</span>).extract()[<span class="number">0</span>]</span><br><span class="line">        item[<span class="string">'score'</span>] = integer+fraction</span><br><span class="line">        <span class="keyword">if</span> self.offset &lt; <span class="number">10</span>:</span><br><span class="line">            self.offset += <span class="number">10</span></span><br><span class="line">            url = self.base_url + str(self.offset)</span><br><span class="line">            <span class="comment"># url = response.urljoin(str(self.offset))</span></span><br><span class="line">        <span class="comment">#yield response.follow(str(self.offset),callback = self.parse2 ,meta = &#123;"key" : item&#125;,dont_filter = True)</span></span><br><span class="line">        <span class="keyword">yield</span> scrapy.Request(url, callback = self.parse2 ,meta = &#123;<span class="string">"key"</span> : item&#125;,dont_filter = <span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse2</span><span class="params">(self,response)</span>:</span></span><br><span class="line"></span><br><span class="line">    item = response.meta[<span class="string">"key"</span>]</span><br><span class="line">    <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure><p>官方解释meta：</p><blockquote><p>A dict that contains arbitrary metadata for this request. This dict is empty for new Requests, and is usually populated by different Scrapy components (extensions, middlewares, etc). So the data contained in this dict depends on the extensions you have enabled.</p><p>See Request.meta special keys for a list of special meta keys recognized by Scrapy.</p><p>This dict is shallow copied when the request is cloned using the copy() or replace() methods, and can also be accessed, in your spider, from the response.meta attribute.</p></blockquote><p>其他详细的meta特殊字典健值可以参考下面的官方链接：</p><p><a href="https://doc.scrapy.org/en/latest/topics/request-response.html#topics-request-meta" target="_blank" rel="noopener">https://doc.scrapy.org/en/latest/topics/request-response.html#topics-request-meta</a></p><h1 id="0x02-Request对象的源码解读"><a href="#0x02-Request对象的源码解读" class="headerlink" title="0x02 Request对象的源码解读"></a>0x02 Request对象的源码解读</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Request</span><span class="params">(object_ref)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, url, callback=None, method=<span class="string">'GET'</span>, headers=None, body=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                 cookies=None, meta=None, encoding=<span class="string">'utf-8'</span>, priority=<span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 dont_filter=False, errback=None, flags=None)</span>:</span></span><br><span class="line"></span><br><span class="line">        self._encoding = encoding  <span class="comment"># this one has to be set first</span></span><br><span class="line">        self.method = str(method).upper()</span><br><span class="line">        self._set_url(url)</span><br><span class="line">        self._set_body(body)</span><br><span class="line">        <span class="keyword">assert</span> isinstance(priority, int), <span class="string">"Request priority not an integer: %r"</span> % priority</span><br><span class="line">        self.priority = priority</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> callback <span class="keyword">or</span> <span class="keyword">not</span> errback, <span class="string">"Cannot use errback without a callback"</span></span><br><span class="line">        self.callback = callback</span><br><span class="line">        self.errback = errback</span><br><span class="line"></span><br><span class="line">        self.cookies = cookies <span class="keyword">or</span> &#123;&#125;</span><br><span class="line">        self.headers = Headers(headers <span class="keyword">or</span> &#123;&#125;, encoding=encoding)</span><br><span class="line">        self.dont_filter = dont_filter</span><br><span class="line"></span><br><span class="line">        self._meta = dict(meta) <span class="keyword">if</span> meta <span class="keyword">else</span> <span class="keyword">None</span></span><br><span class="line">        self.flags = [] <span class="keyword">if</span> flags <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">else</span> list(flags)</span><br></pre></td></tr></table></figure><p>看到很多对应的东西，例如meta的初始化处理，cookies和headers接受的格式等，建议仔细阅读</p><h1 id="0x03-Scrapy里面的response对象"><a href="#0x03-Scrapy里面的response对象" class="headerlink" title="0x03 Scrapy里面的response对象"></a>0x03 Scrapy里面的response对象</h1><ul><li>基础参数</li></ul><p>url——请求的url<br>body——请求回来的html<br>meta——用来在“页面”之间传递数据<br>headers——页面的headers数据<br>cookies——设置页面的cookies<br>Request——发出这个response的request对象</p><p>基本和Request对象一一对应，主要介绍一下两个新的方法，</p><p>urljoin()：将页面相对路径改为绝对路径 </p><p><strong>follow()：对相对路径进行自动补全，构造出绝对路径，可以说是URLjoin的升级版，因为这个方法直接返回Request对象</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> self.offset &lt; <span class="number">10</span>:</span><br><span class="line">    self.offset += <span class="number">10</span></span><br><span class="line">    url = response.urljoin(str(self.offset)) <span class="comment">#利用urljoin()构造绝对路径，再传入Request</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">yield</span> scrapy.Request(url, callback = self.parse2 ,meta = &#123;<span class="string">"key"</span> : item&#125;,dont_filter = <span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#直接利用response的follow()方法构造Request</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">yield</span> response.follow(str(self.offset),callback = self.parse2 ,meta = &#123;<span class="string">"key"</span> : item&#125;,dont_filter = <span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p>refer：</p><p><a href="https://doc.scrapy.org/en/latest/topics/request-response.html#scrapy.http.Response" target="_blank" rel="noopener">https://doc.scrapy.org/en/latest/topics/request-response.html#scrapy.http.Response</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;继续介绍Scrapy的其他用法，丰富一下各种姿势&lt;/p&gt;
&lt;h1 id=&quot;0x01-Scrapy里面
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>SSL握手过程</title>
    <link href="http://yoursite.com/2018/03/01/SSL%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/03/01/SSL握手过程/</id>
    <published>2018-03-01T15:22:25.000Z</published>
    <updated>2018-03-01T07:26:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下SSL的握手过程，里面涉及到了很多基础概念，例如密码学，证书，PKI等</p><p>详细叙述：</p><p>1、浏览器将自己支持的加密规则(也就是 CipherSuite )发给服务器</p><p>2、服务器端收到请求，然后从客户支持的 CipherSuite 中选出一个应答,并发送给客户端公钥证书和选用的 HASH 算法</p><p>3、客户端收到公钥之后,利用自己的信任的根证书对收到的公钥进行验证.若通过,客户端随机生成对称密钥 (Pre-Master secret),然后使用公钥对对称密钥进行加密,并计算连接中全部报文信息的 hash ,再利用生成的对称密钥对 hash 值加密,然后把公钥加密的对称密钥及对称密钥加密的 hash 值发送给服务器.</p><p>4、服务器利用自己的私钥对利用公钥加密的对称密钥进行解密,得到对称密钥. 再利用对称密钥解密 hash 值,对 hash 值进行验证.在验证成功后，会返回给客户端 Finish 报文。（至此，ssl 连接建立成功）</p><p>5、ssl 连接建立完成之后信息的传输加密过程是这样的:</p><p>客户端:先用对称密钥加密要传输的信息,再利用 hash 算法得出加了密的信息的 hash 值.再利用公钥对 hash 值进行加密,之后把对称密钥加密了的信息和利用公钥加密后信息的 hash 值,传输给服务器. </p><p>服务器: 与客户端基本相同，不过把公钥加密换做私钥加密。</p><p>refer:</p><p><a href="http://mp.weixin.qq.com/s/W620Pdu6qvoqjacSRPRVyg" target="_blank" rel="noopener">http://mp.weixin.qq.com/s/W620Pdu6qvoqjacSRPRVyg</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录一下SSL的握手过程，里面涉及到了很多基础概念，例如密码学，证书，PKI等&lt;/p&gt;
&lt;p&gt;详细叙述：&lt;/p&gt;
&lt;p&gt;1、浏览器将自己支持的加密规则(也就是 CipherSuite )发给服务器&lt;/p&gt;
&lt;p&gt;2、服务器端收到请求，然后从客户支持的 CipherSuite
      
    
    </summary>
    
    
      <category term="Web security" scheme="http://yoursite.com/tags/Web-security/"/>
    
  </entry>
  
  <entry>
    <title>Scrapy使用简介_1</title>
    <link href="http://yoursite.com/2018/02/28/Scrapy%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B-1/"/>
    <id>http://yoursite.com/2018/02/28/Scrapy使用简介-1/</id>
    <published>2018-02-27T17:22:12.000Z</published>
    <updated>2018-03-02T02:54:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>上一篇笔记记录了学习Python爬虫的简单思路，然后就要对Python爬虫框架进行基本使用了，玩玩更健康</p><h1 id="0x01-Scrapy基本介绍"><a href="#0x01-Scrapy基本介绍" class="headerlink" title="0x01 Scrapy基本介绍"></a>0x01 Scrapy基本介绍</h1><ul><li>基本数据流图解：</li></ul><p><img src="/images/scrapyworkflow.png" alt="数据流图"></p><ul><li>基本数据流程：</li></ul><ol><li>Spiders发送第一个URL给引擎</li><li>引擎从Spider中获取到第一个要爬取的URL后，在调度器(Scheduler)以Request调度</li><li>调度器把需要爬取的request返回给引擎</li><li>引擎将request通过下载中间件发给下载器(Downloader)去互联网下载数据</li><li>一旦数据下载完毕，下载器获取由互联网服务器发回来的Response，并将其通过下载中间件发送给引擎</li><li>引擎从下载器中接收到Response并通过Spider中间件发送给Spider处理</li><li>Spider处理Response并从中返回匹配到的Item及(跟进的)新的Request给引擎</li><li>引擎将(Spider返回的)爬取到的Item给Item Pipeline做数据处理或者入库保存，将(Spider返回的)Request给调度器入队列</li><li>(从第三步)重复直到调度器中没有更多的request</li></ol><ul><li>简单的说：</li></ul><p>引擎是大脑，负责在各组件中调度传递信息。我们要编写的几个主要组件就是spider，pipeline和中间件</p><ul><li>项目结构：</li></ul><p><img src="/images/structure.png" alt="项目结构图"></p><ul><li>编程思路：</li></ul><p>还是以猫眼这个简单例子，这次使用了scrapy来实现，首先编写maoyan_top.py,实现爬虫主程序，也就是定义一个爬虫，然后编写items.py定义一个存储数据的数据结构，类似dict，最后编写pipelines.py实现数据存储，这就是最简单的scrapy实现思路</p><ul><li>首先编写maoyan_top.py，主要就是编写MaoyanTopSpider类，这个类继承scrapy.Spider，定义好基本URL的数据后，就是主力编写parse函数，这个函数就是负责解析数据的。注意这里我yield了item给pipelines.py处理，yield了scrapy.Request给调度器进行翻页爬取</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> ..items <span class="keyword">import</span> MaoyanItem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaoyanTopSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">'maoyan_top'</span></span><br><span class="line">    allowed_domains = [<span class="string">'maoyan.com'</span>]</span><br><span class="line">    base_url = <span class="string">"https://maoyan.com/board/4?offset="</span></span><br><span class="line">    offset = <span class="number">0</span></span><br><span class="line">    start_urls = [base_url + str(offset)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line"></span><br><span class="line">        nodelist = response.xpath(<span class="string">"//div[@class='board-item-main']"</span>)</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> nodelist:</span><br><span class="line">            item = MaoyanItem()</span><br><span class="line">            item[<span class="string">'name'</span>] = node.xpath(<span class="string">".//a/text()"</span>).extract()[<span class="number">0</span>]</span><br><span class="line">            item[<span class="string">'actors'</span>] = node.xpath(<span class="string">".//p[@class='star']/text()"</span>).extract()[<span class="number">0</span>].split()</span><br><span class="line">            integer = node.xpath(<span class="string">".//i[@class='integer']/text()"</span>).extract()[<span class="number">0</span>]</span><br><span class="line">            fraction = node.xpath(<span class="string">".//i[@class='fraction']/text()"</span>).extract()[<span class="number">0</span>]</span><br><span class="line">            item[<span class="string">'score'</span>] = integer+fraction</span><br><span class="line">            <span class="keyword">yield</span> item</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.offset &lt; <span class="number">100</span>:</span><br><span class="line">            self.offset += <span class="number">10</span></span><br><span class="line">            url = self.base_url+str(self.offset)</span><br><span class="line">            <span class="keyword">yield</span> scrapy.Request(url,callback = self.parse)</span><br></pre></td></tr></table></figure><ul><li>然后编写items.py定义一个存储数据的数据结构给上面的parse函数使用,非常简单我就定义了三个字段，分别为电影的名字，评分和演员</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaoyanItem</span><span class="params">(scrapy.Item)</span>:</span></span><br><span class="line">    <span class="comment"># define the fields for your item here like:</span></span><br><span class="line">    name = scrapy.Field()</span><br><span class="line">    actors = scrapy.Field()</span><br><span class="line">    score = scrapy.Field()</span><br></pre></td></tr></table></figure><ul><li>最后编写pipelines.py进行存储数据，这里要注意parse函数yield出来的item会到达这里处理</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaoyanPipeline</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open_spider</span><span class="params">(self,spider)</span>:</span></span><br><span class="line">        print(type(spider))</span><br><span class="line">        print(<span class="string">"open file"</span>)</span><br><span class="line"></span><br><span class="line">        self.f = open(<span class="string">'/Users/Rick7/Desktop/items.json'</span>, <span class="string">'w+'</span>,encoding=<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line"></span><br><span class="line">        line = json.dumps(dict(item),ensure_ascii=<span class="keyword">False</span>) + <span class="string">"\n"</span></span><br><span class="line">        self.f.write(line)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close_spider</span><span class="params">(self,spider)</span>:</span></span><br><span class="line"></span><br><span class="line">        self.f.close()</span><br><span class="line">        print(<span class="string">"close file"</span>)</span><br></pre></td></tr></table></figure><ul><li>配置好setting文件激活管道，程序完成</li></ul><h1 id="0x02-总结"><a href="#0x02-总结" class="headerlink" title="0x02 总结"></a>0x02 总结</h1><ul><li>要学scrapy首先要搞清楚这个框架的数据流</li><li>建议阅读官方文档了解其中的类和方法</li><li>后面还会继续学习高级一点点的知识，例如url去重，中间件的使用等</li></ul><p>refer：</p><p><a href="https://doc.scrapy.org/en/latest/index.html" target="_blank" rel="noopener">https://doc.scrapy.org/en/latest/index.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;上一篇笔记记录了学习Python爬虫的简单思路，然后就要对Python爬虫框架进行基本使用了，玩玩更
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫小总结</title>
    <link href="http://yoursite.com/2018/02/28/Python%E7%88%AC%E8%99%AB%E5%B0%8F%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/02/28/Python爬虫小总结/</id>
    <published>2018-02-27T16:54:37.000Z</published>
    <updated>2018-02-28T03:44:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>最近玩了一下Python的爬虫，感觉这个东西对Python初学者还是挺友好的，适合入门Python</p><h1 id="0x01-简单编程套路"><a href="#0x01-简单编程套路" class="headerlink" title="0x01 简单编程套路"></a>0x01 简单编程套路</h1><ul><li>requests 库发送请求</li><li>Beautifulsoap,Xpath,Pyquiry,正则，等解释库提取数据</li><li>储存数据到文件或者数据库</li></ul><p>下面通过一个简单的对猫眼榜单的爬取代码体现上面的思路：</p><ul><li>get_onepage(url)函数发送请求，主要使用requests库</li><li>parse_onepage(content)函数负责解释和提取数据，主要使用了Beautifulsoap</li><li>save_csv(content)函数就是把数据保存到CSV文件</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_onepage</span><span class="params">(url)</span>:</span></span><br><span class="line">    headers = &#123;<span class="string">'user-agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) '</span></span><br><span class="line">                             <span class="string">'Chrome/60.0.3112.113 Safari/537.36'</span>&#125;</span><br><span class="line">    raw_content = requests.get(url,headers=headers)</span><br><span class="line">    raw_content.encoding = <span class="string">'utf-8'</span></span><br><span class="line">    <span class="comment"># print(raw_content.text)</span></span><br><span class="line">    <span class="keyword">return</span> raw_content.text</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_onepage</span><span class="params">(content)</span>:</span></span><br><span class="line">    soup = BeautifulSoup(content,<span class="string">'lxml'</span>)</span><br><span class="line">    movie_item = soup.find_all(<span class="string">'dd'</span>)</span><br><span class="line">    <span class="keyword">for</span> items <span class="keyword">in</span> movie_item:</span><br><span class="line">        dict = &#123;<span class="string">'index'</span>: <span class="string">''</span>, <span class="string">'title'</span>: <span class="string">''</span>, <span class="string">'star'</span>: <span class="string">''</span>&#125;</span><br><span class="line">        movie_index = items.find(<span class="string">'i'</span>,class_ = <span class="string">"board-index"</span>)</span><br><span class="line">        dict[<span class="string">'index'</span>] = movie_index.get_text()</span><br><span class="line">        movie_title = items.find(<span class="string">'p'</span>,attrs = &#123;<span class="string">'class'</span>: <span class="string">'name'</span>&#125;)</span><br><span class="line">        dict[<span class="string">'title'</span>] = movie_title.find(<span class="string">'a'</span>).get_text()</span><br><span class="line">        movie_actor = items.find(<span class="string">'p'</span>,attrs = &#123;<span class="string">'class'</span>: <span class="string">'star'</span>&#125;)</span><br><span class="line">        dict[<span class="string">'star'</span>] = movie_actor.get_text().strip()</span><br><span class="line">        <span class="keyword">yield</span> dict</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_csv</span><span class="params">(content)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">"/Users/Rick7/Desktop/data.csv"</span>,<span class="string">'a'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line">        fieldnames = [<span class="string">'index'</span>, <span class="string">'title'</span>, <span class="string">'star'</span>]</span><br><span class="line">        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)</span><br><span class="line">        writer.writeheader()</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> parse_onepage(content):</span><br><span class="line">            writer.writerow(item)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(offset_number)</span>:</span></span><br><span class="line">    url = <span class="string">"http://maoyan.com/board/4?offset="</span>+str(offset_number)</span><br><span class="line">    html = get_onepage(url)</span><br><span class="line">    save_csv(html)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        i=i*<span class="number">10</span></span><br><span class="line">        main(i)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h1 id="0x02-总结"><a href="#0x02-总结" class="headerlink" title="0x02 总结"></a>0x02 总结</h1><ul><li>这是最简单的爬虫小程序，从中要体会里面思路</li><li>上面的小程序只针对静态页面，对于动态的Ajax加载，使用过selenium，不过感觉十分慢和不友好，建议抓包找去真实的URL比较实际</li><li>比起beautifulsoap，感觉xpath提取数据更加高效简洁</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;最近玩了一下Python的爬虫，感觉这个东西对Python初学者还是挺友好的，适合入门Python&lt;
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>OAuth 2.0 笔记_1</title>
    <link href="http://yoursite.com/2018/02/13/OAuth-2-0-%E7%AC%94%E8%AE%B01/"/>
    <id>http://yoursite.com/2018/02/13/OAuth-2-0-笔记1/</id>
    <published>2018-02-13T15:47:52.000Z</published>
    <updated>2018-03-15T07:56:42.163Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>最近OAuth又出了一个漏洞，根据漏洞介绍这个漏洞不在OAuth协议，而在用户的部署上，等详细分析吧，漏洞链接如下，借此机会复习一下OAuth2.0</p><p><a href="http://www.cnvd.org.cn/flaw/show/CNVD-2018-01622" target="_blank" rel="noopener">http://www.cnvd.org.cn/flaw/show/CNVD-2018-01622</a></p><h1 id="0x01-OAuth-2-0-流程"><a href="#0x01-OAuth-2-0-流程" class="headerlink" title="0x01 OAuth 2.0 流程"></a>0x01 OAuth 2.0 流程</h1><p>详细的交换就不写了，网上一大堆，简单总结两句授权码模式（authorization code），包括了(用户A，网站B，GitHub(信息提供者,resource owner))</p><p>前提：网站B要想得到GitHub认证，必须先和GitHub协商可以取得什么权限等事情，这时候GitHub认可了网站B的合法性并同意网站B可以使用GitHub的相关用户资料，并给了网站B：Client Id 和 Client Secret。</p><ol><li><p>用户A想登陆网站B，但不想注册，所以点击了下面的GitHub图标，想通过GitHub账号登陆网站B,这时候就触发了OAuth认证</p></li><li><p>网站带着GitHub颁发的Client Id 到 ”<a href="https://github.com/login/oauth/authorize“" target="_blank" rel="noopener">https://github.com/login/oauth/authorize“</a> 请求权限，这时候会显示网站B从GitHub会取得什么权限，如果用户觉得ok就点击授权，不ok就拒绝，认证结束</p></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /authorize?response_type=code&amp;client_id=s6BhdRkqt3&amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1</span><br><span class="line">Host: github.com</span><br></pre></td></tr></table></figure><ol><li>当如何点击授权后，页面会跳转到网站B预先设定的 redirect_uri 并附带一个授权码(code)</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 302 Found</span><br><span class="line">Location: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA</span><br></pre></td></tr></table></figure><ol><li>用户A的浏览器得到一个302的回复，然后重定向到网站B指定redirect_uri，网站B从而得到了code，然后网站B拿着 code 和能够标识个人身份的 “client_id “,client_secret“ 去拜访 github，拿到access_token，这里的“client_id “,client_secret“ 是Github判断这个请求的合法性依据，”,client_secret“这个是网站B独有的。</li></ol><figure class="highlight"><table><tr><td class="code"><pre><span class="line">POST //github.com/login/oauth/access_token</span><br><span class="line">params = &#123;</span><br><span class="line">  code: "xxx",</span><br><span class="line">  client_id: "xxx",</span><br><span class="line">  client_secret: "xxx",</span><br><span class="line">  redirect_uri: "http://my-website.com"</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">response = &#123;</span><br><span class="line">  access_token: "e72e16c7e42f292c6912e7710c838347ae178b4a"</span><br><span class="line">  scope: "user,gist"</span><br><span class="line">  token_type: "bearer",</span><br><span class="line">  refresh_token: "xxxx"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>从上面的response中得到了access_token，相应的scope，网站B可以凭借这个token来取得用户在GitHub的信息，至于能够取得的信息范围就由scope来定义了，用户A可以使用GitHub的账号登陆网站B了。这就是授权码模式的简单描述。</li></ol><h1 id="0x02-已知的安全问题-CSRF"><a href="#0x02-已知的安全问题-CSRF" class="headerlink" title="0x02 已知的安全问题-CSRF"></a>0x02 已知的安全问题-CSRF</h1><ol><li>漏洞原理</li></ol><blockquote><p>这个问题的关键点在于，OAuth2的认证流程是分为好几步来完成的，在图1中的第4步，第三方应用在收到一个GET请求时，除了能知道当前用户的cookie，以及URL中的Authorization Code之外，难以分辨出这个请求到底是用户本人的意愿，还是攻击者利用用户的身份伪造出来的请求。 于是乎，攻击者就能使用移花接木的手段，提前准备一个含有自己的Authorization Code的请求，并让受害者的浏览器来接着完成后续的令牌申请流程。(知乎转载)</p></blockquote><ol><li>详细分析</li></ol><p>回顾一下上面简单总结的第四步：</p><blockquote><p>用户A的浏览器得到一个302的回复，然后重定向到网站B指定redirect_uri，网站B从而得到了code，然后网站B拿着 code 和能够标识个人身份的 “client_id “,client_secret“ 去拜访 github，拿到access_token，这里的“client_id “,client_secret“ 是Github判断这个请求的合法性依据，”,client_secret“这个是网站B独有的。</p></blockquote><p>这里面有个问题就是用户A的浏览器根据302状态码把code redirect到网站B,这个code是和将要登录网站B的账号关联的，如果攻击者替换了用户A这个请求，把里面的code换成攻击者账号的，然后网站B继续完成OAuth的认证流程，这会造成用户A在网站B的账号和攻击者的GitHub账号绑定了，攻击者只要在网站B通过GitHub登录就能成功登录用户A在网站B的账号了。<strong>因此这个漏洞本质是欺骗网站B</strong></p><p><img src="/images/CSRF OAuth.jpg" alt="攻击图"></p><ol><li>攻击成功条件</li></ol><ul><li>用户A的User Session是valid的</li><li>OAuth2提供者颁发的Authorization Code有效期很短，OAuth2官方推荐的时间是不大于10分钟，所以要快</li><li>一个Authorization Code只能被使用一次</li></ul><h1 id="0x03-如何防御"><a href="#0x03-如何防御" class="headerlink" title="0x03 如何防御"></a>0x03 如何防御</h1><p>刚才提到了，既然这个漏洞本质是欺骗网站B，那么要做防御的当然在网站B了，网站B要确保用户发去GitHub的授权码(Authorization Code)申请和用户redirect回来的授权码是一致的，怎么做呢？就是加一个唯一的，随机的参数state来确保唯一性</p><ul><li>首先，网站B redirect 用户A到GitHub申请授权码的时候带上”state=xyz“参数</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /authorize?response_type=code&amp;client_id=s6BhdRkqt3&amp;state=xyz</span><br><span class="line">        &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br></pre></td></tr></table></figure><ul><li>然后，用户A的浏览器收到GitHub发来的302带着授权码redirect回到B网站时，GitHub会根据申请code时的请求在302的location中带上”state=xyz“</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 302 Found</span><br><span class="line">Location: https://B.com/cb?code=SplxlOBeZQQYbYS6WxSbIA</span><br><span class="line">          &amp;state=xyz</span><br></pre></td></tr></table></figure><ul><li><p>这样网站B就可以根据state参数确认这个code对应哪一个用户了</p></li><li><p>要避免遭受本文提到的CSRF攻击问题，需要第三方应用正确的使用state参数</p></li></ul><h1 id="Refer-link"><a href="#Refer-link" class="headerlink" title="Refer link"></a>Refer link</h1><p><a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html</a></p><p><a href="https://aaronparecki.com/oauth-2-simplified/" target="_blank" rel="noopener">https://aaronparecki.com/oauth-2-simplified/</a></p><p><a href="https://www.zhihu.com/question/19781476" target="_blank" rel="noopener">https://www.zhihu.com/question/19781476</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;最近OAuth又出了一个漏洞，根据漏洞介绍这个漏洞不在OAuth协议，而在用户的部署上，等详细分析吧
      
    
    </summary>
    
    
      <category term="Web security" scheme="http://yoursite.com/tags/Web-security/"/>
    
  </entry>
  
  <entry>
    <title>Same-Origin Protection (SOP)</title>
    <link href="http://yoursite.com/2018/02/09/Same-Origin-Protection-SOP/"/>
    <id>http://yoursite.com/2018/02/09/Same-Origin-Protection-SOP/</id>
    <published>2018-02-09T10:39:27.000Z</published>
    <updated>2018-02-28T03:46:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-什么是同源策略-SOP"><a href="#0x00-什么是同源策略-SOP" class="headerlink" title="0x00 什么是同源策略(SOP)"></a>0x00 什么是同源策略(SOP)</h1><p>在Web安全中，SOP是一个非常重要安全策略，必须要弄懂才能对很多攻击有更加清晰的理解，那什么是同源策略呢？下面是我本人的理解：</p><p><strong>同源策略是一个浏览器中内建的安全策略，它确保不同源的网站不能互相作用或者互相交换。</strong></p><ul><li><p>不同源指的是协议(https,http,ftp…),不同端口(80,443,22,21),不同域名。</p></li><li><p>不能互相作用或者互相交换是指：A网站即使和B网站不同源，但仍然可以发送request到B网站，这个请求在B网站还是会处理的，但A网站不能读取response，总结一句就是：跨域请求是可以发去的，但是请求响应response被浏览器堵塞了，所以说同源策略是限制了不同源的读，但不限制不同源的写</p></li><li><p>由于同源策略的限制，跨域的ajax请求不会带cookie，然而script/iframe/img等标签却是支持跨域的，所以在请求的时候是会带上cookie的，这使得CSRF攻击有可乘之机</p></li></ul><h1 id="0x01-CSRF攻击"><a href="#0x01-CSRF攻击" class="headerlink" title="0x01 CSRF攻击"></a>0x01 CSRF攻击</h1><ul><li>由于同源策略的限制，跨域的ajax请求不会带cookie，然而script/iframe/img等标签却是支持跨域的，所以在请求的时候是会带上cookie的。如果用户登陆了Abank.com，那么cookie里面就有了tocken，同时又打开了另外一个标签页访问了evil.com，这个网页里面有一个iframe:</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://Abank.com/app/transferFunds?amount=1500&amp;destinationAccount="</span><span class="attr">attackeraccountnumber</span>" &gt;</span></span><br></pre></td></tr></table></figure><ul><li>防CSRF攻击的策略就是将token添加到请求的参数里面，也就是说每个需要验证身份的请求都要显式地带上token值,目的就是让请求不可预知，就算攻击者得到了你的登录token，也没有办法构造转账的请求，因为转账的请求带有一个不可预知的，随机的token作为保护，当然也可以加入一些人机交换，例如验证码之类的</li></ul><h1 id="0x02-Cross-domain-和-Silverlight-的跨越配置文件"><a href="#0x02-Cross-domain-和-Silverlight-的跨越配置文件" class="headerlink" title="0x02 Cross-domain 和 Silverlight 的跨越配置文件"></a>0x02 Cross-domain 和 Silverlight 的跨越配置文件</h1><p>这两个配置文件必须设置严格，防止不必要跨域</p><h1 id="Refer-link"><a href="#Refer-link" class="headerlink" title="Refer link"></a>Refer link</h1><p><a href="https://www.gracefulsecurity.com/cross-domain-flash-and-silverlight-crossdomain-xml/" target="_blank" rel="noopener">https://www.gracefulsecurity.com/cross-domain-flash-and-silverlight-crossdomain-xml/</a></p><p><a href="https://www.gracefulsecurity.com/what-is-cross-site-request-forgery/" target="_blank" rel="noopener">https://www.gracefulsecurity.com/what-is-cross-site-request-forgery/</a></p><p><a href="http://www.veracode.com/security/csrf" target="_blank" rel="noopener">http://www.veracode.com/security/csrf</a></p><p><a href="http://yincheng.site/cross-domain" target="_blank" rel="noopener">http://yincheng.site/cross-domain</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x00-什么是同源策略-SOP&quot;&gt;&lt;a href=&quot;#0x00-什么是同源策略-SOP&quot; class=&quot;headerlink&quot; title=&quot;0x00 什么是同源策略(SOP)&quot;&gt;&lt;/a&gt;0x00 什么是同源策略(SOP)&lt;/h1&gt;&lt;p&gt;在Web安全中，SOP是
      
    
    </summary>
    
    
      <category term="Web security" scheme="http://yoursite.com/tags/Web-security/"/>
    
  </entry>
  
  <entry>
    <title>XXE 攻击(2)</title>
    <link href="http://yoursite.com/2018/02/08/XXE-%E6%94%BB%E5%87%BB%E2%80%94%E2%80%942/"/>
    <id>http://yoursite.com/2018/02/08/XXE-攻击——2/</id>
    <published>2018-02-07T20:57:37.000Z</published>
    <updated>2018-02-28T03:46:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>在上一遍文章中提到了XML的格式定义DTD存在外部实体引用攻击，这次来学习一下主流的XML格式定义XML Schema，刚好最近上了java的spring培训，里面定义beans的时候主要配置的就是XML文档，所以也是时候再学学xml的相关知识了，网上很多相关文章，主要记录一些和安全相关的设置吧</p><h1 id="0x01-XML-Schema-基础"><a href="#0x01-XML-Schema-基础" class="headerlink" title="0x01 XML Schema 基础"></a>0x01 XML Schema 基础</h1><p>XML Schema 描述了 XML文档的结构，也是由 XML 编写，其中Schema可以理解为约束、概要，但不推荐使用中文进行记忆，Schema就是Schema</p><ul><li>一个普通的xml文档：</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">to</span>&gt;</span>Tove<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">from</span>&gt;</span>Jani<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">heading</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span>Don't forget me this weekend!<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>一个XML Schema定义</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">xs:schema</span> <span class="attr">xmlns:xs</span>=<span class="string">"http://www.w3.org/2001/XMLSchema"</span></span></span><br><span class="line"><span class="tag"><span class="attr">targetNamespace</span>=<span class="string">"http://www.w3schools.com"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns</span>=<span class="string">"http://www.w3schools.com"</span></span></span><br><span class="line"><span class="tag"><span class="attr">elementFormDefault</span>=<span class="string">"qualified"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">"note"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">xs:complexType</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xs:sequence</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">"to"</span> <span class="attr">type</span>=<span class="string">"xs:string"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">"from"</span> <span class="attr">type</span>=<span class="string">"xs:string"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">"heading"</span> <span class="attr">type</span>=<span class="string">"xs:string"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">"body"</span> <span class="attr">type</span>=<span class="string">"xs:string"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xs:sequence</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">xs:complexType</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xs:element</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">xs:schema</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>第一句代表xml版本号，1.0版本</li><li><xs:schema> </xs:schema> schema的根元素</li><li>xmlns:xs=”<a href="http://www.w3.org/2001/XMLSchema" target="_blank" rel="noopener">http://www.w3.org/2001/XMLSchema</a>“ 代表schema 中用到的元素和数据类型来自命名空间 “<a href="http://www.w3.org/2001/XMLSchema&quot;。同时它还规定了来自命名空间" target="_blank" rel="noopener">http://www.w3.org/2001/XMLSchema&quot;。同时它还规定了来自命名空间</a> “<a href="http://www.w3.org/2001/XMLSchema" target="_blank" rel="noopener">http://www.w3.org/2001/XMLSchema</a>“ 的元素和数据类型应该使用前缀 xs：</li><li>targetNamespace=”<a href="http://www.runoob.com" target="_blank" rel="noopener">http://www.runoob.com</a>“ 显示被此 schema 定义的元素 (note, to, from, heading, body) 来自命名空间： “<a href="http://www.runoob.com&quot;。" target="_blank" rel="noopener">http://www.runoob.com&quot;。</a></li><li>xmlns=”<a href="http://www.runoob.com" target="_blank" rel="noopener">http://www.runoob.com</a>“ xmlns=”<a href="http://www.runoob.com" target="_blank" rel="noopener">http://www.runoob.com</a>“</li><li>elementFormDefault=”qualified” 指出任何 XML 实例文档所使用的且在此 schema 中声明过的元素必须被命名空间限定。</li><li>后面是各种元素定义，数据类型定义等</li></ol><p>详细的关于XML Schema定义可以参考下面的链接</p><p><a href="http://www.runoob.com/schema/schema-schema.html" target="_blank" rel="noopener">http://www.runoob.com/schema/schema-schema.html</a></p><ul><li>xml文档引用上面定义的Schema:note.xsd(这是重点要理解的)</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">note</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns</span>=<span class="string">"http://www.w3schools.com"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.w3schools.com note.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">to</span>&gt;</span>Tove<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">from</span>&gt;</span>Jani<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">heading</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span>Don't forget me this weekend!<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>xmlns=”<a href="http://www.w3schools.com" target="_blank" rel="noopener">http://www.w3schools.com</a>“ 定义了默认的命名空间，如果没有定义其他的命名空间，XML 文档会使用这个作为schema 验证器</li><li>xmlns:xsi=”<a href="http://www.w3.org/2001/XMLSchema-instance" target="_blank" rel="noopener">http://www.w3.org/2001/XMLSchema-instance</a>“ 定义了一个指定的命名空间，并把这个空间 alias - xsi(别名)</li><li>xsi:schemaLocation=”<a href="http://www.w3schools.com" target="_blank" rel="noopener">http://www.w3schools.com</a> note.xsd”&gt; 定义了xsi的schemaLocation属性，格式为：namespace and XSD-location-URI，中间用换行符或者空格作为分隔符</li></ol><p>下来来自stackoverflow的详细解释，好明白的讲解：</p><p><a href="https://stackoverflow.com/questions/34202967/xmlns-xmlnsxsi-xsischemalocation-and-targetnamespace" target="_blank" rel="noopener">https://stackoverflow.com/questions/34202967/xmlns-xmlnsxsi-xsischemalocation-and-targetnamespace</a></p><h1 id="0x02-XML-Schema攻击的分类"><a href="#0x02-XML-Schema攻击的分类" class="headerlink" title="0x02 XML Schema攻击的分类"></a>0x02 XML Schema攻击的分类</h1><p>XML Schema攻击分为,下面的没有怎么研究，希望日后可以补充，都是看家人的总结来的</p><p>1.schemaLocation</p><p>2.noNamespaceSchemaLocation</p><p>3.XInclude。</p><p>4.XSLT 攻击</p><p>refer link</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzIwNDI4MzAwOA==&amp;mid=2650524176&amp;idx=1&amp;sn=e1f8ebb128ae248d69e2947e4ac9bcf2&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzIwNDI4MzAwOA==&amp;mid=2650524176&amp;idx=1&amp;sn=e1f8ebb128ae248d69e2947e4ac9bcf2&amp;scene=21#wechat_redirect</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;在上一遍文章中提到了XML的格式定义DTD存在外部实体引用攻击，这次来学习一下主流的XML格式定义X
      
    
    </summary>
    
    
      <category term="Web security" scheme="http://yoursite.com/tags/Web-security/"/>
    
  </entry>
  
  <entry>
    <title>XXE 攻击</title>
    <link href="http://yoursite.com/2018/02/06/XXE-%E6%94%BB%E5%87%BB/"/>
    <id>http://yoursite.com/2018/02/06/XXE-攻击/</id>
    <published>2018-02-06T11:14:30.000Z</published>
    <updated>2018-02-28T03:47:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-什么是-XXE"><a href="#0x00-什么是-XXE" class="headerlink" title="0x00 什么是 XXE"></a>0x00 什么是 XXE</h1><p>XXE：XML External Entity，即外部实体攻击,其本质是利用应用过滤不严格进行xml语句的注入攻击，感觉应该属于注入攻击的一种，</p><h1 id="0x01-XML-文档的DTD"><a href="#0x01-XML-文档的DTD" class="headerlink" title="0x01 XML 文档的DTD"></a>0x01 XML 文档的DTD</h1><p>文档类型定义（DTD）可定义合法的XML文档构建模块。它使用一系列合法的元素来定义文档的结构，包括定义了XML文档的元素(!ELEMENT)，属性(!ATTLIST)，实体(!ENTITY),<strong>其中实体的定义为：实体是用于定义引用普通文本或特殊字符的快捷方式的变量。类似于定义了一个变量</strong></p><p>详细的DTD定义可以参考下面的链接：</p><p><a href="http://www.runoob.com/dtd/dtd-building.html" target="_blank" rel="noopener">http://www.runoob.com/dtd/dtd-building.html</a></p><h1 id="x03-内部实体和外部实体"><a href="#x03-内部实体和外部实体" class="headerlink" title="x03 内部实体和外部实体"></a>x03 内部实体和外部实体</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">DTD 定义内部实体</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">!ENTITY</span> <span class="attr">writer</span> "<span class="attr">Donald</span> <span class="attr">Duck.</span>"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">!ENTITY</span> <span class="attr">copyright</span> "<span class="attr">Copyright</span> <span class="attr">runoob.com</span>"&gt;</span></span><br><span class="line"></span><br><span class="line">XML引用上面实体的内部定义：</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">author</span>&gt;</span>&amp;writer;&amp;copyright;<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">DTD 定义外部实体，加了一个SYSTEM关键字</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">!ENTITY</span> <span class="attr">writer</span> <span class="attr">SYSTEM</span> "<span class="attr">http:</span>//<span class="attr">www.runoob.com</span>/<span class="attr">entities.dtd</span>"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">!ENTITY</span> <span class="attr">copyright</span> <span class="attr">SYSTEM</span> "<span class="attr">http:</span>//<span class="attr">www.runoob.com</span>/<span class="attr">entities.dtd</span>"&gt;</span></span><br><span class="line"></span><br><span class="line">XML引用上面定义的外部实体</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">author</span>&gt;</span>&amp;writer;&amp;copyright;<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="0x02-XXE-攻击PAYLOAD"><a href="#0x02-XXE-攻击PAYLOAD" class="headerlink" title="0x02 XXE 攻击PAYLOAD"></a>0x02 XXE 攻击PAYLOAD</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE foo [</span></span><br><span class="line"><span class="meta">    &lt;!ELEMENT foo ANY &gt;</span></span><br><span class="line"><span class="meta">    &lt;!ENTITY  xxe SYSTEM "file:///c:/windows/win.ini" &gt; #定义了外部实体引用</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">foo</span>&gt;</span>&amp;xxe;<span class="tag">&lt;/<span class="name">foo</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="0x02-XXE攻击原理"><a href="#0x02-XXE攻击原理" class="headerlink" title="0x02 XXE攻击原理"></a>0x02 XXE攻击原理</h1><p>在 XML1.0 标准里，XML文档里的实体的标识符可以访问本地远程内容，如果在外部实体引用的过程中，注入恶意代码，即可引发信息泄露等安全问题。</p><p>比如上述示例中所演示的 URI，即可读取 passwd 中的敏感信息。</p><h1 id="0x03-攻击方式"><a href="#0x03-攻击方式" class="headerlink" title="0x03 攻击方式"></a>0x03 攻击方式</h1><ul><li><p>有回显</p></li><li><p>无回显</p></li></ul><p>具体就不继续了，网上一大堆文章，反正了解了核心概念就可以了，其他利用姿势自行Google</p><h1 id="0x04-如何防御"><a href="#0x04-如何防御" class="headerlink" title="0x04 如何防御"></a>0x04 如何防御</h1><p>可以将 libxml 版本升级到 2.9.0 以后，因为 libxml 2.9.0 以后默认是不解析外部实体的，还要做输入过滤，错误处理等，反正应对注入的措施都要有</p><h1 id="Bonus"><a href="#Bonus" class="headerlink" title="Bonus"></a>Bonus</h1><p>XML Schema 很快会将 DTD 取而代之，但 XML Schema 也会存在注入的问题，这个后面再慢慢看，还有Xpath注入等，关于xml的安全问题还是由很多的</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://mp.weixin.qq.com/s/vkCdz6YCoiiJPI30KePD6g" target="_blank" rel="noopener">http://mp.weixin.qq.com/s/vkCdz6YCoiiJPI30KePD6g</a></p><p><a href="http://www.runoob.com/dtd/dtd-summary.html" target="_blank" rel="noopener">http://www.runoob.com/dtd/dtd-summary.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x00-什么是-XXE&quot;&gt;&lt;a href=&quot;#0x00-什么是-XXE&quot; class=&quot;headerlink&quot; title=&quot;0x00 什么是 XXE&quot;&gt;&lt;/a&gt;0x00 什么是 XXE&lt;/h1&gt;&lt;p&gt;XXE：XML External Entity，即外部实体攻
      
    
    </summary>
    
    
      <category term="Web security" scheme="http://yoursite.com/tags/Web-security/"/>
    
  </entry>
  
</feed>
