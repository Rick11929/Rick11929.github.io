<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Rick7dology</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-04-05T15:04:19.012Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Rick7</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android开发基础复习_2</title>
    <link href="http://yoursite.com/2018/04/05/Android%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0-2/"/>
    <id>http://yoursite.com/2018/04/05/Android开发基础复习-2/</id>
    <published>2018-04-04T22:58:40.000Z</published>
    <updated>2018-04-05T15:04:19.012Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>继续写“第一行代码”的读书笔记，这次看看Android的广播机制</p><h1 id="0x01-广播机制"><a href="#0x01-广播机制" class="headerlink" title="0x01 广播机制"></a>0x01 广播机制</h1><p>广播机制分为两类：</p><ul><li><p>标准广播：异步的，广播发送之后，所有的广播接收器几乎同时接受广播，广播效率比较高。但不能截断。</p></li><li><p>有序广播：同步执行的，优先级高的先接受到，之前的广播接收器可以截断广播。</p></li></ul><h1 id="0x02-动态注册广播接收器和静态注册广播接收器"><a href="#0x02-动态注册广播接收器和静态注册广播接收器" class="headerlink" title="0x02 动态注册广播接收器和静态注册广播接收器"></a>0x02 动态注册广播接收器和静态注册广播接收器</h1><p>先来看如何写动态注册，关键函数是：registerReceiver(networkChangReceiver,intentFilter)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    private IntentFilter intentFilter;</span><br><span class="line">    private NetworkChangReceiver networkChangReceiver;</span><br><span class="line"></span><br><span class="line">    class NetworkChangReceiver extends BroadcastReceiver &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onReceive(Context context,Intent intent) &#123;</span><br><span class="line">            Toast.makeText(context,&quot;Netwokchange&quot;,Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void onDestroy() &#123;</span><br><span class="line">        super.onDestroy();</span><br><span class="line">        unregisterReceiver(networkChangReceiver);//注销广播接收器</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.first_layout);</span><br><span class="line">        Button button1 = (Button) findViewById(R.id.button_1);</span><br><span class="line">        intentFilter = new IntentFilter();</span><br><span class="line">        intentFilter.addAction(&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;);//定义广播接收器的接收动作</span><br><span class="line">        networkChangReceiver = new NetworkChangReceiver();//新建一个广播接收器</span><br><span class="line">        registerReceiver(networkChangReceiver,intentFilter);//动态注册广播接收器</span><br></pre></td></tr></table></figure><p>静态注册的编写方法就简单多了，直接定义一个接收类，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> This method is called when the BroadcastReceiver is receiving</span></span><br><span class="line">        <span class="comment">// an Intent broadcast.</span></span><br><span class="line">        Toast.makeText(context, <span class="string">"开机 "</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Not yet implemented"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在AndroidManifest.xml中注册,添加Intentfileter；并且开启权限:RECEIVE_BOOT_COMPLETED</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.RECEIVE_BOOT_COMPLETED"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">receiver</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">".MyReceiver"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:enabled</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.BOOT_COMPLETED"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="0x03-发送广播"><a href="#0x03-发送广播" class="headerlink" title="0x03 发送广播"></a>0x03 发送广播</h1><ul><li>发送标准广播</li></ul><p>基本步骤为：新建一个广播接收器，在然后AndroidManifest.xml中注册,添加Intentfileter，发送自定义广播，也就是Intent。</p><p>这里的广播接收器我用上面的就OK了，只需要添加一个Intentfileter就完成。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发送标准广播到我们定义的广播接收器</span></span><br><span class="line">        Button button5 = (Button) findViewById(R.id.button_5);</span><br><span class="line">        button3.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                Intent intent=<span class="keyword">new</span> Intent(<span class="string">"com.example.broadcastdemo.MY_BROADCAST"</span>);<span class="comment">//还是要用到Intent</span></span><br><span class="line">                sendBroadcast(intent);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;继续写“第一行代码”的读书笔记，这次看看Android的广播机制&lt;/p&gt;
&lt;h1 id=&quot;0x01-
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Json web token vs session id</title>
    <link href="http://yoursite.com/2018/04/04/Json-web-token-vs-session-id/"/>
    <id>http://yoursite.com/2018/04/04/Json-web-token-vs-session-id/</id>
    <published>2018-04-03T21:58:19.000Z</published>
    <updated>2018-04-09T10:13:55.423Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>JWT是现代web中常见的持续认证手段，也是针对http无状态的其中一个认证的解决方案，今日特地看了写JWT和传统的session id方案作比较的文章</p><h1 id="0x01-Json-Web-Token"><a href="#0x01-Json-Web-Token" class="headerlink" title="0x01 Json Web Token"></a>0x01 Json Web Token</h1><p>JWT是开发的标准，主要的特点是简洁，自包含。通过数字签名确保信息的完整性，真实性</p><h2 id="JWT的结构"><a href="#JWT的结构" class="headerlink" title="JWT的结构"></a>JWT的结构</h2><p>主要包括三大块：header, payload and signature。</p><p>详细的信息主要参考官方说明：</p><p><a href="https://jwt.io/introduction/" target="_blank" rel="noopener">https://jwt.io/introduction/</a></p><h2 id="JWT的认证过程"><a href="#JWT的认证过程" class="headerlink" title="JWT的认证过程"></a>JWT的认证过程</h2><p>当然登录应用成功后，应用会返回一个JWT给用户保存，用户后续的请求都会带上这个JWT作为token取得授权的资源。常见的JWT会以以下的请求头部出现：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Authorization: Bearer &lt;token&gt;</span><br></pre></td></tr></table></figure><p>具体的认证过程如下：</p><p><img src="/images/JWT_workflow.png" alt="JWT认证图"></p><h1 id="0x02-与传统session-id的比较"><a href="#0x02-与传统session-id的比较" class="headerlink" title="0x02 与传统session id的比较"></a>0x02 与传统session id的比较</h1><ul><li>在扩展性上，JWT的扩展性比session更加好，毕竟session需要存储在服务器，如果需要做服务器迁移或者扩展，JWT的基于token认证的无状态显示出了优势。</li><li>在安全性上，本人感觉JWT没有比session更加有优势，JWT使用了数字签名确保了数据的完整性和防篡改，但还是要存储在用户本地，这样和普通cookie一样会受到XSS攻击的威胁，有被盗取的风险。而却JWT对于防CSRF也是显得力不从心的，特别在攻击者诱骗授权用户点击操作的场景，还是需要CSRF token。在重放攻击(replay attack)中，JWT也是不能防止这类攻击的。</li><li>在 RESTful API Services 上，JWT简直是为这个而生，无状态的最佳实现，再配合(CORS)进行跨越，这样调用API就更加方便了</li></ul><h1 id="0x03-JWT已知漏洞"><a href="#0x03-JWT已知漏洞" class="headerlink" title="0x03 JWT已知漏洞"></a>0x03 JWT已知漏洞</h1><ul><li>NONE hashing algorithm ：某些JWT库对token的验证出现了bug，详细资料参考以下链接：</li></ul><p><a href="https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/" target="_blank" rel="noopener">https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/</a></p><h1 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h1><p><a href="https://ponyfoo.com/articles/json-web-tokens-vs-session-cookies" target="_blank" rel="noopener">https://ponyfoo.com/articles/json-web-tokens-vs-session-cookies</a></p><p><a href="https://github.com/teesloane/Auth-Boss" target="_blank" rel="noopener">https://github.com/teesloane/Auth-Boss</a></p><p><a href="https://www.owasp.org/index.php/JSON_Web_Token_(JWT)_Cheat_Sheet_for_Java#Issues" target="_blank" rel="noopener">https://www.owasp.org/index.php/JSON_Web_Token_(JWT)_Cheat_Sheet_for_Java#Issues</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;JWT是现代web中常见的持续认证手段，也是针对http无状态的其中一个认证的解决方案，今日特地看了
      
    
    </summary>
    
    
      <category term="Web Security" scheme="http://yoursite.com/tags/Web-Security/"/>
    
  </entry>
  
  <entry>
    <title>Android开发基础读书笔记_1</title>
    <link href="http://yoursite.com/2018/03/23/Android%E5%BC%80%E5%8F%91%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0_1/"/>
    <id>http://yoursite.com/2018/03/23/Android开发基础复习_1/</id>
    <published>2018-03-22T23:46:54.000Z</published>
    <updated>2018-03-28T14:43:46.820Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>又看了一遍“第一行代码”的第二版，这次跟着书里面的代码随便敲了一下，顺便写一遍读书笔记</p><h2 id="0x01-Android项目中的资源"><a href="#0x01-Android项目中的资源" class="headerlink" title="0x01 Android项目中的资源"></a>0x01 Android项目中的资源</h2><p>src: 各种java程序在此，包括主程序<br>gen: 最重要的是R.java，所有res资源都在这里编号，通过R.xx.xx或@xx查询<br>res: 各种资源都在这里，包括drawable, layout, values等<br>另外还有menifest文件，统筹兼顾全局的，Android四大组件都要在此注册。</p><p><strong>重点说一下gradle，这里有两个build.gradle目录，一个在项目的最外层，负责项目全局的构建，另外一个build.gradle在app模块的构建脚本，里面有超级多的构建配置，关于gradle会另外在自行学习一点</strong></p><h2 id="0x02-Activity"><a href="#0x02-Activity" class="headerlink" title="0x02 Activity"></a>0x02 Activity</h2><p>创建Activity步骤：<br>1、首先，在app目录右击创建一个空的activity，重写Activity的onCreate()方法<br>2、建立布局文件并关联，用setContentView(R.layout.myactivity)将布局加载进来。<br>3、所有四大组件的使用，都需要在AndroidManifest.xml文件中注册。AS自动帮我解决了，下面是手动方式<br>注册方法为：<br>在<application>中添加<activity>标签，将需要注册的activity使用android:name=”.MainActivity”注册。如果是主activity，即打开application时看到的activity，则需要添加</activity></application></p><p><action android:name="android.intent.action.MAIN"></action></p><p><category android:name="android.intent.category.LAUNCHER"><br>4、加一个button到新创建的activity，然后用toast对象的show方法进行输出提示</category></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.first_layout);</span><br><span class="line">        Button button1 = (Button)findViewById(R.id.button_1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//建立一个button并调用Toast显示短信息</span></span><br><span class="line">        button1.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>&#123;</span><br><span class="line">                Toast.makeText(MainActivity.<span class="keyword">this</span>,<span class="string">"You click button_1"</span>,</span><br><span class="line">                        Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><h2 id="0x03-Intent"><a href="#0x03-Intent" class="headerlink" title="0x03 Intent"></a>0x03 Intent</h2><ul><li>显式Intent</li></ul><p>首先，按照上面的步骤重新创建一个SecondActivity（记得注册），采用Intent实现跳转</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Button button2 = (Button)findViewById(R.id.button_2);</span><br><span class="line">        button2.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>&#123;</span><br><span class="line">                Intent intent = <span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>,Main2Activity.class);</span><br><span class="line">                startActivity(intent);<span class="comment">//使用显示intent调用Main2Activity</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><ul><li>隐式Intent</li></ul><p>隐式Intent并不能实现直接跳转，需要指定两个条件（intent-filter）：action和category。<strong>要两个同时匹配才能相应这个intent。</strong></p><p>intent-filter在注册activity时添加，intentfilter中只能有一个action，但可以有多个category，满足其中一个category即可。</p><p>跳转方法为：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用隐式Intent调用第三个page，Category使用默认的，自定义的实验失败</span></span><br><span class="line">        Button button3 = (Button)findViewById(R.id.button_3);</span><br><span class="line">        button3.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>&#123;</span><br><span class="line">                Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.example.rick7.rickapplication.ACTION_START"</span>);<span class="comment">//使用隐式Intent，只传入一个自定义的动作名称</span></span><br><span class="line">                <span class="comment">//intent.addCategory("com.example.rick7.rickapplication.MY_CATEGORY");</span></span><br><span class="line">                startActivity(intent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><ul><li><p>使用隐式Intent的系统内置方法，打开系统编写的activity，比如浏览器，打电话等</p></li><li><p>使用Intent传递数据</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用隐式Intent调用系统浏览器界面并打开百度，并传输数据到BrowserActivity</span></span><br><span class="line">        Button button4 = (Button)findViewById(R.id.button_4);</span><br><span class="line">        button4.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>&#123;</span><br><span class="line">                String data = <span class="string">"i want to open baidu"</span>;</span><br><span class="line">                Intent intent= <span class="keyword">new</span> Intent(Intent.ACTION_VIEW);<span class="comment">//传入系统内置动作ACTION_VIEW</span></span><br><span class="line">                intent.setData(Uri.parse(<span class="string">"http://www.baidu.com"</span>));<span class="comment">//设置Intent携带的数据</span></span><br><span class="line">                intent.putExtra(<span class="string">"extra_data"</span>,data);</span><br><span class="line">                startActivity(intent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><h2 id="0x04-activity生存期"><a href="#0x04-activity生存期" class="headerlink" title="0x04 activity生存期"></a>0x04 activity生存期</h2><p>完整生存期：onCreate() -&gt; onDestory()<br>可见生存期：onStart() -&gt; onStop()<br>前台生存期：onResume() -&gt; onPause()</p><p><img src="/images/activity生存周期.png" alt="生存周期"></p><h2 id="0x05-activity的启动模式"><a href="#0x05-activity的启动模式" class="headerlink" title="0x05 activity的启动模式"></a>0x05 activity的启动模式</h2><p>四种启动模式，可以在<activity>标签中android:launchMode定义。</activity></p><ul><li>standard：打开activity，就放入栈顶</li><li>singleTop：打开activity，检查栈顶是否已经存在该activity，存在了就不创建。不存在才创建。不过，如果该activity不在栈顶，但也存在，则也会重新创建一个。</li><li>singleTask：检查整个返回栈，如果存在某个activity，则不会重新创建。</li><li>singleInstance：创建一个activity，重新在一个新的返回栈(或Task)中创建，该activity与其他activity不在同一个Task中，其他程序也可以调用这个activity的实例。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h2&gt;&lt;p&gt;又看了一遍“第一行代码”的第二版，这次跟着书里面的代码随便敲了一下，顺便写一遍读书笔记&lt;/p&gt;
&lt;h
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>英文面试速背指南_持续更新</title>
    <link href="http://yoursite.com/2018/03/21/%E8%8B%B1%E6%96%87%E9%9D%A2%E8%AF%95%E9%80%9F%E8%83%8C%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2018/03/21/英文面试速背指南/</id>
    <published>2018-03-20T18:04:27.000Z</published>
    <updated>2018-03-23T06:20:54.637Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>为了面试外企做准备的速背表，一定要精简,精简，再精简，每个概念尽量一到两句话进行速记</p><h1 id="0x01-What-is-Penetration-Testing"><a href="#0x01-What-is-Penetration-Testing" class="headerlink" title="0x01 What is Penetration Testing?"></a>0x01 What is Penetration Testing?</h1><p>Penetration testing is a type of security testing that is used to test the insecurity of an application. It is conducted to find the security risk which might be present in the system.</p><h1 id="0x02-Penetration-Testing-Methodologies-seven-steps"><a href="#0x02-Penetration-Testing-Methodologies-seven-steps" class="headerlink" title="0x02 Penetration Testing Methodologies (seven steps)"></a>0x02 Penetration Testing Methodologies (seven steps)</h1><p>Penetration Testing Execution Standard (PTES) defines penetration testing as 7 phases.</p><ul><li><p>Pre-engagement Interactions<br>It includes gathering the required tools, OS, and software to start the penetration testing. In addition, there are some basic tools that are required to complete penetration testing with expected results.</p></li><li><p>Intelligence Gathering (Information Gathering)(DNS,IP,Email,Google hacking,etc…)<br>The data is collected to help in completing the assessment actions. The information is gathered using a process that helps us to get access to any information that is relevant to the target.</p></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tools：</span><br><span class="line">1.theHarvester is a tool for gathering e-mail accounts, subdomain names, virtual</span><br><span class="line">hosts, open ports/ banners, and employee names from different public sources</span><br><span class="line">(search engines, pgp key servers).</span><br><span class="line">https://github.com/laramies/theHarvester</span><br><span class="line">2.Social Engineer Toolkit</span><br><span class="line">Social Engineer Toolkit (SET) is an open source Python-based tool aimed at penetration testing around Social Engineering.</span><br></pre></td></tr></table></figure><ul><li><p>Threat Modeling<br>Threat modeling allows you to strengthen network security by tracking the vulnerabilities and then defining measures to prevent or reduce the effect of the threat.</p></li><li><p>Vulnerability Analysis(Scanning,manual testing)<br>Identification: Vulnerabilities are discovered<br>Validation: Validate the identified vulnerabilities</p></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tools:</span><br><span class="line">1.OpenVAS</span><br><span class="line">2.Nexpose/Nessus</span><br><span class="line">3.Netsparker </span><br><span class="line">4.Acunetix(AWS)</span><br></pre></td></tr></table></figure><ul><li>Exploitation<br>The identified vulnerabilities are exploited to breach the security</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tools:</span><br><span class="line">1.BeEF(Browser Exploitation Framework (Beef))</span><br><span class="line">2.Metasploit</span><br><span class="line">3.sqlmap</span><br></pre></td></tr></table></figure><ul><li>Post Exploitation<br>In this phase, the compromised machine’s value is determined by the sensitivity of the data stored on it. It also evaluates the machine usefulness in further exploiting the network.</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tools:</span><br><span class="line">1.PowerShell Empire</span><br><span class="line">2.Meterpreter</span><br><span class="line">3.Netcat</span><br></pre></td></tr></table></figure><ul><li>Reporting<br>The findings are reported in a way that is easily understandable. </li></ul><h1 id="0x03-Web-Vulnerability"><a href="#0x03-Web-Vulnerability" class="headerlink" title="0x03 Web Vulnerability"></a>0x03 Web Vulnerability</h1><h2 id="What-is-SQLinjection-attack"><a href="#What-is-SQLinjection-attack" class="headerlink" title="What is SQLinjection attack"></a>What is SQLinjection attack</h2><p>A SQL injection attack consists of insertion or “injection” of a SQL query via the input data from the client to the application. A successful SQL injection exploit can read sensitive data from the database, modify database data (Insert/Update/Delete), execute administration operations on the database (such as shutdown the DBMS), recover the content of a given file present on the DBMS file system and in some cases issue commands to the operating system. SQL injection attacks are a type of injection attack, in which SQL commands are injected into data-plane input in order to effect the execution of predefined SQL commands.</p><ul><li>In-band SQLi (Classic SQLi):Error-based SQLi and Union-based SQLi.</li><li>Inferential SQLi (Blind SQLi):Boolean-based (content-based) Blind SQLi and Time-based Blind SQLi</li></ul><h2 id="What-is-Cross-site-Scripting-XSS-attack"><a href="#What-is-Cross-site-Scripting-XSS-attack" class="headerlink" title="What is Cross-site Scripting (XSS) attack"></a>What is Cross-site Scripting (XSS) attack</h2><p>Cross-Site Scripting (XSS) attacks are a type of injection, in which malicious scripts are injected into otherwise benign and trusted web sites. XSS attacks occur when an attacker uses a web application to send malicious code, generally in the form of a browser side script, to a different end user. Flaws that allow these attacks to succeed are quite widespread and occur anywhere a web application uses input from a user within the output it generates without validating or encoding it.</p><ul><li>Reflected XSS Attacks</li><li>Stored XSS Attacks</li><li>DOM Based XSS </li></ul><h2 id="OWASP-top-10-2017"><a href="#OWASP-top-10-2017" class="headerlink" title="OWASP top 10 2017"></a>OWASP top 10 2017</h2><p>Top 10<br>A1:2017-Injection (SQL, LDAP, XPath, or NoSQL queries, OS commands, XML parsers, SMTP headers, expression languages, and ORM queries.)</p><p>A2:2017-Broken Authentication</p><p>A3:2017-Sensitive Data Exposure</p><p>A4:2017-XML External Entities (XXE) Any of the XML processors in the application or SOAP based web services has document type definitions (DTDs) enabled.</p><p>A5:2017-Broken Access Control</p><p>A6:2017-Security Misconfiguration</p><p>A7:2017-Cross-Site Scripting (XSS)</p><p>A8:2017-Insecure Deserialization</p><p>A9:2017-Using Components with Known Vulnerabilities</p><p>A10:2017-Insufficient Logging&amp;Monitoring</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;为了面试外企做准备的速背表，一定要精简,精简，再精简，每个概念尽量一到两句话进行速记&lt;/p&gt;
&lt;h1
      
    
    </summary>
    
    
      <category term="其他" scheme="http://yoursite.com/tags/%E5%85%B6%E4%BB%96/"/>
    
  </entry>
  
  <entry>
    <title>OAuth2.0 笔记_2</title>
    <link href="http://yoursite.com/2018/03/13/OAuth2-0-%E7%AC%94%E8%AE%B02/"/>
    <id>http://yoursite.com/2018/03/13/OAuth2-0-笔记2/</id>
    <published>2018-03-12T19:27:59.000Z</published>
    <updated>2018-03-15T07:56:40.349Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>在上一遍学习笔记中整理了授权码模式的交换流程和csrf攻击的知识，这次继续总结OAuth其他攻击面</p><h1 id="0x01-“redirect-uri”"><a href="#0x01-“redirect-uri”" class="headerlink" title="0x01 “redirect uri”"></a>0x01 “redirect uri”</h1><p>根据OAuth的认证流程,用户授权凭证会由服务器转发到redirect_uri对应的地址,如果攻击者伪造redirect_uri为自己的地址,然后诱导用户发送该请求,之后获取的凭证就会发送给攻击者伪造的回调地址.攻击者使用该凭证即可登录用户账号,造成授权劫持.</p><p>近日有安全测试团队又发布了一些关于redirect_url过滤不严格的问题，详情看下面的链接，就是redirect_uri只过滤了主域名，而没有对子域名进行过滤，如果子域名存在漏洞，攻击者则可以通过子域名构造构造恶意的redirect_uri，从refer头部盗取用户的 “authorization code”</p><p><a href="https://bbs.ichunqiu.com/thread-34168-1-1.html" target="_blank" rel="noopener">https://bbs.ichunqiu.com/thread-34168-1-1.html</a></p><p>Refer:</p><p><a href="http://www.freebuf.com/articles/web/110757.html" target="_blank" rel="noopener">http://www.freebuf.com/articles/web/110757.html</a></p><p><a href="https://dhavalkapil.com/blogs/Attacking-the-OAuth-Protocol/" target="_blank" rel="noopener">https://dhavalkapil.com/blogs/Attacking-the-OAuth-Protocol/</a></p><p><a href="https://sakurity.com/oauth" target="_blank" rel="noopener">https://sakurity.com/oauth</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;在上一遍学习笔记中整理了授权码模式的交换流程和csrf攻击的知识，这次继续总结OAuth其他攻击面&lt;
      
    
    </summary>
    
    
      <category term="Web security" scheme="http://yoursite.com/tags/Web-security/"/>
    
  </entry>
  
  <entry>
    <title>经典sqlmap命令</title>
    <link href="http://yoursite.com/2018/03/09/%E7%BB%8F%E5%85%B8sqlmap%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/03/09/经典sqlmap命令/</id>
    <published>2018-03-09T15:33:21.000Z</published>
    <updated>2018-03-09T10:07:51.195Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x01-查看当前数据库，得到数据库名字"><a href="#0x01-查看当前数据库，得到数据库名字" class="headerlink" title="0x01 查看当前数据库，得到数据库名字"></a>0x01 查看当前数据库，得到数据库名字</h1><p>sqlmap.py -u “存在注入url” –current-db</p><p>python sqlmap.py -u “<a href="http://127.0.0.1:65412/?id=2" target="_blank" rel="noopener">http://127.0.0.1:65412/?id=2</a>“ –current-db</p><h1 id="0x02-查看tables-得到指定数据库的表名字"><a href="#0x02-查看tables-得到指定数据库的表名字" class="headerlink" title="0x02 查看tables,得到指定数据库的表名字"></a>0x02 查看tables,得到指定数据库的表名字</h1><p>python sqlmap.py -u “存在注入url” -D “当前数据库名” –tables   //解释说明：-D是指定数据库名称</p><p>python sqlmap.py -u “<a href="http://127.0.0.1:65412/?id=2" target="_blank" rel="noopener">http://127.0.0.1:65412/?id=2</a>“ –tables</p><h1 id="0x03-查看columns，得到指定数据库，指定表的列名字"><a href="#0x03-查看columns，得到指定数据库，指定表的列名字" class="headerlink" title="0x03 查看columns，得到指定数据库，指定表的列名字"></a>0x03 查看columns，得到指定数据库，指定表的列名字</h1><p>sqlmap.py -u “存在注入url” -D “当前数据库名” -T “数据库中的随意一张表(选取表需要自己判断)” –columns</p><p>python sqlmap.py -u “<a href="http://127.0.0.1:65412/?id=2" target="_blank" rel="noopener">http://127.0.0.1:65412/?id=2</a>“ -T “users” –columns</p><h1 id="0x04-根据上面得到的columns查看具体字段"><a href="#0x04-根据上面得到的columns查看具体字段" class="headerlink" title="0x04 根据上面得到的columns查看具体字段"></a>0x04 根据上面得到的columns查看具体字段</h1><p>sqlmap.py -u “存在注入url ” -D “当前数据库名” -T “数据库中的随意一张表(选取表需要自己判断)” -C “username,password,email” –dump</p><p>python sqlmap.py -u “<a href="http://127.0.0.1:65412/?id=2" target="_blank" rel="noopener">http://127.0.0.1:65412/?id=2</a>“ -T “users” -C “password” –dump</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x01-查看当前数据库，得到数据库名字&quot;&gt;&lt;a href=&quot;#0x01-查看当前数据库，得到数据库名字&quot; class=&quot;headerlink&quot; title=&quot;0x01 查看当前数据库，得到数据库名字&quot;&gt;&lt;/a&gt;0x01 查看当前数据库，得到数据库名字&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="Web security" scheme="http://yoursite.com/tags/Web-security/"/>
    
  </entry>
  
  <entry>
    <title>数字证书的理解</title>
    <link href="http://yoursite.com/2018/03/07/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/03/07/数字证书的理解/</id>
    <published>2018-03-07T11:27:18.000Z</published>
    <updated>2018-03-10T07:47:14.445Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>数字证书是公钥密码学的典型应用，是信息安全的基础，今日好好复习一下</p><h1 id="0x01-简单应用原理"><a href="#0x01-简单应用原理" class="headerlink" title="0x01 简单应用原理"></a>0x01 简单应用原理</h1><p><strong>最重要的一点，数字证书是保障公钥的可靠性</strong></p><p>以下流程参考阮一峰老师的经典流程：</p><p>假设A给B写一份信。</p><p>那么这封将包含如下三部分内容：</p><p>1.信本身的内容（直接可以看到，未加密）</p><p>2.A的数字签名 （是由信本身的内容经过hash算法计算得到digest摘要，然后用 A的私钥 加密而来的）</p><p>3.A的数字证书 （是A 向数字证书中心（CA）申请的，是由 A的个人信息，A的公钥 等经过CA的私钥 加密而来的）</p><p>然后B先用CA提供的公钥解开数字证书，根据得到的内容，如A的个人信息，确定是A发过来的，然后拿到了A的公钥。</p><p>接着，用A的公钥解开A的数字签名 就能得到信本身内容的摘要。然后将信的第一部分，即信的本身内容 经hash计算得到一个新的摘要，将两个摘要比较，如果相同 说明信的内容没有被篡改。</p><p><strong>这里B要做的就是查询CA是否可信，然后用可信CA的公钥解开A的数字证书，得到A的个人信息和公钥，然后利用A的可信公钥验证A的数字签名，可见，数字证书的最大作用就是保证A的公钥的真实性，抗抵赖</strong></p><h1 id="0x02-Https的应用"><a href="#0x02-Https的应用" class="headerlink" title="0x02 Https的应用"></a>0x02 Https的应用</h1><p>https传输，访问google网站：<br>握手时用非对称加密传输对称加密的密码，数据传输时用对称加密的密码加密数据（对称加密解密速度比非对称加密快）</p><p>过程：</p><ul><li>浏览器发送自己支持的加密规则给google</li><li>google选择一组加密算法和HASH算法，并将自己的数字证书发给浏览器</li><li>浏览器验证数字证书的合法性（验证证书的数字签名），然后生成一个随机数，从google的数字证书里面获取google的公钥，用这个公钥加密随机数。用约定的hash算法生成握手消息的摘要，并用生成的随机数加密摘要。把握手消息、加密的摘要、加密的随机数发给google</li><li>google用自己的私钥解密随机数，然后用随机数解密摘要，再用hash生成收到的握手消息的摘要与解密的摘要对比，验证正确性。</li><li>google一样用hash算法生成握手消息的摘要，并用解密的随机数加密摘要。然后把握手消息、加密的摘要发给浏览器</li><li>浏览器验证摘要成功后，握手完成。之后通信的数据用之前浏览器生成的随机密码加密后传输。</li></ul><h1 id="0x03-问题的根源：-证书中的公钥的真实性和完整性）"><a href="#0x03-问题的根源：-证书中的公钥的真实性和完整性）" class="headerlink" title="0x03 问题的根源：(证书中的公钥的真实性和完整性）"></a>0x03 问题的根源：(证书中的公钥的真实性和完整性）</h1><p>由上面的例子中我们看到，https传输的过程中，Google会发来自己的证书，里面包含了Google的公钥，用户浏览器要使用这个公钥加密消息再发送到Google服务器进行协商，其中，这个公钥的完整性和真实性就是关键，如何保证这个证书里面的公钥真的是Google的呢？这就是为什么要验证证书的数字签名的理由，那么如何验证呢？就是通过CA了，CA会通过自己的私钥对可信的包含正确公钥的Google证书进行数字签名，用户浏览器要使用CA的公钥验证证书的数字签名。</p><h1 id="0x04-证书链"><a href="#0x04-证书链" class="headerlink" title="0x04 证书链"></a>0x04 证书链</h1><p>根据上面的说明，证书的出现是为了保证双方的公钥是合法的，没有被篡改的，那么谁保证证书的合法性和完整呢？那就是CA，但是直接从知名的CA获得签名证书是昂贵的，所以，就出现了由知名CA签发了一个证书A，再又证书A签发证书B的方式，这就是证书链。<br><strong>本质来说，就是顶级CA认证了A的公钥，然后A的公钥再认证B的公钥。</strong> </p><h2 id="证书链的构成："><a href="#证书链的构成：" class="headerlink" title="证书链的构成："></a>证书链的构成：</h2><p>end-user ：baidu.com 包含用来加密传输数据的公钥的证书，是HTTPS中使用的证书</p><p>intermediates CA ：CA用来认证公钥持有者身份的证书，即确认HTTPS使用的end-user证书是属于baidu.com的证书。这类intermediates证书甚至可以有很多级。</p><p>root CA ：用来认证intermediates证书是合法证书的证书。</p><p>简单来说，end-user证书上面几级证书都是为了保证end-user证书未被篡改，保证是CA签发的合法证书，进而保证end-user证书中的公钥未被篡改</p><p><img src="/images/certificate chain.png" alt="证书链图片"></p><h2 id="如何验证证书链"><a href="#如何验证证书链" class="headerlink" title="如何验证证书链"></a>如何验证证书链</h2><p>链式向上验证证书，直到Root Certificates，先验证用intermediates CA 签发的end-user的证书的数字签名，再利用root CA验证intermediates CA的数字签名。下图就是访问百度获得的三张证书</p><p><img src="/images/end-user.png" alt="证书链图片1"><br><img src="/images/intermediates CA.png" alt="证书链图片2"><br><img src="/images/root CA.png" alt="证书链图片3"></p><p>下面的图片很好的表达了如何进行证书链的认证：</p><p><img src="/images/verify.png" alt="证书链图片4"></p><p>从哪获取非根证书的颁发者证书？</p><p>网站的证书里是包含上级颁发机构的证书获取地址的</p><h2 id="总体来说浏览器对证书的验证包括下面几项："><a href="#总体来说浏览器对证书的验证包括下面几项：" class="headerlink" title="总体来说浏览器对证书的验证包括下面几项："></a>总体来说浏览器对证书的验证包括下面几项：</h2><ul><li><p>验证证书是否在有效期内</p></li><li><p>验证证书是否在有效期内</p></li></ul><p>验证吊销有CRL和OCSP两种方法</p><ul><li>验证证书是否是上级CA签发的(上面讨论的重点)</li></ul><h1 id="x-509-证书编码格式"><a href="#x-509-证书编码格式" class="headerlink" title="x.509 证书编码格式"></a>x.509 证书编码格式</h1><p>我们平时会见到一大堆后缀名不同的证书，但先抛开后缀名字不谈，x.509就只有两种常用的编码格式</p><ul><li><p>PEM - Privacy Enhanced Mail,打开看文本格式,以”—–BEGIN…”开头, “—–END…”结尾,内容是BASE64编码.<br>查看PEM格式证书的信息:openssl x509 -in certificate.pem -text -noout<br>Apache和*NIX服务器偏向于使用这种编码格式.</p></li><li><p>DER - Distinguished Encoding Rules,打开看是二进制格式,不可读.<br>查看DER格式证书的信息:openssl x509 -in certificate.der -inform der -text -noout<br>Java和Windows服务器偏向于使用这种编码格式.</p></li></ul><h2 id="相关的文件扩展名-引用一下别人的"><a href="#相关的文件扩展名-引用一下别人的" class="headerlink" title="相关的文件扩展名,引用一下别人的"></a>相关的文件扩展名,引用一下别人的</h2><blockquote><p>这是比较误导人的地方,虽然我们已经知道有PEM和DER这两种编码格式,但文件扩展名并不一定就叫”PEM”或者”DER”,常见的扩展名除了PEM和DER还有以下这些,它们除了编码格式可能不同之外,内容也有差别,但大多数都能相互转换编码格式.</p></blockquote><ul><li><p>CRT - CRT应该是certificate的三个字母,其实还是证书的意思,常见于*NIX系统,有可能是PEM编码,也有可能是DER编码,大多数应该是PEM编码,</p></li><li><p>CER - 还是certificate,还是证书,常见于Windows系统,同样的,可能是PEM编码,也可能是DER编码,大多数应该是DER编码.</p></li><li><p>PFX/P12 - predecessor of PKCS#12,对*nix服务器来说,一般CRT和KEY是分开存放在不同文件中的,但Windows的IIS则将它们存在一个PFX文件中,(因此这个文件包含了证书及私钥)这样会不会不安全？应该不会,PFX通常会有一个”提取密码”,你想把里面的东西读取出来的话,它就要求你提供提取密码,PFX使用的时DER编码,如何把PFX转换为PEM编码？<br>openssl pkcs12 -in for-iis.pfx -out for-iis.pem -nodes<br>这个时候会提示你输入提取代码. for-iis.pem就是可读的文本.<br>生成pfx的命令类似这样:openssl pkcs12 -export -in certificate.crt -inkey privateKey.key -out certificate.pfx -certfile CACert.crt</p></li></ul><p>其中CACert.crt是CA(权威证书颁发机构)的根证书,有的话也通过-certfile参数一起带进去.这么看来,PFX其实是个证书密钥库.</p><p>参考：</p><p><a href="http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html</a></p><p><a href="https://www.jianshu.com/p/46e48bc517d0" target="_blank" rel="noopener">https://www.jianshu.com/p/46e48bc517d0</a></p><p><a href="https://security.stackexchange.com/questions/56389/ssl-certificate-framework-101-how-does-the-browser-actually-verify-the-validity" target="_blank" rel="noopener">https://security.stackexchange.com/questions/56389/ssl-certificate-framework-101-how-does-the-browser-actually-verify-the-validity</a></p><p><a href="https://www.zhihu.com/question/37370216" target="_blank" rel="noopener">https://www.zhihu.com/question/37370216</a></p><p><a href="http://www.cnblogs.com/guogangj/p/4118605.html" target="_blank" rel="noopener">http://www.cnblogs.com/guogangj/p/4118605.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;数字证书是公钥密码学的典型应用，是信息安全的基础，今日好好复习一下&lt;/p&gt;
&lt;h1 id=&quot;0x01
      
    
    </summary>
    
    
      <category term="Web security" scheme="http://yoursite.com/tags/Web-security/"/>
    
  </entry>
  
  <entry>
    <title>Python 常用套路总结_1</title>
    <link href="http://yoursite.com/2018/03/03/Python%20%E5%B8%B8%E7%94%A8%E5%A5%97%E8%B7%AF%E6%80%BB%E7%BB%93-1/"/>
    <id>http://yoursite.com/2018/03/03/Python 常用套路总结-1/</id>
    <published>2018-03-02T16:15:14.000Z</published>
    <updated>2018-03-05T13:47:59.350Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>跟着“菜鸟学Python”这个我最喜欢的公众号文章做点练习和巩固基本套路</p><h1 id="0x01-字符串-string-的使用"><a href="#0x01-字符串-string-的使用" class="headerlink" title="0x01 字符串(string)的使用"></a>0x01 字符串(string)的使用</h1><ul><li>主要复习了字符串分割，字符串列表按长度排序的方法</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">text1=<span class="string">'A dict that contains arbitrary metadata for this request. '</span> \</span><br><span class="line">      <span class="string">'This dict is empty for new Requests, '</span> \</span><br><span class="line">      <span class="string">'and is usually populated by different Scrapy components . '</span> \</span><br><span class="line">      <span class="string">'So the data contained in this dict depends on the extensions you have enabled.'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">text2 = text1.split(<span class="string">' '</span>) <span class="comment">#分割字符串,得到下面的由字符串组成的列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#['A', 'dict', 'that', 'contains', 'arbitrary', 'metadata', 'for', 'this', 'request.', 'This', 'dict', 'is', 'empty', 'for', 'new', 'Requests,', 'and', 'is', 'usually', 'populated', 'by', 'different', 'Scrapy', 'components', '.', 'So', 'the', 'data', 'contained', 'in', 'this', 'dict', 'depends', 'on', 'the', 'extensions', 'you', 'have', 'enabled.']</span></span><br><span class="line"></span><br><span class="line">text3 = sorted(text2,key = <span class="keyword">lambda</span> x:len(x),reverse=<span class="keyword">True</span>) <span class="comment">#按分割后的每个字符串长度排序</span></span><br><span class="line"></span><br><span class="line">print(text3[<span class="number">0</span>]) <span class="comment">#得到最长的那个字符串</span></span><br></pre></td></tr></table></figure><ul><li>找单词的长度是5或6，主要复习了列表生成式</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list = [x <span class="keyword">for</span> x <span class="keyword">in</span> text2 <span class="keyword">if</span> <span class="number">6</span>&gt;=len(x)&gt;=<span class="number">5</span>] <span class="comment">#利用列表生成式</span></span><br><span class="line"></span><br><span class="line">print(list)</span><br></pre></td></tr></table></figure><ul><li>统计每个字符串出现的次数，主要复习了Counter类的使用，常用于统计</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter <span class="comment">#统计每个字符串的出现次数</span></span><br><span class="line"></span><br><span class="line">result = dict(Counter(text2))</span><br><span class="line"></span><br><span class="line"><span class="comment">#output:输出字典形式的统计结果</span></span><br><span class="line">&#123;<span class="string">'empty'</span>: <span class="number">1</span>, <span class="string">'metadata'</span>: <span class="number">1</span>, <span class="string">'Scrapy'</span>: <span class="number">1</span>, <span class="string">'by'</span>: <span class="number">1</span>, <span class="string">'dict'</span>: <span class="number">3</span>, <span class="string">'the'</span>: <span class="number">2</span>, <span class="string">'contains'</span>: <span class="number">1</span>, <span class="string">'enabled.'</span>: <span class="number">1</span>, <span class="string">'So'</span>: <span class="number">1</span>, <span class="string">'contained'</span>: <span class="number">1</span>, <span class="string">'.'</span>: <span class="number">1</span>, <span class="string">'is'</span>: <span class="number">2</span>, <span class="string">'in'</span>: <span class="number">1</span>, <span class="string">'new'</span>: <span class="number">1</span>, <span class="string">'that'</span>: <span class="number">1</span>, <span class="string">'components'</span>: <span class="number">1</span>, <span class="string">'Requests,'</span>: <span class="number">1</span>, <span class="string">'different'</span>: <span class="number">1</span>, <span class="string">'This'</span>: <span class="number">1</span>, <span class="string">'depends'</span>: <span class="number">1</span>, <span class="string">'extensions'</span>: <span class="number">1</span>, <span class="string">'on'</span>: <span class="number">1</span>, <span class="string">'and'</span>: <span class="number">1</span>, <span class="string">'you'</span>: <span class="number">1</span>, <span class="string">'this'</span>: <span class="number">2</span>, <span class="string">'request.'</span>: <span class="number">1</span>, <span class="string">'arbitrary'</span>: <span class="number">1</span>, <span class="string">'for'</span>: <span class="number">2</span>, <span class="string">'have'</span>: <span class="number">1</span>, <span class="string">'populated'</span>: <span class="number">1</span>, <span class="string">'A'</span>: <span class="number">1</span>, <span class="string">'usually'</span>: <span class="number">1</span>, <span class="string">'data'</span>: <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><ul><li>字符串的拼接, join()函数和字符串拼接符“+”的运用和对比，建议大型拼接用join()</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">names=[<span class="string">'Hello'</span>,<span class="string">' James'</span>,<span class="string">','</span>,<span class="string">' how'</span>,<span class="string">' are'</span>,<span class="string">' you'</span>, <span class="string">'!'</span>]</span><br><span class="line"></span><br><span class="line">print(<span class="string">''</span>.join(names))</span><br><span class="line"></span><br><span class="line">---------------------------</span><br><span class="line">s=<span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> names:</span><br><span class="line">    s=s+i</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure><h1 id="0x02-字典-dict-的使用"><a href="#0x02-字典-dict-的使用" class="headerlink" title="0x02 字典(dict)的使用"></a>0x02 字典(dict)的使用</h1><ul><li>通过key,value排序，这里需要借助 dict.items() 方法以列表方式返回键值对</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">print(result.items())<span class="comment">#得到由元组组成的列表</span></span><br><span class="line"></span><br><span class="line">dict_items([(<span class="string">'empty'</span>, <span class="number">1</span>), (<span class="string">'metadata'</span>, <span class="number">1</span>), (<span class="string">'Scrapy'</span>, <span class="number">1</span>), (<span class="string">'by'</span>, <span class="number">1</span>), (<span class="string">'dict'</span>, <span class="number">3</span>), (<span class="string">'the'</span>, <span class="number">2</span>), (<span class="string">'contains'</span>, <span class="number">1</span>), (<span class="string">'enabled.'</span>, <span class="number">1</span>), (<span class="string">'So'</span>, <span class="number">1</span>), (<span class="string">'contained'</span>, <span class="number">1</span>), (<span class="string">'.'</span>, <span class="number">1</span>), (<span class="string">'is'</span>, <span class="number">2</span>), (<span class="string">'in'</span>, <span class="number">1</span>), (<span class="string">'new'</span>, <span class="number">1</span>), (<span class="string">'that'</span>, <span class="number">1</span>), (<span class="string">'components'</span>, <span class="number">1</span>), (<span class="string">'Requests,'</span>, <span class="number">1</span>), (<span class="string">'different'</span>, <span class="number">1</span>), (<span class="string">'This'</span>, <span class="number">1</span>), (<span class="string">'depends'</span>, <span class="number">1</span>), (<span class="string">'extensions'</span>, <span class="number">1</span>), (<span class="string">'on'</span>, <span class="number">1</span>), (<span class="string">'and'</span>, <span class="number">1</span>), (<span class="string">'you'</span>, <span class="number">1</span>), (<span class="string">'this'</span>, <span class="number">2</span>), (<span class="string">'request.'</span>, <span class="number">1</span>), (<span class="string">'arbitrary'</span>, <span class="number">1</span>), (<span class="string">'for'</span>, <span class="number">2</span>), (<span class="string">'have'</span>, <span class="number">1</span>), (<span class="string">'populated'</span>, <span class="number">1</span>), (<span class="string">'A'</span>, <span class="number">1</span>), (<span class="string">'usually'</span>, <span class="number">1</span>), (<span class="string">'data'</span>, <span class="number">1</span>)])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(sorted(result.items(),key = <span class="keyword">lambda</span> x:x[<span class="number">0</span>],reverse=<span class="keyword">True</span>)) <span class="comment">#以字典的key排序</span></span><br><span class="line"></span><br><span class="line">print(sorted(result.items(),key = <span class="keyword">lambda</span> x:x[<span class="number">1</span>],reverse=<span class="keyword">True</span>)) <span class="comment">#以字典的value排序</span></span><br></pre></td></tr></table></figure><ul><li>有序字典OrderedDict()，按照插入顺序进行输出</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"></span><br><span class="line">orderdict = OrderedDict() <span class="comment">#按输入的顺序有序输出</span></span><br><span class="line"></span><br><span class="line">orderdict[<span class="string">'a'</span>] = <span class="number">1</span></span><br><span class="line">orderdict[<span class="string">'b'</span>] = <span class="number">2</span></span><br><span class="line">orderdict[<span class="string">'c'</span>] = <span class="number">3</span></span><br><span class="line">orderdict[<span class="string">'d'</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">print(orderdict)</span><br><span class="line"></span><br><span class="line">dict = &#123;&#125; <span class="comment">#普通字典不能按输入的顺序输出，无序输出</span></span><br><span class="line"></span><br><span class="line">dict[<span class="string">'a'</span>] = <span class="number">1</span></span><br><span class="line">dict[<span class="string">'b'</span>] = <span class="number">2</span></span><br><span class="line">dict[<span class="string">'c'</span>] = <span class="number">3</span></span><br><span class="line">dict[<span class="string">'d'</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">print(dict)</span><br></pre></td></tr></table></figure><ul><li>字典的取值，建议用get()方法代替传统方法，增加代码健壮性</li></ul><p>传统的取值dict[key],当key不是字典dict的键，会引起异常，但get()当key不存在时会返回空，不会导致程序异常</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict = &#123;&#125;</span><br><span class="line"></span><br><span class="line">dict[<span class="string">'a'</span>] = <span class="number">1</span></span><br><span class="line">dict[<span class="string">'b'</span>] = <span class="number">2</span></span><br><span class="line">dict[<span class="string">'c'</span>] = <span class="number">3</span></span><br><span class="line">dict[<span class="string">'d'</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">print(dict(<span class="string">'e'</span>)) <span class="comment">#报错，程序终止</span></span><br><span class="line"></span><br><span class="line">print(dict.get(<span class="string">'e'</span>)) <span class="comment">#返回none，程序继续运行</span></span><br><span class="line"></span><br><span class="line">print(dict.get(<span class="string">'e'</span>,<span class="string">'not found'</span>)) <span class="comment">#自定义异常信息，返回not found，程序继续运行</span></span><br></pre></td></tr></table></figure><h1 id="0x03-Python操作集合的三架马车-filter、map-reduce、sorted-zip"><a href="#0x03-Python操作集合的三架马车-filter、map-reduce、sorted-zip" class="headerlink" title="0x03 Python操作集合的三架马车(filter、map/reduce、sorted)+zip()"></a>0x03 Python操作集合的三架马车(filter、map/reduce、sorted)+zip()</h1><ul><li>map()/reduce()</li></ul><p>map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line">r = map(f, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])</span><br><span class="line"></span><br><span class="line">print(r) <span class="comment">#函数返回一个map object，通过遍历得到每个值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> r:</span><br><span class="line">    print(item)</span><br><span class="line">    print(type(item))</span><br><span class="line"></span><br><span class="line">print(list(map(f,[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>])))<span class="comment"># 一句话解决问题</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#output</span></span><br><span class="line">&lt;map object at <span class="number">0x10e7d2d68</span>&gt;</span><br><span class="line"><span class="number">1</span></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">int</span>'&gt;</span></span><br><span class="line"><span class="class">4</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">int</span>'&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">.......</span></span><br><span class="line"><span class="class"></span></span><br><span class="line">[1, 4, 9, 16, 25, 36, 49, 64, 81]</span><br></pre></td></tr></table></figure><p>reduce()把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算</p><ul><li>filter()</li></ul><p>和map()类似，filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">not_empty</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> s <span class="keyword">and</span> s.strip()</span><br><span class="line"></span><br><span class="line">print(filter(not_empty, [<span class="string">'A'</span>, <span class="string">''</span>, <span class="string">'B'</span>, <span class="keyword">None</span>, <span class="string">'C'</span>, <span class="string">'  '</span>]))</span><br><span class="line"></span><br><span class="line">print(list(filter(not_empty, [<span class="string">'A'</span>, <span class="string">''</span>, <span class="string">'B'</span>, <span class="keyword">None</span>, <span class="string">'C'</span>, <span class="string">'  '</span>])))</span><br><span class="line"></span><br><span class="line"><span class="comment">#output</span></span><br><span class="line"></span><br><span class="line">&lt;filter object at <span class="number">0x100da1cf8</span>&gt; <span class="comment">#返回一个惰性序列</span></span><br><span class="line"></span><br><span class="line">[<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]<span class="comment">#用list()函数遍历求解</span></span><br></pre></td></tr></table></figure><ul><li>sorted()</li></ul><p>sorted()函数就可以对list进行排序,此外，sorted()函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">L = [(<span class="string">'Bob'</span>, <span class="number">75</span>), (<span class="string">'Adam'</span>, <span class="number">92</span>), (<span class="string">'Bart'</span>, <span class="number">66</span>), (<span class="string">'Lisa'</span>, <span class="number">88</span>)]</span><br><span class="line"></span><br><span class="line">print(sorted(L,key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>],reverse=<span class="keyword">True</span>)) <span class="comment">#对数字又高到低排列</span></span><br><span class="line"></span><br><span class="line">print(sorted(L,key=<span class="keyword">lambda</span> x:str(x[<span class="number">0</span>].lower))) <span class="comment">#对名字进行大小写不敏感排列</span></span><br></pre></td></tr></table></figure><ul><li>zip()</li></ul><p>zip()是 Python 的一个内建函数，它接受一系列可迭代的对象作为参数，将对象中对应的元素打包成一个个tuple（元组），然后返回由这些tuples组成的list（列表）。若传入参数的长度不等，则返回 list 的长度和参数中长度最短的对象相同。利用*号操作符，可以将list unzip（解压）。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">l2 = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</span><br><span class="line"></span><br><span class="line">l4 = zip(l1,l2) </span><br><span class="line"></span><br><span class="line">print(l4)<span class="comment">#输出惰性序列</span></span><br><span class="line"></span><br><span class="line">l4 = tuple(zip(l1,l2)) <span class="comment">#使用tuple()函数遍历得到元组</span></span><br><span class="line"></span><br><span class="line">print(l4)</span><br><span class="line"></span><br><span class="line">l5 = dict(l4) <span class="comment">#转化为字典</span></span><br><span class="line"></span><br><span class="line">print(l5)</span><br><span class="line"></span><br><span class="line"><span class="comment">#output</span></span><br><span class="line"></span><br><span class="line">&lt;zip object at <span class="number">0x1078e0848</span>&gt;</span><br><span class="line">((<span class="number">1</span>, <span class="string">'a'</span>), (<span class="number">2</span>, <span class="string">'b'</span>), (<span class="number">3</span>, <span class="string">'c'</span>), (<span class="number">4</span>, <span class="string">'d'</span>))</span><br><span class="line">&#123;<span class="number">1</span>: <span class="string">'a'</span>, <span class="number">2</span>: <span class="string">'b'</span>, <span class="number">3</span>: <span class="string">'c'</span>, <span class="number">4</span>: <span class="string">'d'</span>&#125;</span><br></pre></td></tr></table></figure><h1 id="0x04-枚举-enumerate-–-Python内置函数"><a href="#0x04-枚举-enumerate-–-Python内置函数" class="headerlink" title="0x04 枚举(enumerate) – Python内置函数"></a>0x04 枚举(enumerate) – Python内置函数</h1><p>常常会在别人的代码中看到它的身影,它允许我们遍历数据并自动计数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'grapes'</span>, <span class="string">'pear'</span>]</span><br><span class="line"><span class="keyword">for</span> c, value <span class="keyword">in</span> enumerate(my_list,<span class="number">1</span>):</span><br><span class="line">    print(c, value)</span><br><span class="line"></span><br><span class="line">print(enumerate(my_list,<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">print(dict(enumerate(my_list,<span class="number">1</span>)))</span><br><span class="line">print(list(enumerate(my_list,<span class="number">1</span>)))</span><br><span class="line">print(tuple(enumerate(my_list,<span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment">#output:</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> apple</span><br><span class="line"><span class="number">2</span> banana</span><br><span class="line"><span class="number">3</span> grapes</span><br><span class="line"><span class="number">4</span> pear</span><br><span class="line">&lt;enumerate object at <span class="number">0x103d10828</span>&gt; <span class="comment">#输出惰性序列</span></span><br><span class="line">&#123;<span class="number">1</span>: <span class="string">'apple'</span>, <span class="number">2</span>: <span class="string">'banana'</span>, <span class="number">3</span>: <span class="string">'grapes'</span>, <span class="number">4</span>: <span class="string">'pear'</span>&#125;</span><br><span class="line">[(<span class="number">1</span>, <span class="string">'apple'</span>), (<span class="number">2</span>, <span class="string">'banana'</span>), (<span class="number">3</span>, <span class="string">'grapes'</span>), (<span class="number">4</span>, <span class="string">'pear'</span>)]</span><br><span class="line">((<span class="number">1</span>, <span class="string">'apple'</span>), (<span class="number">2</span>, <span class="string">'banana'</span>), (<span class="number">3</span>, <span class="string">'grapes'</span>), (<span class="number">4</span>, <span class="string">'pear'</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;跟着“菜鸟学Python”这个我最喜欢的公众号文章做点练习和巩固基本套路&lt;/p&gt;
&lt;h1 id=&quot;0
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Scrapy使用简介_2</title>
    <link href="http://yoursite.com/2018/03/02/Scrapy%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B-2/"/>
    <id>http://yoursite.com/2018/03/02/Scrapy使用简介-2/</id>
    <published>2018-03-02T10:22:12.000Z</published>
    <updated>2018-03-02T06:03:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>继续介绍Scrapy的其他用法，丰富一下各种姿势</p><h1 id="0x01-Scrapy里面的request对象"><a href="#0x01-Scrapy里面的request对象" class="headerlink" title="0x01 Scrapy里面的request对象"></a>0x01 Scrapy里面的request对象</h1><p>request对象是在Scrapy编写中经常要用到的，你要发送一个请求给调度器爬娶，就必须构造request对象，这个对象里面有各种属性可以使用，例如设置request的header，cookie等，下面是request基础参数：</p><ul><li><p>url —— 请求的url</p></li><li><p>callback —— 请求回来的reseponse处理函数，也叫回调函数</p></li><li><p>headers —— 页面的headers数据</p></li><li><p>cookies —— 设置页面的cookies，下面是一些小例子。<strong>这里没有设置callback，Scrapy会默认调用parse()函数作为callback函数传入</strong></p></li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#传入多个键值对：列表</span></span><br><span class="line">request_with_cookies = Request(url=<span class="string">"http://www.example.com"</span>,</span><br><span class="line">                               cookies=[&#123;<span class="string">'name'</span>: <span class="string">'currency'</span>,</span><br><span class="line">                                        <span class="string">'value'</span>: <span class="string">'USD'</span>,</span><br><span class="line">                                        <span class="string">'domain'</span>: <span class="string">'example.com'</span>,</span><br><span class="line">                                        <span class="string">'path'</span>: <span class="string">'/currency'</span>&#125;])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#传入单一键值对：字典</span></span><br><span class="line">request_with_cookies = Request(url=<span class="string">"http://www.example.com"</span>,</span><br><span class="line">                               cookies=&#123;<span class="string">'currency'</span>: <span class="string">'USD'</span>, <span class="string">'country'</span>: <span class="string">'UY'</span>&#125;)</span><br></pre></td></tr></table></figure><ul><li>meta —— 最神奇的参数，它是一个字典，可以用来做页面间传值，但同时又一大堆重要的健值，适当设置可以精细化你的request，先看看如何传值</li></ul><p>我对前面的猫眼做了一点改写，把保存了数据的item对象传了meta字典保存：meta = {“key” : item} ，然后通过这个新的Request对象调用的新的url，传到新的callback：parse2 ，然后取出meta里面的数据交给pipeline处理，这样我就实现了数据在页面间传递了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line"></span><br><span class="line">    nodelist = response.xpath(<span class="string">"//div[@class='board-item-main']"</span>)</span><br><span class="line">    <span class="keyword">for</span> node <span class="keyword">in</span> nodelist:</span><br><span class="line">        item = MaoyanItem()</span><br><span class="line">        item[<span class="string">'name'</span>] = node.xpath(<span class="string">".//a/text()"</span>).extract()[<span class="number">0</span>]</span><br><span class="line">        item[<span class="string">'actors'</span>] = node.xpath(<span class="string">".//p[@class='star']/text()"</span>).extract()[<span class="number">0</span>].split()</span><br><span class="line">        integer = node.xpath(<span class="string">".//i[@class='integer']/text()"</span>).extract()[<span class="number">0</span>]</span><br><span class="line">        fraction = node.xpath(<span class="string">".//i[@class='fraction']/text()"</span>).extract()[<span class="number">0</span>]</span><br><span class="line">        item[<span class="string">'score'</span>] = integer+fraction</span><br><span class="line">        <span class="keyword">if</span> self.offset &lt; <span class="number">10</span>:</span><br><span class="line">            self.offset += <span class="number">10</span></span><br><span class="line">            url = self.base_url + str(self.offset)</span><br><span class="line">            <span class="comment"># url = response.urljoin(str(self.offset))</span></span><br><span class="line">        <span class="comment">#yield response.follow(str(self.offset),callback = self.parse2 ,meta = &#123;"key" : item&#125;,dont_filter = True)</span></span><br><span class="line">        <span class="keyword">yield</span> scrapy.Request(url, callback = self.parse2 ,meta = &#123;<span class="string">"key"</span> : item&#125;,dont_filter = <span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse2</span><span class="params">(self,response)</span>:</span></span><br><span class="line"></span><br><span class="line">    item = response.meta[<span class="string">"key"</span>]</span><br><span class="line">    <span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure><p>官方解释meta：</p><blockquote><p>A dict that contains arbitrary metadata for this request. This dict is empty for new Requests, and is usually populated by different Scrapy components (extensions, middlewares, etc). So the data contained in this dict depends on the extensions you have enabled.</p><p>See Request.meta special keys for a list of special meta keys recognized by Scrapy.</p><p>This dict is shallow copied when the request is cloned using the copy() or replace() methods, and can also be accessed, in your spider, from the response.meta attribute.</p></blockquote><p>其他详细的meta特殊字典健值可以参考下面的官方链接：</p><p><a href="https://doc.scrapy.org/en/latest/topics/request-response.html#topics-request-meta" target="_blank" rel="noopener">https://doc.scrapy.org/en/latest/topics/request-response.html#topics-request-meta</a></p><h1 id="0x02-Request对象的源码解读"><a href="#0x02-Request对象的源码解读" class="headerlink" title="0x02 Request对象的源码解读"></a>0x02 Request对象的源码解读</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Request</span><span class="params">(object_ref)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, url, callback=None, method=<span class="string">'GET'</span>, headers=None, body=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                 cookies=None, meta=None, encoding=<span class="string">'utf-8'</span>, priority=<span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 dont_filter=False, errback=None, flags=None)</span>:</span></span><br><span class="line"></span><br><span class="line">        self._encoding = encoding  <span class="comment"># this one has to be set first</span></span><br><span class="line">        self.method = str(method).upper()</span><br><span class="line">        self._set_url(url)</span><br><span class="line">        self._set_body(body)</span><br><span class="line">        <span class="keyword">assert</span> isinstance(priority, int), <span class="string">"Request priority not an integer: %r"</span> % priority</span><br><span class="line">        self.priority = priority</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> callback <span class="keyword">or</span> <span class="keyword">not</span> errback, <span class="string">"Cannot use errback without a callback"</span></span><br><span class="line">        self.callback = callback</span><br><span class="line">        self.errback = errback</span><br><span class="line"></span><br><span class="line">        self.cookies = cookies <span class="keyword">or</span> &#123;&#125;</span><br><span class="line">        self.headers = Headers(headers <span class="keyword">or</span> &#123;&#125;, encoding=encoding)</span><br><span class="line">        self.dont_filter = dont_filter</span><br><span class="line"></span><br><span class="line">        self._meta = dict(meta) <span class="keyword">if</span> meta <span class="keyword">else</span> <span class="keyword">None</span></span><br><span class="line">        self.flags = [] <span class="keyword">if</span> flags <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">else</span> list(flags)</span><br></pre></td></tr></table></figure><p>看到很多对应的东西，例如meta的初始化处理，cookies和headers接受的格式等，建议仔细阅读</p><h1 id="0x03-Scrapy里面的response对象"><a href="#0x03-Scrapy里面的response对象" class="headerlink" title="0x03 Scrapy里面的response对象"></a>0x03 Scrapy里面的response对象</h1><ul><li>基础参数</li></ul><p>url——请求的url<br>body——请求回来的html<br>meta——用来在“页面”之间传递数据<br>headers——页面的headers数据<br>cookies——设置页面的cookies<br>Request——发出这个response的request对象</p><p>基本和Request对象一一对应，主要介绍一下两个新的方法，</p><p>urljoin()：将页面相对路径改为绝对路径 </p><p><strong>follow()：对相对路径进行自动补全，构造出绝对路径，可以说是URLjoin的升级版，因为这个方法直接返回Request对象</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> self.offset &lt; <span class="number">10</span>:</span><br><span class="line">    self.offset += <span class="number">10</span></span><br><span class="line">    url = response.urljoin(str(self.offset)) <span class="comment">#利用urljoin()构造绝对路径，再传入Request</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">yield</span> scrapy.Request(url, callback = self.parse2 ,meta = &#123;<span class="string">"key"</span> : item&#125;,dont_filter = <span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#直接利用response的follow()方法构造Request</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">yield</span> response.follow(str(self.offset),callback = self.parse2 ,meta = &#123;<span class="string">"key"</span> : item&#125;,dont_filter = <span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p>refer：</p><p><a href="https://doc.scrapy.org/en/latest/topics/request-response.html#scrapy.http.Response" target="_blank" rel="noopener">https://doc.scrapy.org/en/latest/topics/request-response.html#scrapy.http.Response</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;继续介绍Scrapy的其他用法，丰富一下各种姿势&lt;/p&gt;
&lt;h1 id=&quot;0x01-Scrapy里面
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>SSL握手过程</title>
    <link href="http://yoursite.com/2018/03/01/SSL%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/03/01/SSL握手过程/</id>
    <published>2018-03-01T15:22:25.000Z</published>
    <updated>2018-03-01T07:26:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下SSL的握手过程，里面涉及到了很多基础概念，例如密码学，证书，PKI等</p><p>详细叙述：</p><p>1、浏览器将自己支持的加密规则(也就是 CipherSuite )发给服务器</p><p>2、服务器端收到请求，然后从客户支持的 CipherSuite 中选出一个应答,并发送给客户端公钥证书和选用的 HASH 算法</p><p>3、客户端收到公钥之后,利用自己的信任的根证书对收到的公钥进行验证.若通过,客户端随机生成对称密钥 (Pre-Master secret),然后使用公钥对对称密钥进行加密,并计算连接中全部报文信息的 hash ,再利用生成的对称密钥对 hash 值加密,然后把公钥加密的对称密钥及对称密钥加密的 hash 值发送给服务器.</p><p>4、服务器利用自己的私钥对利用公钥加密的对称密钥进行解密,得到对称密钥. 再利用对称密钥解密 hash 值,对 hash 值进行验证.在验证成功后，会返回给客户端 Finish 报文。（至此，ssl 连接建立成功）</p><p>5、ssl 连接建立完成之后信息的传输加密过程是这样的:</p><p>客户端:先用对称密钥加密要传输的信息,再利用 hash 算法得出加了密的信息的 hash 值.再利用公钥对 hash 值进行加密,之后把对称密钥加密了的信息和利用公钥加密后信息的 hash 值,传输给服务器. </p><p>服务器: 与客户端基本相同，不过把公钥加密换做私钥加密。</p><p>refer:</p><p><a href="http://mp.weixin.qq.com/s/W620Pdu6qvoqjacSRPRVyg" target="_blank" rel="noopener">http://mp.weixin.qq.com/s/W620Pdu6qvoqjacSRPRVyg</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录一下SSL的握手过程，里面涉及到了很多基础概念，例如密码学，证书，PKI等&lt;/p&gt;
&lt;p&gt;详细叙述：&lt;/p&gt;
&lt;p&gt;1、浏览器将自己支持的加密规则(也就是 CipherSuite )发给服务器&lt;/p&gt;
&lt;p&gt;2、服务器端收到请求，然后从客户支持的 CipherSuite
      
    
    </summary>
    
    
      <category term="Web security" scheme="http://yoursite.com/tags/Web-security/"/>
    
  </entry>
  
  <entry>
    <title>Scrapy使用简介_1</title>
    <link href="http://yoursite.com/2018/02/28/Scrapy%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B-1/"/>
    <id>http://yoursite.com/2018/02/28/Scrapy使用简介-1/</id>
    <published>2018-02-27T17:22:12.000Z</published>
    <updated>2018-03-02T02:54:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>上一篇笔记记录了学习Python爬虫的简单思路，然后就要对Python爬虫框架进行基本使用了，玩玩更健康</p><h1 id="0x01-Scrapy基本介绍"><a href="#0x01-Scrapy基本介绍" class="headerlink" title="0x01 Scrapy基本介绍"></a>0x01 Scrapy基本介绍</h1><ul><li>基本数据流图解：</li></ul><p><img src="/images/scrapyworkflow.png" alt="数据流图"></p><ul><li>基本数据流程：</li></ul><ol><li>Spiders发送第一个URL给引擎</li><li>引擎从Spider中获取到第一个要爬取的URL后，在调度器(Scheduler)以Request调度</li><li>调度器把需要爬取的request返回给引擎</li><li>引擎将request通过下载中间件发给下载器(Downloader)去互联网下载数据</li><li>一旦数据下载完毕，下载器获取由互联网服务器发回来的Response，并将其通过下载中间件发送给引擎</li><li>引擎从下载器中接收到Response并通过Spider中间件发送给Spider处理</li><li>Spider处理Response并从中返回匹配到的Item及(跟进的)新的Request给引擎</li><li>引擎将(Spider返回的)爬取到的Item给Item Pipeline做数据处理或者入库保存，将(Spider返回的)Request给调度器入队列</li><li>(从第三步)重复直到调度器中没有更多的request</li></ol><ul><li>简单的说：</li></ul><p>引擎是大脑，负责在各组件中调度传递信息。我们要编写的几个主要组件就是spider，pipeline和中间件</p><ul><li>项目结构：</li></ul><p><img src="/images/structure.png" alt="项目结构图"></p><ul><li>编程思路：</li></ul><p>还是以猫眼这个简单例子，这次使用了scrapy来实现，首先编写maoyan_top.py,实现爬虫主程序，也就是定义一个爬虫，然后编写items.py定义一个存储数据的数据结构，类似dict，最后编写pipelines.py实现数据存储，这就是最简单的scrapy实现思路</p><ul><li>首先编写maoyan_top.py，主要就是编写MaoyanTopSpider类，这个类继承scrapy.Spider，定义好基本URL的数据后，就是主力编写parse函数，这个函数就是负责解析数据的。注意这里我yield了item给pipelines.py处理，yield了scrapy.Request给调度器进行翻页爬取</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> ..items <span class="keyword">import</span> MaoyanItem</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaoyanTopSpider</span><span class="params">(scrapy.Spider)</span>:</span></span><br><span class="line">    name = <span class="string">'maoyan_top'</span></span><br><span class="line">    allowed_domains = [<span class="string">'maoyan.com'</span>]</span><br><span class="line">    base_url = <span class="string">"https://maoyan.com/board/4?offset="</span></span><br><span class="line">    offset = <span class="number">0</span></span><br><span class="line">    start_urls = [base_url + str(offset)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, response)</span>:</span></span><br><span class="line"></span><br><span class="line">        nodelist = response.xpath(<span class="string">"//div[@class='board-item-main']"</span>)</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> nodelist:</span><br><span class="line">            item = MaoyanItem()</span><br><span class="line">            item[<span class="string">'name'</span>] = node.xpath(<span class="string">".//a/text()"</span>).extract()[<span class="number">0</span>]</span><br><span class="line">            item[<span class="string">'actors'</span>] = node.xpath(<span class="string">".//p[@class='star']/text()"</span>).extract()[<span class="number">0</span>].split()</span><br><span class="line">            integer = node.xpath(<span class="string">".//i[@class='integer']/text()"</span>).extract()[<span class="number">0</span>]</span><br><span class="line">            fraction = node.xpath(<span class="string">".//i[@class='fraction']/text()"</span>).extract()[<span class="number">0</span>]</span><br><span class="line">            item[<span class="string">'score'</span>] = integer+fraction</span><br><span class="line">            <span class="keyword">yield</span> item</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.offset &lt; <span class="number">100</span>:</span><br><span class="line">            self.offset += <span class="number">10</span></span><br><span class="line">            url = self.base_url+str(self.offset)</span><br><span class="line">            <span class="keyword">yield</span> scrapy.Request(url,callback = self.parse)</span><br></pre></td></tr></table></figure><ul><li>然后编写items.py定义一个存储数据的数据结构给上面的parse函数使用,非常简单我就定义了三个字段，分别为电影的名字，评分和演员</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaoyanItem</span><span class="params">(scrapy.Item)</span>:</span></span><br><span class="line">    <span class="comment"># define the fields for your item here like:</span></span><br><span class="line">    name = scrapy.Field()</span><br><span class="line">    actors = scrapy.Field()</span><br><span class="line">    score = scrapy.Field()</span><br></pre></td></tr></table></figure><ul><li>最后编写pipelines.py进行存储数据，这里要注意parse函数yield出来的item会到达这里处理</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaoyanPipeline</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open_spider</span><span class="params">(self,spider)</span>:</span></span><br><span class="line">        print(type(spider))</span><br><span class="line">        print(<span class="string">"open file"</span>)</span><br><span class="line"></span><br><span class="line">        self.f = open(<span class="string">'/Users/Rick7/Desktop/items.json'</span>, <span class="string">'w+'</span>,encoding=<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_item</span><span class="params">(self, item, spider)</span>:</span></span><br><span class="line"></span><br><span class="line">        line = json.dumps(dict(item),ensure_ascii=<span class="keyword">False</span>) + <span class="string">"\n"</span></span><br><span class="line">        self.f.write(line)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close_spider</span><span class="params">(self,spider)</span>:</span></span><br><span class="line"></span><br><span class="line">        self.f.close()</span><br><span class="line">        print(<span class="string">"close file"</span>)</span><br></pre></td></tr></table></figure><ul><li>配置好setting文件激活管道，程序完成</li></ul><h1 id="0x02-总结"><a href="#0x02-总结" class="headerlink" title="0x02 总结"></a>0x02 总结</h1><ul><li>要学scrapy首先要搞清楚这个框架的数据流</li><li>建议阅读官方文档了解其中的类和方法</li><li>后面还会继续学习高级一点点的知识，例如url去重，中间件的使用等</li></ul><p>refer：</p><p><a href="https://doc.scrapy.org/en/latest/index.html" target="_blank" rel="noopener">https://doc.scrapy.org/en/latest/index.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;上一篇笔记记录了学习Python爬虫的简单思路，然后就要对Python爬虫框架进行基本使用了，玩玩更
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫小总结</title>
    <link href="http://yoursite.com/2018/02/28/Python%E7%88%AC%E8%99%AB%E5%B0%8F%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/02/28/Python爬虫小总结/</id>
    <published>2018-02-27T16:54:37.000Z</published>
    <updated>2018-02-28T03:44:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>最近玩了一下Python的爬虫，感觉这个东西对Python初学者还是挺友好的，适合入门Python</p><h1 id="0x01-简单编程套路"><a href="#0x01-简单编程套路" class="headerlink" title="0x01 简单编程套路"></a>0x01 简单编程套路</h1><ul><li>requests 库发送请求</li><li>Beautifulsoap,Xpath,Pyquiry,正则，等解释库提取数据</li><li>储存数据到文件或者数据库</li></ul><p>下面通过一个简单的对猫眼榜单的爬取代码体现上面的思路：</p><ul><li>get_onepage(url)函数发送请求，主要使用requests库</li><li>parse_onepage(content)函数负责解释和提取数据，主要使用了Beautifulsoap</li><li>save_csv(content)函数就是把数据保存到CSV文件</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_onepage</span><span class="params">(url)</span>:</span></span><br><span class="line">    headers = &#123;<span class="string">'user-agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) '</span></span><br><span class="line">                             <span class="string">'Chrome/60.0.3112.113 Safari/537.36'</span>&#125;</span><br><span class="line">    raw_content = requests.get(url,headers=headers)</span><br><span class="line">    raw_content.encoding = <span class="string">'utf-8'</span></span><br><span class="line">    <span class="comment"># print(raw_content.text)</span></span><br><span class="line">    <span class="keyword">return</span> raw_content.text</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_onepage</span><span class="params">(content)</span>:</span></span><br><span class="line">    soup = BeautifulSoup(content,<span class="string">'lxml'</span>)</span><br><span class="line">    movie_item = soup.find_all(<span class="string">'dd'</span>)</span><br><span class="line">    <span class="keyword">for</span> items <span class="keyword">in</span> movie_item:</span><br><span class="line">        dict = &#123;<span class="string">'index'</span>: <span class="string">''</span>, <span class="string">'title'</span>: <span class="string">''</span>, <span class="string">'star'</span>: <span class="string">''</span>&#125;</span><br><span class="line">        movie_index = items.find(<span class="string">'i'</span>,class_ = <span class="string">"board-index"</span>)</span><br><span class="line">        dict[<span class="string">'index'</span>] = movie_index.get_text()</span><br><span class="line">        movie_title = items.find(<span class="string">'p'</span>,attrs = &#123;<span class="string">'class'</span>: <span class="string">'name'</span>&#125;)</span><br><span class="line">        dict[<span class="string">'title'</span>] = movie_title.find(<span class="string">'a'</span>).get_text()</span><br><span class="line">        movie_actor = items.find(<span class="string">'p'</span>,attrs = &#123;<span class="string">'class'</span>: <span class="string">'star'</span>&#125;)</span><br><span class="line">        dict[<span class="string">'star'</span>] = movie_actor.get_text().strip()</span><br><span class="line">        <span class="keyword">yield</span> dict</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_csv</span><span class="params">(content)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">"/Users/Rick7/Desktop/data.csv"</span>,<span class="string">'a'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line">        fieldnames = [<span class="string">'index'</span>, <span class="string">'title'</span>, <span class="string">'star'</span>]</span><br><span class="line">        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)</span><br><span class="line">        writer.writeheader()</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> parse_onepage(content):</span><br><span class="line">            writer.writerow(item)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(offset_number)</span>:</span></span><br><span class="line">    url = <span class="string">"http://maoyan.com/board/4?offset="</span>+str(offset_number)</span><br><span class="line">    html = get_onepage(url)</span><br><span class="line">    save_csv(html)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        i=i*<span class="number">10</span></span><br><span class="line">        main(i)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h1 id="0x02-总结"><a href="#0x02-总结" class="headerlink" title="0x02 总结"></a>0x02 总结</h1><ul><li>这是最简单的爬虫小程序，从中要体会里面思路</li><li>上面的小程序只针对静态页面，对于动态的Ajax加载，使用过selenium，不过感觉十分慢和不友好，建议抓包找去真实的URL比较实际</li><li>比起beautifulsoap，感觉xpath提取数据更加高效简洁</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;最近玩了一下Python的爬虫，感觉这个东西对Python初学者还是挺友好的，适合入门Python&lt;
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>OAuth 2.0 笔记_1</title>
    <link href="http://yoursite.com/2018/02/13/OAuth-2-0-%E7%AC%94%E8%AE%B01/"/>
    <id>http://yoursite.com/2018/02/13/OAuth-2-0-笔记1/</id>
    <published>2018-02-13T15:47:52.000Z</published>
    <updated>2018-03-15T07:56:42.163Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>最近OAuth又出了一个漏洞，根据漏洞介绍这个漏洞不在OAuth协议，而在用户的部署上，等详细分析吧，漏洞链接如下，借此机会复习一下OAuth2.0</p><p><a href="http://www.cnvd.org.cn/flaw/show/CNVD-2018-01622" target="_blank" rel="noopener">http://www.cnvd.org.cn/flaw/show/CNVD-2018-01622</a></p><h1 id="0x01-OAuth-2-0-流程"><a href="#0x01-OAuth-2-0-流程" class="headerlink" title="0x01 OAuth 2.0 流程"></a>0x01 OAuth 2.0 流程</h1><p>详细的交换就不写了，网上一大堆，简单总结两句授权码模式（authorization code），包括了(用户A，网站B，GitHub(信息提供者,resource owner))</p><p>前提：网站B要想得到GitHub认证，必须先和GitHub协商可以取得什么权限等事情，这时候GitHub认可了网站B的合法性并同意网站B可以使用GitHub的相关用户资料，并给了网站B：Client Id 和 Client Secret。</p><ol><li><p>用户A想登陆网站B，但不想注册，所以点击了下面的GitHub图标，想通过GitHub账号登陆网站B,这时候就触发了OAuth认证</p></li><li><p>网站带着GitHub颁发的Client Id 到 ”<a href="https://github.com/login/oauth/authorize“" target="_blank" rel="noopener">https://github.com/login/oauth/authorize“</a> 请求权限，这时候会显示网站B从GitHub会取得什么权限，如果用户觉得ok就点击授权，不ok就拒绝，认证结束</p></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /authorize?response_type=code&amp;client_id=s6BhdRkqt3&amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1</span><br><span class="line">Host: github.com</span><br></pre></td></tr></table></figure><ol><li>当如何点击授权后，页面会跳转到网站B预先设定的 redirect_uri 并附带一个授权码(code)</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 302 Found</span><br><span class="line">Location: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA</span><br></pre></td></tr></table></figure><ol><li>用户A的浏览器得到一个302的回复，然后重定向到网站B指定redirect_uri，网站B从而得到了code，然后网站B拿着 code 和能够标识个人身份的 “client_id “,client_secret“ 去拜访 github，拿到access_token，这里的“client_id “,client_secret“ 是Github判断这个请求的合法性依据，”,client_secret“这个是网站B独有的。</li></ol><figure class="highlight"><table><tr><td class="code"><pre><span class="line">POST //github.com/login/oauth/access_token</span><br><span class="line">params = &#123;</span><br><span class="line">  code: "xxx",</span><br><span class="line">  client_id: "xxx",</span><br><span class="line">  client_secret: "xxx",</span><br><span class="line">  redirect_uri: "http://my-website.com"</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">response = &#123;</span><br><span class="line">  access_token: "e72e16c7e42f292c6912e7710c838347ae178b4a"</span><br><span class="line">  scope: "user,gist"</span><br><span class="line">  token_type: "bearer",</span><br><span class="line">  refresh_token: "xxxx"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>从上面的response中得到了access_token，相应的scope，网站B可以凭借这个token来取得用户在GitHub的信息，至于能够取得的信息范围就由scope来定义了，用户A可以使用GitHub的账号登陆网站B了。这就是授权码模式的简单描述。</li></ol><h1 id="0x02-已知的安全问题-CSRF"><a href="#0x02-已知的安全问题-CSRF" class="headerlink" title="0x02 已知的安全问题-CSRF"></a>0x02 已知的安全问题-CSRF</h1><ol><li>漏洞原理</li></ol><blockquote><p>这个问题的关键点在于，OAuth2的认证流程是分为好几步来完成的，在图1中的第4步，第三方应用在收到一个GET请求时，除了能知道当前用户的cookie，以及URL中的Authorization Code之外，难以分辨出这个请求到底是用户本人的意愿，还是攻击者利用用户的身份伪造出来的请求。 于是乎，攻击者就能使用移花接木的手段，提前准备一个含有自己的Authorization Code的请求，并让受害者的浏览器来接着完成后续的令牌申请流程。(知乎转载)</p></blockquote><ol><li>详细分析</li></ol><p>回顾一下上面简单总结的第四步：</p><blockquote><p>用户A的浏览器得到一个302的回复，然后重定向到网站B指定redirect_uri，网站B从而得到了code，然后网站B拿着 code 和能够标识个人身份的 “client_id “,client_secret“ 去拜访 github，拿到access_token，这里的“client_id “,client_secret“ 是Github判断这个请求的合法性依据，”,client_secret“这个是网站B独有的。</p></blockquote><p>这里面有个问题就是用户A的浏览器根据302状态码把code redirect到网站B,这个code是和将要登录网站B的账号关联的，如果攻击者替换了用户A这个请求，把里面的code换成攻击者账号的，然后网站B继续完成OAuth的认证流程，这会造成用户A在网站B的账号和攻击者的GitHub账号绑定了，攻击者只要在网站B通过GitHub登录就能成功登录用户A在网站B的账号了。<strong>因此这个漏洞本质是欺骗网站B</strong></p><p><img src="/images/CSRF OAuth.jpg" alt="攻击图"></p><ol><li>攻击成功条件</li></ol><ul><li>用户A的User Session是valid的</li><li>OAuth2提供者颁发的Authorization Code有效期很短，OAuth2官方推荐的时间是不大于10分钟，所以要快</li><li>一个Authorization Code只能被使用一次</li></ul><h1 id="0x03-如何防御"><a href="#0x03-如何防御" class="headerlink" title="0x03 如何防御"></a>0x03 如何防御</h1><p>刚才提到了，既然这个漏洞本质是欺骗网站B，那么要做防御的当然在网站B了，网站B要确保用户发去GitHub的授权码(Authorization Code)申请和用户redirect回来的授权码是一致的，怎么做呢？就是加一个唯一的，随机的参数state来确保唯一性</p><ul><li>首先，网站B redirect 用户A到GitHub申请授权码的时候带上”state=xyz“参数</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /authorize?response_type=code&amp;client_id=s6BhdRkqt3&amp;state=xyz</span><br><span class="line">        &amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br></pre></td></tr></table></figure><ul><li>然后，用户A的浏览器收到GitHub发来的302带着授权码redirect回到B网站时，GitHub会根据申请code时的请求在302的location中带上”state=xyz“</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 302 Found</span><br><span class="line">Location: https://B.com/cb?code=SplxlOBeZQQYbYS6WxSbIA</span><br><span class="line">          &amp;state=xyz</span><br></pre></td></tr></table></figure><ul><li><p>这样网站B就可以根据state参数确认这个code对应哪一个用户了</p></li><li><p>要避免遭受本文提到的CSRF攻击问题，需要第三方应用正确的使用state参数</p></li></ul><h1 id="Refer-link"><a href="#Refer-link" class="headerlink" title="Refer link"></a>Refer link</h1><p><a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html</a></p><p><a href="https://aaronparecki.com/oauth-2-simplified/" target="_blank" rel="noopener">https://aaronparecki.com/oauth-2-simplified/</a></p><p><a href="https://www.zhihu.com/question/19781476" target="_blank" rel="noopener">https://www.zhihu.com/question/19781476</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;最近OAuth又出了一个漏洞，根据漏洞介绍这个漏洞不在OAuth协议，而在用户的部署上，等详细分析吧
      
    
    </summary>
    
    
      <category term="Web security" scheme="http://yoursite.com/tags/Web-security/"/>
    
  </entry>
  
  <entry>
    <title>Same-Origin Protection (SOP)</title>
    <link href="http://yoursite.com/2018/02/09/Same-Origin-Protection-SOP/"/>
    <id>http://yoursite.com/2018/02/09/Same-Origin-Protection-SOP/</id>
    <published>2018-02-09T10:39:27.000Z</published>
    <updated>2018-02-28T03:46:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-什么是同源策略-SOP"><a href="#0x00-什么是同源策略-SOP" class="headerlink" title="0x00 什么是同源策略(SOP)"></a>0x00 什么是同源策略(SOP)</h1><p>在Web安全中，SOP是一个非常重要安全策略，必须要弄懂才能对很多攻击有更加清晰的理解，那什么是同源策略呢？下面是我本人的理解：</p><p><strong>同源策略是一个浏览器中内建的安全策略，它确保不同源的网站不能互相作用或者互相交换。</strong></p><ul><li><p>不同源指的是协议(https,http,ftp…),不同端口(80,443,22,21),不同域名。</p></li><li><p>不能互相作用或者互相交换是指：A网站即使和B网站不同源，但仍然可以发送request到B网站，这个请求在B网站还是会处理的，但A网站不能读取response，总结一句就是：跨域请求是可以发去的，但是请求响应response被浏览器堵塞了，所以说同源策略是限制了不同源的读，但不限制不同源的写</p></li><li><p>由于同源策略的限制，跨域的ajax请求不会带cookie，然而script/iframe/img等标签却是支持跨域的，所以在请求的时候是会带上cookie的，这使得CSRF攻击有可乘之机</p></li></ul><h1 id="0x01-CSRF攻击"><a href="#0x01-CSRF攻击" class="headerlink" title="0x01 CSRF攻击"></a>0x01 CSRF攻击</h1><ul><li>由于同源策略的限制，跨域的ajax请求不会带cookie，然而script/iframe/img等标签却是支持跨域的，所以在请求的时候是会带上cookie的。如果用户登陆了Abank.com，那么cookie里面就有了tocken，同时又打开了另外一个标签页访问了evil.com，这个网页里面有一个iframe:</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://Abank.com/app/transferFunds?amount=1500&amp;destinationAccount="</span><span class="attr">attackeraccountnumber</span>" &gt;</span></span><br></pre></td></tr></table></figure><ul><li>防CSRF攻击的策略就是将token添加到请求的参数里面，也就是说每个需要验证身份的请求都要显式地带上token值,目的就是让请求不可预知，就算攻击者得到了你的登录token，也没有办法构造转账的请求，因为转账的请求带有一个不可预知的，随机的token作为保护，当然也可以加入一些人机交换，例如验证码之类的</li></ul><h1 id="0x02-Cross-domain-和-Silverlight-的跨越配置文件"><a href="#0x02-Cross-domain-和-Silverlight-的跨越配置文件" class="headerlink" title="0x02 Cross-domain 和 Silverlight 的跨越配置文件"></a>0x02 Cross-domain 和 Silverlight 的跨越配置文件</h1><p>这两个配置文件必须设置严格，防止不必要跨域</p><h1 id="Refer-link"><a href="#Refer-link" class="headerlink" title="Refer link"></a>Refer link</h1><p><a href="https://www.gracefulsecurity.com/cross-domain-flash-and-silverlight-crossdomain-xml/" target="_blank" rel="noopener">https://www.gracefulsecurity.com/cross-domain-flash-and-silverlight-crossdomain-xml/</a></p><p><a href="https://www.gracefulsecurity.com/what-is-cross-site-request-forgery/" target="_blank" rel="noopener">https://www.gracefulsecurity.com/what-is-cross-site-request-forgery/</a></p><p><a href="http://www.veracode.com/security/csrf" target="_blank" rel="noopener">http://www.veracode.com/security/csrf</a></p><p><a href="http://yincheng.site/cross-domain" target="_blank" rel="noopener">http://yincheng.site/cross-domain</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x00-什么是同源策略-SOP&quot;&gt;&lt;a href=&quot;#0x00-什么是同源策略-SOP&quot; class=&quot;headerlink&quot; title=&quot;0x00 什么是同源策略(SOP)&quot;&gt;&lt;/a&gt;0x00 什么是同源策略(SOP)&lt;/h1&gt;&lt;p&gt;在Web安全中，SOP是
      
    
    </summary>
    
    
      <category term="Web security" scheme="http://yoursite.com/tags/Web-security/"/>
    
  </entry>
  
  <entry>
    <title>XXE 攻击(2)</title>
    <link href="http://yoursite.com/2018/02/08/XXE-%E6%94%BB%E5%87%BB%E2%80%94%E2%80%942/"/>
    <id>http://yoursite.com/2018/02/08/XXE-攻击——2/</id>
    <published>2018-02-07T20:57:37.000Z</published>
    <updated>2018-02-28T03:46:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>在上一遍文章中提到了XML的格式定义DTD存在外部实体引用攻击，这次来学习一下主流的XML格式定义XML Schema，刚好最近上了java的spring培训，里面定义beans的时候主要配置的就是XML文档，所以也是时候再学学xml的相关知识了，网上很多相关文章，主要记录一些和安全相关的设置吧</p><h1 id="0x01-XML-Schema-基础"><a href="#0x01-XML-Schema-基础" class="headerlink" title="0x01 XML Schema 基础"></a>0x01 XML Schema 基础</h1><p>XML Schema 描述了 XML文档的结构，也是由 XML 编写，其中Schema可以理解为约束、概要，但不推荐使用中文进行记忆，Schema就是Schema</p><ul><li>一个普通的xml文档：</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">to</span>&gt;</span>Tove<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">from</span>&gt;</span>Jani<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">heading</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span>Don't forget me this weekend!<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>一个XML Schema定义</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">xs:schema</span> <span class="attr">xmlns:xs</span>=<span class="string">"http://www.w3.org/2001/XMLSchema"</span></span></span><br><span class="line"><span class="tag"><span class="attr">targetNamespace</span>=<span class="string">"http://www.w3schools.com"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns</span>=<span class="string">"http://www.w3schools.com"</span></span></span><br><span class="line"><span class="tag"><span class="attr">elementFormDefault</span>=<span class="string">"qualified"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">"note"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">xs:complexType</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xs:sequence</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">"to"</span> <span class="attr">type</span>=<span class="string">"xs:string"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">"from"</span> <span class="attr">type</span>=<span class="string">"xs:string"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">"heading"</span> <span class="attr">type</span>=<span class="string">"xs:string"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">"body"</span> <span class="attr">type</span>=<span class="string">"xs:string"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xs:sequence</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">xs:complexType</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xs:element</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">xs:schema</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>第一句代表xml版本号，1.0版本</li><li><xs:schema> </xs:schema> schema的根元素</li><li>xmlns:xs=”<a href="http://www.w3.org/2001/XMLSchema" target="_blank" rel="noopener">http://www.w3.org/2001/XMLSchema</a>“ 代表schema 中用到的元素和数据类型来自命名空间 “<a href="http://www.w3.org/2001/XMLSchema&quot;。同时它还规定了来自命名空间" target="_blank" rel="noopener">http://www.w3.org/2001/XMLSchema&quot;。同时它还规定了来自命名空间</a> “<a href="http://www.w3.org/2001/XMLSchema" target="_blank" rel="noopener">http://www.w3.org/2001/XMLSchema</a>“ 的元素和数据类型应该使用前缀 xs：</li><li>targetNamespace=”<a href="http://www.runoob.com" target="_blank" rel="noopener">http://www.runoob.com</a>“ 显示被此 schema 定义的元素 (note, to, from, heading, body) 来自命名空间： “<a href="http://www.runoob.com&quot;。" target="_blank" rel="noopener">http://www.runoob.com&quot;。</a></li><li>xmlns=”<a href="http://www.runoob.com" target="_blank" rel="noopener">http://www.runoob.com</a>“ xmlns=”<a href="http://www.runoob.com" target="_blank" rel="noopener">http://www.runoob.com</a>“</li><li>elementFormDefault=”qualified” 指出任何 XML 实例文档所使用的且在此 schema 中声明过的元素必须被命名空间限定。</li><li>后面是各种元素定义，数据类型定义等</li></ol><p>详细的关于XML Schema定义可以参考下面的链接</p><p><a href="http://www.runoob.com/schema/schema-schema.html" target="_blank" rel="noopener">http://www.runoob.com/schema/schema-schema.html</a></p><ul><li>xml文档引用上面定义的Schema:note.xsd(这是重点要理解的)</li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">&lt;?xml version="1.0"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">note</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns</span>=<span class="string">"http://www.w3schools.com"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.w3schools.com note.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">to</span>&gt;</span>Tove<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">from</span>&gt;</span>Jani<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">heading</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span>Don't forget me this weekend!<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>xmlns=”<a href="http://www.w3schools.com" target="_blank" rel="noopener">http://www.w3schools.com</a>“ 定义了默认的命名空间，如果没有定义其他的命名空间，XML 文档会使用这个作为schema 验证器</li><li>xmlns:xsi=”<a href="http://www.w3.org/2001/XMLSchema-instance" target="_blank" rel="noopener">http://www.w3.org/2001/XMLSchema-instance</a>“ 定义了一个指定的命名空间，并把这个空间 alias - xsi(别名)</li><li>xsi:schemaLocation=”<a href="http://www.w3schools.com" target="_blank" rel="noopener">http://www.w3schools.com</a> note.xsd”&gt; 定义了xsi的schemaLocation属性，格式为：namespace and XSD-location-URI，中间用换行符或者空格作为分隔符</li></ol><p>下来来自stackoverflow的详细解释，好明白的讲解：</p><p><a href="https://stackoverflow.com/questions/34202967/xmlns-xmlnsxsi-xsischemalocation-and-targetnamespace" target="_blank" rel="noopener">https://stackoverflow.com/questions/34202967/xmlns-xmlnsxsi-xsischemalocation-and-targetnamespace</a></p><h1 id="0x02-XML-Schema攻击的分类"><a href="#0x02-XML-Schema攻击的分类" class="headerlink" title="0x02 XML Schema攻击的分类"></a>0x02 XML Schema攻击的分类</h1><p>XML Schema攻击分为,下面的没有怎么研究，希望日后可以补充，都是看家人的总结来的</p><p>1.schemaLocation</p><p>2.noNamespaceSchemaLocation</p><p>3.XInclude。</p><p>4.XSLT 攻击</p><p>refer link</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzIwNDI4MzAwOA==&amp;mid=2650524176&amp;idx=1&amp;sn=e1f8ebb128ae248d69e2947e4ac9bcf2&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzIwNDI4MzAwOA==&amp;mid=2650524176&amp;idx=1&amp;sn=e1f8ebb128ae248d69e2947e4ac9bcf2&amp;scene=21#wechat_redirect</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h1&gt;&lt;p&gt;在上一遍文章中提到了XML的格式定义DTD存在外部实体引用攻击，这次来学习一下主流的XML格式定义X
      
    
    </summary>
    
    
      <category term="Web security" scheme="http://yoursite.com/tags/Web-security/"/>
    
  </entry>
  
  <entry>
    <title>XXE 攻击</title>
    <link href="http://yoursite.com/2018/02/06/XXE-%E6%94%BB%E5%87%BB/"/>
    <id>http://yoursite.com/2018/02/06/XXE-攻击/</id>
    <published>2018-02-06T11:14:30.000Z</published>
    <updated>2018-02-28T03:47:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-什么是-XXE"><a href="#0x00-什么是-XXE" class="headerlink" title="0x00 什么是 XXE"></a>0x00 什么是 XXE</h1><p>XXE：XML External Entity，即外部实体攻击,其本质是利用应用过滤不严格进行xml语句的注入攻击，感觉应该属于注入攻击的一种，</p><h1 id="0x01-XML-文档的DTD"><a href="#0x01-XML-文档的DTD" class="headerlink" title="0x01 XML 文档的DTD"></a>0x01 XML 文档的DTD</h1><p>文档类型定义（DTD）可定义合法的XML文档构建模块。它使用一系列合法的元素来定义文档的结构，包括定义了XML文档的元素(!ELEMENT)，属性(!ATTLIST)，实体(!ENTITY),<strong>其中实体的定义为：实体是用于定义引用普通文本或特殊字符的快捷方式的变量。类似于定义了一个变量</strong></p><p>详细的DTD定义可以参考下面的链接：</p><p><a href="http://www.runoob.com/dtd/dtd-building.html" target="_blank" rel="noopener">http://www.runoob.com/dtd/dtd-building.html</a></p><h1 id="x03-内部实体和外部实体"><a href="#x03-内部实体和外部实体" class="headerlink" title="x03 内部实体和外部实体"></a>x03 内部实体和外部实体</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">DTD 定义内部实体</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">!ENTITY</span> <span class="attr">writer</span> "<span class="attr">Donald</span> <span class="attr">Duck.</span>"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">!ENTITY</span> <span class="attr">copyright</span> "<span class="attr">Copyright</span> <span class="attr">runoob.com</span>"&gt;</span></span><br><span class="line"></span><br><span class="line">XML引用上面实体的内部定义：</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">author</span>&gt;</span>&amp;writer;&amp;copyright;<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">DTD 定义外部实体，加了一个SYSTEM关键字</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">!ENTITY</span> <span class="attr">writer</span> <span class="attr">SYSTEM</span> "<span class="attr">http:</span>//<span class="attr">www.runoob.com</span>/<span class="attr">entities.dtd</span>"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">!ENTITY</span> <span class="attr">copyright</span> <span class="attr">SYSTEM</span> "<span class="attr">http:</span>//<span class="attr">www.runoob.com</span>/<span class="attr">entities.dtd</span>"&gt;</span></span><br><span class="line"></span><br><span class="line">XML引用上面定义的外部实体</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">author</span>&gt;</span>&amp;writer;&amp;copyright;<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="0x02-XXE-攻击PAYLOAD"><a href="#0x02-XXE-攻击PAYLOAD" class="headerlink" title="0x02 XXE 攻击PAYLOAD"></a>0x02 XXE 攻击PAYLOAD</h1><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE foo [</span></span><br><span class="line"><span class="meta">    &lt;!ELEMENT foo ANY &gt;</span></span><br><span class="line"><span class="meta">    &lt;!ENTITY  xxe SYSTEM "file:///c:/windows/win.ini" &gt; #定义了外部实体引用</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">foo</span>&gt;</span>&amp;xxe;<span class="tag">&lt;/<span class="name">foo</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="0x02-XXE攻击原理"><a href="#0x02-XXE攻击原理" class="headerlink" title="0x02 XXE攻击原理"></a>0x02 XXE攻击原理</h1><p>在 XML1.0 标准里，XML文档里的实体的标识符可以访问本地远程内容，如果在外部实体引用的过程中，注入恶意代码，即可引发信息泄露等安全问题。</p><p>比如上述示例中所演示的 URI，即可读取 passwd 中的敏感信息。</p><h1 id="0x03-攻击方式"><a href="#0x03-攻击方式" class="headerlink" title="0x03 攻击方式"></a>0x03 攻击方式</h1><ul><li><p>有回显</p></li><li><p>无回显</p></li></ul><p>具体就不继续了，网上一大堆文章，反正了解了核心概念就可以了，其他利用姿势自行Google</p><h1 id="0x04-如何防御"><a href="#0x04-如何防御" class="headerlink" title="0x04 如何防御"></a>0x04 如何防御</h1><p>可以将 libxml 版本升级到 2.9.0 以后，因为 libxml 2.9.0 以后默认是不解析外部实体的，还要做输入过滤，错误处理等，反正应对注入的措施都要有</p><h1 id="Bonus"><a href="#Bonus" class="headerlink" title="Bonus"></a>Bonus</h1><p>XML Schema 很快会将 DTD 取而代之，但 XML Schema 也会存在注入的问题，这个后面再慢慢看，还有Xpath注入等，关于xml的安全问题还是由很多的</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://mp.weixin.qq.com/s/vkCdz6YCoiiJPI30KePD6g" target="_blank" rel="noopener">http://mp.weixin.qq.com/s/vkCdz6YCoiiJPI30KePD6g</a></p><p><a href="http://www.runoob.com/dtd/dtd-summary.html" target="_blank" rel="noopener">http://www.runoob.com/dtd/dtd-summary.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x00-什么是-XXE&quot;&gt;&lt;a href=&quot;#0x00-什么是-XXE&quot; class=&quot;headerlink&quot; title=&quot;0x00 什么是 XXE&quot;&gt;&lt;/a&gt;0x00 什么是 XXE&lt;/h1&gt;&lt;p&gt;XXE：XML External Entity，即外部实体攻
      
    
    </summary>
    
    
      <category term="Web security" scheme="http://yoursite.com/tags/Web-security/"/>
    
  </entry>
  
  <entry>
    <title>Jekins security related</title>
    <link href="http://yoursite.com/2018/02/05/Jekins-security-related-doc/"/>
    <id>http://yoursite.com/2018/02/05/Jekins-security-related-doc/</id>
    <published>2018-02-05T15:08:20.000Z</published>
    <updated>2018-02-05T07:11:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>一些Jekins安全配置和漏洞的文章：</p><p><a href="https://www.blackhat.com/docs/eu-15/materials/eu-15-Mittal-Continuous-Intrusion-Why-CI-Tools-Are-An-Attackers-Best-Friend.pdf" target="_blank" rel="noopener">https://www.blackhat.com/docs/eu-15/materials/eu-15-Mittal-Continuous-Intrusion-Why-CI-Tools-Are-An-Attackers-Best-Friend.pdf</a></p><p><a href="https://www.sans.org/reading-room/whitepapers/bestprac/securing-jenkins-ci-systems-36872" target="_blank" rel="noopener">https://www.sans.org/reading-room/whitepapers/bestprac/securing-jenkins-ci-systems-36872</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一些Jekins安全配置和漏洞的文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.blackhat.com/docs/eu-15/materials/eu-15-Mittal-Continuous-Intrusion-Why-CI-Tools-Are-An-A
      
    
    </summary>
    
    
      <category term="Jekins" scheme="http://yoursite.com/tags/Jekins/"/>
    
  </entry>
  
  <entry>
    <title>Java由反射到命令执行</title>
    <link href="http://yoursite.com/2018/02/01/Java%E7%94%B1%E5%8F%8D%E5%B0%84%E5%88%B0%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"/>
    <id>http://yoursite.com/2018/02/01/Java由反射到命令执行/</id>
    <published>2018-01-31T17:26:50.000Z</published>
    <updated>2018-03-20T08:28:04.303Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-什么是Java反射和应用场景"><a href="#0x00-什么是Java反射和应用场景" class="headerlink" title="0x00 什么是Java反射和应用场景"></a>0x00 什么是Java反射和应用场景</h1><ul><li>详细的反射教程可以参考下面的链接，讲得超级详细，简单讲就是在程序运行时动态获得类的属性和方法，并可以动态创建对象</li></ul><p><a href="http://www.sczyh30.com/posts/Java/java-reflection-1/#%E4%B8%80%E3%80%81%E5%9B%9E%E9%A1%BE%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%EF%BC%9F" target="_blank" rel="noopener">关于反射的详解教程请点我</a></p><ul><li>应用场景</li></ul><blockquote><p>当我们在使用IDE(如Eclipse，IDEA)时，当我们输入一个对象或类并想调用它的属性或方法时，一按点号，编译器就会自动列出它的属性或方法，这里就会用到反射。反射最重要的用途就是开发各种通用框架。<br>很多框架（比如Spring）都是配置化的（比如通过XML文件配置JavaBean,Action之类的），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。</p></blockquote><ul><li>简单介绍几个主要方法，详解的用法可以参考我上面给的链接</li></ul><ol><li>加载类，得到指定类的Class对象</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">"com.yano.reflect.Consumer"</span>);</span><br><span class="line">Class clazz1 = <span class="keyword">new</span> Consumer().getClass();</span><br><span class="line">Class class2 = Person.class;</span><br></pre></td></tr></table></figure><ol><li>创建实例</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法一：</span><br><span class="line">Class&lt;?&gt; c = String.class;</span><br><span class="line">Object str = c.newInstance();</span><br><span class="line">方法二：</span><br><span class="line"><span class="comment">//获取String所对应的Class对象</span></span><br><span class="line">Class&lt;?&gt; c = String.class;</span><br><span class="line"><span class="comment">//获取String类带一个String参数的构造器</span></span><br><span class="line">Constructor constructor = c.getConstructor(String.class);</span><br><span class="line"><span class="comment">//根据构造器创建实例</span></span><br><span class="line">Object obj = constructor.newInstance(<span class="string">"23333"</span>);</span><br><span class="line">System.out.println(obj);</span><br></pre></td></tr></table></figure><ol><li>获取方法</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getMethod方法返回一个特定的方法，其中第一个参数为方法名称，后面的参数为方法的参数对应Class的对象</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Method <span class="title">getMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span></span></span><br></pre></td></tr></table></figure><h1 id="0x02-Java的命令执行类："><a href="#0x02-Java的命令执行类：" class="headerlink" title="0x02 Java的命令执行类："></a>0x02 Java的命令执行类：</h1><ul><li>java.lang.Runtime类,下面是官方文档解释</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Runtime extends Object</span><br><span class="line"></span><br><span class="line">Every Java application has a single instance of class Runtime that allows the application to interface with the environment in which the application is running. The current runtime can be obtained from the getRuntime method.</span><br><span class="line">An application cannot create its own instance of this class.</span><br></pre></td></tr></table></figure><ul><li>其中主要的方法是：getRuntime(),得到一个和当前程序相关联的Runtime类的对象，文档解释如下：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static Runtime getRuntime()</span><br><span class="line">Returns the runtime object associated with the current Java application. Most of the methods of class Runtime are instance methods and must be invoked with respect to the current runtime object.</span><br><span class="line">Returns:</span><br><span class="line">the Runtime object associated with the current Java application.</span><br></pre></td></tr></table></figure><ul><li>这个Runtime对象再调用exec()方法执行命令，详细文档解释如下：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Process exec(String command)</span><br><span class="line">             throws IOException</span><br><span class="line">Executes the specified string command in a separate process.</span><br><span class="line">This is a convenience method. An invocation of the form exec(command) behaves in exactly the same way as the invocation exec(command, null, null).</span><br></pre></td></tr></table></figure><ul><li>最后综合使用,在我的mac打开了计算器程序</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, IOException </span>&#123;</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">"open /Applications/Calculator.app/"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="0x03-命令执行漏洞的实现，如何取得Runtime类是关键，其中一种常用方式就是通过反射"><a href="#0x03-命令执行漏洞的实现，如何取得Runtime类是关键，其中一种常用方式就是通过反射" class="headerlink" title="0x03 命令执行漏洞的实现，如何取得Runtime类是关键，其中一种常用方式就是通过反射"></a>0x03 命令执行漏洞的实现，如何取得Runtime类是关键，其中一种常用方式就是通过反射</h1><ol><li>场景一 Android API17 前的Webview加了addJavascriptInterface()方法，映射了一个Java对象到js中</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebAppInterface</span> </span>&#123;</span><br><span class="line">    Context mContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Instantiate the interface and set the context */</span></span><br><span class="line">    WebAppInterface(Context c) &#123;</span><br><span class="line">        mContext = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Show a toast from the web page */</span></span><br><span class="line">    <span class="comment">/*@JavascriptInterface  /*新的要求，加注解,API17以上*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showToast</span><span class="params">(String toast)</span> </span>&#123;</span><br><span class="line">        Toast.makeText(mContext, toast, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WebView webView = (WebView) findViewById(R.id.webview);</span><br><span class="line">webView.addJavascriptInterface(<span class="keyword">new</span> WebAppInterface(<span class="keyword">this</span>), <span class="string">"Android"</span>);</span><br></pre></td></tr></table></figure><ul><li>上面这段Android代码中，把WebAppInterface类映射到了js中的的Android对象上，所以可以在js中调用WebAppInterface类的方法</li></ul><p>对于强迫症患者，一定会疑惑这个“Android”在js中算什么，类？还是实例？，下面一段是Google文档的解释,Webview帮我们初始化好这个js的”Android”对象，可以直接在JavaScript中调用</p><blockquote><p>You can bind this class to the JavaScript that runs in your WebView with addJavascriptInterface() and name the interface Android. For example:<br>This creates an interface called Android for JavaScript running in the WebView. At this point, your web application has access to the WebAppInterface class. For example, here’s some HTML and JavaScript that creates a toast message using the new interface when the user clicks a button:<br>There’s no need to initialize the Android interface from JavaScript. The WebView automatically makes it available to your web page. So, at the click of the button, the showAndroidToast() function uses the Android interface to call the WebAppInterface.showToast() method.</p></blockquote><ul><li>结合前面的Java反射知识，既然暴露了Java对象给JavaScript操作，首先可以通过这个这个对象的“getClass()”方法获得对应类的Class对象，然后调用Class对象的”forname()”方法加载指定的“Runtime”类，这个特殊的“Runtime”类再调用”getmethod()”方法调用类里面的getruntime方法，返回一个Method对象，最后调用”invoke()”方法执行Runtime类的exec()方法。。。这就是整个思路了</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.test;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebAppInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showToast</span><span class="params">(String toast)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"just a test class"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException,</span></span><br><span class="line"><span class="function">            InstantiationException, IOException, NoSuchMethodException, InvocationTargetException </span>&#123;</span><br><span class="line">        WebAppInterface Android = <span class="keyword">new</span> WebAppInterface();<span class="comment">/* 模拟一个可以被js调用的实例 */</span></span><br><span class="line">        Method method = Android.getClass().forName(<span class="string">"java.lang.Runtime"</span>).getMethod(<span class="string">"getRuntime"</span>,<span class="keyword">null</span>);</span><br><span class="line">        Runtime run = (Runtime) method.invoke(<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        run.exec(<span class="string">"open /Applications/Calculator.app/"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/RCE.jpg" alt="效果图"></p><h1 id="0x04-Runtime类的限制"><a href="#0x04-Runtime类的限制" class="headerlink" title="0x04 Runtime类的限制"></a>0x04 Runtime类的限制</h1><p>不同环境下命令的编写有差异，例如Bash,powershell,python,perl,所以我这里找来了一个在线工具自动格式化相应环境的命令</p><p><a href="http://jackson.thuraisamy.me/runtime-exec-payloads.html" target="_blank" rel="noopener">http://jackson.thuraisamy.me/runtime-exec-payloads.html</a></p><h1 id="Bonus"><a href="#Bonus" class="headerlink" title="Bonus"></a>Bonus</h1><p>关于Java泛型的一点讲解：泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p><p><a href="https://www.jianshu.com/p/95f349258afb" target="_blank" rel="noopener">详细的Java 泛型讲解请点击我</a></p><ol><li>不用泛型直接通过反射创建类的实例，需要进行强制类型转换</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Consumer clazz;</span><br><span class="line">clazz = (Consumer) Class.forName(<span class="string">"com.company.hsbc.Consumer"</span>).newInstance();</span><br></pre></td></tr></table></figure><ol><li>用object类型可以解决问题</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object clazz;</span><br><span class="line">clazz = Class.forName(<span class="string">"com.company.hsbc.Consumer"</span>).newInstance();</span><br></pre></td></tr></table></figure><h1 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0x00-什么是Java反射和应用场景&quot;&gt;&lt;a href=&quot;#0x00-什么是Java反射和应用场景&quot; class=&quot;headerlink&quot; title=&quot;0x00 什么是Java反射和应用场景&quot;&gt;&lt;/a&gt;0x00 什么是Java反射和应用场景&lt;/h1&gt;&lt;ul&gt;

      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Android支付宝克隆漏洞</title>
    <link href="http://yoursite.com/2018/01/30/Android%E6%94%AF%E4%BB%98%E5%AE%9D%E5%85%8B%E9%9A%86%E6%BC%8F%E6%B4%9E/"/>
    <id>http://yoursite.com/2018/01/30/Android支付宝克隆漏洞/</id>
    <published>2018-01-30T15:54:33.000Z</published>
    <updated>2018-01-30T09:32:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章介绍了Android Webview组件的安全问题，其中一个就是file域访问限制不严格导致数据泄露，前段时间很火的支付宝克隆漏洞也是基于file协议的权限设置不当造成的，参考了很多文章总结一下攻击流程：</p><h1 id="1-克隆漏洞基本原理解释："><a href="#1-克隆漏洞基本原理解释：" class="headerlink" title="1 克隆漏洞基本原理解释："></a>1 克隆漏洞基本原理解释：</h1><ul><li><p>Step 1 ：通过 URL Scheme 的方式唤起打开 App 里暴露出去的(export=true)带 WebView 组件的 Activity , 这里需要得到支付宝的Scheme，然后通过这些Scheme打开Webview</p></li><li><p>Step 2 ：在发送给目标的网页中通过a标签调用支付宝带 WebView 组件的 Activity，从而实现在支付宝中打开Webview</p></li><li><p>Step 3 ：Webview加载攻击者的攻击脚本到本地SD卡的download目录：</p></li><li><p>Step 4 ：再利用file协议加载攻击者存在本地的脚本</p></li><li><p>Step 5 ：由于这个Webview是通过支付宝打开的，再通过file协议读取本地攻击脚本，所以本地攻击脚本实际是支付宝打开的，可以读取支付宝沙盒进程的个人用户数据，并上传回服务器，到此，攻击完成，成功得到用户的支付宝数据</p></li><li><p>Step 6 ：攻击者加载目标用户的支付宝数据，支付宝没有二次验证机器指纹直接默认登录成功，攻击者可以使用用户的支付宝进行支付</p></li></ul><h1 id="2-漏洞利用的关键点："><a href="#2-漏洞利用的关键点：" class="headerlink" title="2 漏洞利用的关键点："></a>2 漏洞利用的关键点：</h1><ol><li>在 Step 1 中：</li></ol><p>这里使用了支付宝定义的URL Scheme，如何得到有效的Scheme，使得可以通过a标签启动支付宝的Webview，这是一个关键点</p><ol><li><p>在 Step 2 中：<br>构造一个网页，网页代码要包含：1.启动支付宝的Webview  2.下载攻击脚本到本地SD卡的download目录 3.利用file协议加载本地攻击脚本</p></li><li><p>在 Step 5 中：<br>下载到本地的攻击脚本再一次利用file协议读取支付宝的个人数据，并上传到攻击者的服务器或者设备中</p></li><li><p>攻击成功的两个关键点：</p></li></ol><ul><li><p>WebView中setAllowFileAccessFromFileURLs 或setAllowUniversalAccessFromFileURLsAPI配置为true；</p></li><li><p>WebView可以直接被外部调用，并能够加载外部可控的HTML文件</p></li></ul><h1 id="3-相关技术介绍："><a href="#3-相关技术介绍：" class="headerlink" title="3 相关技术介绍："></a>3 相关技术介绍：</h1><ul><li>什么是URL Scheme：</li></ul><blockquote><p>android中的scheme是一种页面内跳转协议，是一种非常好的实现机制，通过定义自己的scheme协议，可以非常方便跳转app中的各个页面；通过scheme协议，服务器可以定制化告诉App跳转那个页面，可以通过通知栏消息定制化跳转页面，可以通过H5页面跳转页面等。</p><p>客户端应用可以向操作系统注册一个 URL scheme，该 scheme 用于从浏览器或其他应用中启动本应用。通过指定的 URL 字段，可以让应用在被调起后直接打开某些特定页面，比如商品详情页、活动详情页等等。也可以执行某些指定动作，如完成支付等。也可以在应用内通过 html 页来直接调用显示 app 内的某个页面</p></blockquote><h1 id="4-总结："><a href="#4-总结：" class="headerlink" title="4 总结："></a>4 总结：</h1><p>这次的克隆漏洞利用的都是Android Webview的已知漏洞，但却玩出了新花样，但却引出了一些问题，例如Chrome打开网页自动下载没有一丁点提示，支付宝没有对用户进行二次设备验证等</p><h1 id="5-refer-link："><a href="#5-refer-link：" class="headerlink" title="5 refer link："></a>5 refer link：</h1><p>关于Android平台WebView控件存在跨域访问高危漏洞的安全公告<br><a href="http://www.cnvd.org.cn/webinfo/show/4365?from=timeline&amp;isappinstalled=0" target="_blank" rel="noopener">http://www.cnvd.org.cn/webinfo/show/4365?from=timeline&amp;isappinstalled=0</a></p><p>“应用克隆”攻击模型<br><a href="https://mp.weixin.qq.com/s/pQqOLQS_hWfv8btYpYK1xQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/pQqOLQS_hWfv8btYpYK1xQ</a></p><p>Android安全开发之浅谈网页打开APP<br><a href="https://yq.aliyun.com/articles/57088" target="_blank" rel="noopener">https://yq.aliyun.com/articles/57088</a></p><p>Webview跨源攻击分析<br><a href="http://blogs.360.cn/360mobile/2014/09/22/webview%E8%B7%A8%E6%BA%90%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">http://blogs.360.cn/360mobile/2014/09/22/webview%E8%B7%A8%E6%BA%90%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/</a></p><p>Attack Your Android Apps By Webview<br><a href="http://blog.knownsec.com/2013/03/attack-your-android-apps-by-webview/" target="_blank" rel="noopener">http://blog.knownsec.com/2013/03/attack-your-android-apps-by-webview/</a></p><p>Andorid Intent 与 Chrome<br><a href="https://developer.chrome.com/multidevice/android/intents?spm=5176.100239.blogcont57088.9.1c29be50KIPvAG" target="_blank" rel="noopener">https://developer.chrome.com/multidevice/android/intents?spm=5176.100239.blogcont57088.9.1c29be50KIPvAG</a></p><p>克隆攻击分析与复现<br><a href="https://xianzhi.aliyun.com/forum/topic/1952" target="_blank" rel="noopener">https://xianzhi.aliyun.com/forum/topic/1952</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一篇文章介绍了Android Webview组件的安全问题，其中一个就是file域访问限制不严格导致数据泄露，前段时间很火的支付宝克隆漏洞也是基于file协议的权限设置不当造成的，参考了很多文章总结一下攻击流程：&lt;/p&gt;
&lt;h1 id=&quot;1-克隆漏洞基本原理解释：&quot;&gt;&lt;a
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android WebView Vulnerabilities</title>
    <link href="http://yoursite.com/2018/01/27/Android-WebView-Vulnerabilities/"/>
    <id>http://yoursite.com/2018/01/27/Android-WebView-Vulnerabilities/</id>
    <published>2018-01-26T17:29:30.000Z</published>
    <updated>2018-01-29T10:27:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天专门总结一下Android Webview漏洞，因为这是一个安全大坑，我也被坑了…郁闷，平时复习一下就好了</p><h1 id="1-基本开发知识："><a href="#1-基本开发知识：" class="headerlink" title="1 基本开发知识："></a>1 基本开发知识：</h1><p>If you want to deliver a web application (or just a web page) as a part of a client application, you can do it using WebView。顾名思义就是开发web app之类的，用处很多，不详细讲了，看开发文档写得很清楚</p><ul><li>添加Webview,步骤为写配置文件到layout，建立Webview类，然后取得Internet权限，一目了然</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">写配置文件：</span><br><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"utf-8"</span>?&gt;</span><br><span class="line">&lt;WebView  xmlns:android=<span class="string">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    android:id=<span class="string">"@+id/webview"</span></span><br><span class="line">    android:layout_width=<span class="string">"fill_parent"</span></span><br><span class="line">    android:layout_height=<span class="string">"fill_parent"</span></span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">新建类：</span><br><span class="line">WebView myWebView = (WebView) findViewById(R.id.webview);</span><br><span class="line">myWebView.loadUrl(&quot;http://www.example.com&quot;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">申请Internet权限：</span><br><span class="line">&lt;manifest ... &gt;</span><br><span class="line">    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure><ul><li>使用JavaScript（JavaScript is disabled in a WebView by default）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">通过Websettings开启JavaScript</span><br><span class="line">WebView myWebView = (WebView) findViewById(R.id.webview);</span><br><span class="line">WebSettings webSettings = myWebView.getSettings();</span><br><span class="line">webSettings.setJavaScriptEnabled(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><ul><li>通过绑定JavaScript和你指定的android代码,让JavaScript可以调用你指定的代码，例如你定义了一个WebAppInterface类</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebAppInterface</span> </span>&#123;</span><br><span class="line">    Context mContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Instantiate the interface and set the context */</span></span><br><span class="line">    WebAppInterface(Context c) &#123;</span><br><span class="line">        mContext = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Show a toast from the web page */</span></span><br><span class="line">    <span class="meta">@JavascriptInterface</span>  <span class="comment">/*新的要求，加注解,API17以上*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showToast</span><span class="params">(String toast)</span> </span>&#123;</span><br><span class="line">        Toast.makeText(mContext, toast, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">WebView webView = (WebView) findViewById(R.id.webview);</span><br><span class="line">webView.addJavascriptInterface(<span class="keyword">new</span> WebAppInterface(<span class="keyword">this</span>), <span class="string">"Android"</span>);</span><br></pre></td></tr></table></figure><ul><li>到此，JavaScript就可以调用你定义的函数了</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Say hello"</span> <span class="attr">onClick</span>=<span class="string">"showAndroidToast('Hello Android!')"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    function showAndroidToast(toast) &#123;</span></span><br><span class="line"><span class="undefined">        Android.showToast(toast); /*There's no need to initialize the Android interface from JavaScript. The WebView automatically makes it available to your web page</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="2-存在的安全问题："><a href="#2-存在的安全问题：" class="headerlink" title="2 存在的安全问题："></a>2 存在的安全问题：</h1><h2 id="1-Webview-任意代码执行漏洞"><a href="#1-Webview-任意代码执行漏洞" class="headerlink" title="1 Webview 任意代码执行漏洞"></a>1 Webview 任意代码执行漏洞</h2><ol><li>问题方法”addJavascriptInterface()”,上文基础部分中提到这个方法让JavaScript调用你定义的JAVA函数</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mWebView.addJavascriptInterface(<span class="keyword">new</span> TestAddJsInterface(), “myjs”);</span><br></pre></td></tr></table></figure><ol><li>在API17之前，上面的“addJavascriptInterface()”方法会导致出现问题，网页中的JS脚本可以利用接口“myjs”调用App中的Java代码，而Java对象继承关系会导致很多Public的函数及getClass函数都可以在JS中被访问，结合Java的反射机制，攻击者还可以获得系统类的函数，进而可以进行任意代码执行</li></ol><p>类似的攻击代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">execute</span><span class="params">(cmdArgs)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="comment">// 步骤1：遍历 window 对象</span></span><br><span class="line">    <span class="comment">// 目的是为了找到包含 getClass()的对象</span></span><br><span class="line">    <span class="comment">// 因为Android映射的"myjs"对象也在window中，所以肯定会遍历到</span></span><br><span class="line">    <span class="keyword">for</span> (var obj in window) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"getClass"</span> in window[obj]) &#123;  </span><br><span class="line"></span><br><span class="line">      <span class="comment">// 步骤2：利用反射调用forName（）得到Runtime类对象</span></span><br><span class="line">            alert(obj);          </span><br><span class="line">            <span class="keyword">return</span>  window[obj].getClass().forName(<span class="string">"java.lang.Runtime"</span>)  </span><br><span class="line"></span><br><span class="line">      <span class="comment">// 步骤3：以后，就可以调用静态方法来执行一些命令，比如访问文件的命令</span></span><br><span class="line">getMethod(<span class="string">"getRuntime"</span>,<span class="keyword">null</span>).invoke(<span class="keyword">null</span>,<span class="keyword">null</span>).exec(cmdArgs);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 从执行命令后返回的输入流中得到字符串，有很严重暴露隐私的危险。</span></span><br><span class="line"><span class="comment">// 如执行完访问文件的命令之后，就可以得到文件名的信息了。</span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>当一些 APP 通过扫描二维码打开一个外部网页时，攻击者就可以执行这段 js 代码进行漏洞攻击</p></li><li><p>关键的JAVA反射思路如下：</p></li></ol><ul><li>JAVA中的对象有一公共的方法：getClass() ；</li><li>该方法可以获取到当前类的Class对象</li><li>该类有一关键的方法： Class.forName；</li><li>该方法可以加载一个类（可加载 java.lang.Runtime 类）</li><li>而该类是可以执行本地命令的</li></ul><ol><li>解决方案：</li></ol><p>Google在API_17中规定允许被调用的函数必须以@JavascriptInterface进行注解，理论上如果APP依赖的API为17或者以上，就不会受该问题的影响。所以检查API的版本和关键函数的注解可以有效识别漏洞</p><h2 id="2-WebView域控制不严格漏洞"><a href="#2-WebView域控制不严格漏洞" class="headerlink" title="2 WebView域控制不严格漏洞"></a>2 WebView域控制不严格漏洞</h2><p>这个漏洞主要出现在了对file协议的控制不当上，通过4个API来理解WebView中file协议的安全性，下面的代码是新建一个Webview，通过发送Intent调用这个export的activity，把intent中的data作为url传入Webview，这个data是攻击者可控的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebViewActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> WebView webView;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_webview);</span><br><span class="line">        webView = (WebView) findViewById(R.id.webView1);</span><br><span class="line">        <span class="comment">//webView.getSettings().setAllowFileAccess(false);                    (1)</span></span><br><span class="line">        <span class="comment">//webView.getSettings().setJavaScriptEnabled(true);                   (2)</span></span><br><span class="line">        <span class="comment">//webView.getSettings().setAllowFileAccessFromFileURLs(true);       (3)</span></span><br><span class="line">        <span class="comment">//webView.getSettings().setAllowUniversalAccessFromFileURLs(true); (4)</span></span><br><span class="line">        Intent i = getIntent();</span><br><span class="line">        String url = i.getData().toString();</span><br><span class="line">        webView.loadUrl(url);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>/<strong>Mainifest.xml</strong>/<br>// 将该 WebViewActivity 在Mainifest.xml设置exported属性<br>// 表示：当前Activity是否可以被另一个Application的组件启动<br>android:exported=”true”</p><ol><li>setAllowFileAccess</li></ol><p>设置是否允许 WebView 使用 File 协议 ,默认设置为true，即允许在 File 域下执行任意 JavaScript 代码 ,使用 file 域加载的 js代码能够使用进行同源策略跨域访问，从而导致隐私信息泄露,如果不允许使用 file 协议，则不会存在上述的威胁；但同时也限制了 WebView 的功能，使其不能加载本地的 html 文件</p><ol><li>setAllowFileAccessFromFileURLs</li></ol><p>设置是否允许通过 file url 加载的 Js代码读取其他的本地文件,当这个方法为true时，攻击者可以读取本地敏感文件<br>在Android 4.1前默认允许<br>在Android 4.1后默认禁止</p><ol><li><p>setAllowUniversalAccessFromFileURLs<br>设置是否允许通过 file url 加载的 Javascript 可以访问其他的源(包括http、https等源)<br>在Android 4.1前默认允许（setAllowFileAccessFromFileURLs（）不起作用）<br>在Android 4.1后默认禁止</p></li><li><p>setJavaScriptEnabled</p></li></ol><p>设置是否允许 WebView 使用 JavaScript（默认是不允许）<br>但很多应用（包括移动浏览器）为了让 WebView 执行 http 协议中的 JavaScript，都会主动设置为true，不区别对待是非常危险的。</p><ol><li><p>符号链接跨源攻击 (不看)</p></li><li><p>最佳设置</p></li></ol><ul><li><p>对于不需要使用 file 协议的应用，禁用 file 协议；</p></li><li><p>对于需要使用 file 协议的应用，禁止 file 协议加载 JavaScript。</p></li></ul><h2 id="明文保存密码"><a href="#明文保存密码" class="headerlink" title="明文保存密码"></a>明文保存密码</h2><ol><li>WebView默认开启密码保存功能 ：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mWebView.setSavePassword(<span class="keyword">true</span>)</span><br></pre></td></tr></table></figure><p>开启后，在用户输入密码时，会弹出提示框：询问用户是否保存密码；<br>如果选择”是”，密码会被明文保到 /data/data/com.package.name/databases/webview.db 中，这样就有被盗取密码的危险</p><ol><li>关闭密码保存提醒</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WebSettings.setSavePassword(<span class="keyword">false</span>)</span><br></pre></td></tr></table></figure><h2 id="SSL-Error-Handling"><a href="#SSL-Error-Handling" class="headerlink" title="SSL Error Handling"></a>SSL Error Handling</h2><p>直接忽略了SSL错误的处理方法，让程序继续运行，让程序有机会收到Mitm</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceivedSslError</span><span class="params">(WebView view, SslErrorHandler handler,</span></span></span><br><span class="line"><span class="function"><span class="params">SslError error)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">handler.proceed();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="refer-link"><a href="#refer-link" class="headerlink" title="refer link:"></a>refer link:</h1><p><a href="https://pentestlab.blog/2017/02/12/android-webview-vulnerabilities/" target="_blank" rel="noopener">https://pentestlab.blog/2017/02/12/android-webview-vulnerabilities/</a></p><p><a href="https://developer.android.com/guide/webapps/webview.html" target="_blank" rel="noopener">https://developer.android.com/guide/webapps/webview.html</a></p><p><a href="https://www.jianshu.com/p/3a345d27cd42" target="_blank" rel="noopener">https://www.jianshu.com/p/3a345d27cd42</a></p><p><a href="https://www.jianshu.com/p/5b3acad0f025" target="_blank" rel="noopener">https://www.jianshu.com/p/5b3acad0f025</a></p><p><a href="http://blogs.360.cn/360mobile/2014/09/22/webview%E8%B7%A8%E6%BA%90%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">http://blogs.360.cn/360mobile/2014/09/22/webview%E8%B7%A8%E6%BA%90%E6%94%BB%E5%87%BB%E5%88%86%E6%9E%90/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天专门总结一下Android Webview漏洞，因为这是一个安全大坑，我也被坑了…郁闷，平时复习一下就好了&lt;/p&gt;
&lt;h1 id=&quot;1-基本开发知识：&quot;&gt;&lt;a href=&quot;#1-基本开发知识：&quot; class=&quot;headerlink&quot; title=&quot;1 基本开发知识：&quot;&gt;
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
</feed>
